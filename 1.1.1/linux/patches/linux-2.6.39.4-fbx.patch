diff -ruw linux-2.6.39.4/arch/arm/include/asm/setup.h linux-2.6.39.4-fbx/arch/arm/include/asm/setup.h
--- linux-2.6.39.4/arch/arm/include/asm/setup.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/arch/arm/include/asm/setup.h	2011-06-15 18:56:40.745448573 +0200
@@ -143,6 +143,37 @@
 	__u32 fmemclk;
 };
 
+/*
+ * bootloader version
+ */
+#define ATAG_LOADER_VERSION	0x41000045
+struct tag_loader_version {
+	char version[1];
+};
+
+/*
+ * freebox serial info, make RMK cry a bit more :(
+ */
+#include <linux/fbxserial.h>
+#define ATAG_FBXSERIAL          0x41000044
+struct tag_fbxserial {
+        struct fbx_serial serial;
+};
+
+/*
+ * boot_info tag, used by bank0 in conjuction with fbxhwinfo to
+ * sortout whether:
+ *
+ * - user forced a bank0 boot
+ * - user forced a bank0 boot _and_ asked for nvram to be erased.
+ */
+#define ATAG_BOOT_INFO		0x41000046
+struct tag_boot_info {
+	u32 erase_nvram;		/* == 1 if user selected nvram erase */
+	u32 bank0_forced;		/* == 1 if bank0 boot was
+					   forced by user*/
+};
+
 struct tag {
 	struct tag_header hdr;
 	union {
@@ -165,6 +196,13 @@
 		 * DC21285 specific
 		 */
 		struct tag_memclk	memclk;
+
+		/*
+		 * Freebox specific
+		 */
+		struct tag_loader_version loader_version;
+		struct tag_fbxserial	fbxserial;
+		struct tag_boot_info	boot_info;
 	} u;
 };
 
diff -ruw linux-2.6.39.4/arch/arm/Kconfig linux-2.6.39.4-fbx/arch/arm/Kconfig
--- linux-2.6.39.4/arch/arm/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/arch/arm/Kconfig	2011-09-09 18:24:20.341503842 +0200
@@ -1309,6 +1309,8 @@
 
 source "drivers/pci/Kconfig"
 
+source "drivers/pci/pcie/Kconfig"
+
 source "drivers/pcmcia/Kconfig"
 
 endmenu
diff -ruw linux-2.6.39.4/arch/arm/Kconfig.debug linux-2.6.39.4-fbx/arch/arm/Kconfig.debug
--- linux-2.6.39.4/arch/arm/Kconfig.debug	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/arch/arm/Kconfig.debug	2011-06-15 18:56:40.735448545 +0200
@@ -87,6 +87,14 @@
 	  kernel low-level debugging functions. Add earlyprintk to your
 	  kernel parameters to enable this console.
 
+config DEBUG_LL_UART1
+	bool "Use UART1 for low-level debugging"
+	depends on DEBUG_LL
+	help
+	  Say Y here to use the second UART when enabling DEBUG_LL, if
+	  your board does not have the first UART wired. This will
+	  enlarge the uncompressed kernel size by exactly four bytes.
+
 config DEBUG_ICEDCC
 	bool "Kernel low-level debugging via EmbeddedICE DCC channel"
 	depends on DEBUG_LL
diff -ruw linux-2.6.39.4/arch/arm/mach-kirkwood/common.c linux-2.6.39.4-fbx/arch/arm/mach-kirkwood/common.c
--- linux-2.6.39.4/arch/arm/mach-kirkwood/common.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/arch/arm/mach-kirkwood/common.c	2011-06-15 18:56:40.815448769 +0200
@@ -18,6 +18,7 @@
 #include <linux/ata_platform.h>
 #include <linux/mtd/nand.h>
 #include <linux/spi/orion_spi.h>
+#include <linux/spi/orion_tdm_spi.h>
 #include <net/dsa.h>
 #include <asm/page.h>
 #include <asm/timex.h>
@@ -76,7 +77,7 @@
  ****************************************************************************/
 static struct orion_ehci_data kirkwood_ehci_data = {
 	.dram		= &kirkwood_mbus_dram_info,
-	.phy_version	= EHCI_PHY_NA,
+	.phy_version	= EHCI_PHY_KW,
 };
 
 static u64 ehci_dmamask = 0xffffffffUL;
@@ -111,7 +112,15 @@
 
 void __init kirkwood_ehci_init(void)
 {
+	u32 val;
+
 	kirkwood_clk_ctrl |= CGC_USB0;
+
+	/* Analog Group Configuration Register */
+	val = readl(DEV_BUS_VIRT_BASE + 0x7c);
+	val &= ~(0x3 << 3);
+	val |= (0x1 << 3);
+	writel(val, DEV_BUS_VIRT_BASE + 0x7c);
 	platform_device_register(&kirkwood_ehci);
 }
 
@@ -121,6 +130,7 @@
  ****************************************************************************/
 struct mv643xx_eth_shared_platform_data kirkwood_ge00_shared_data = {
 	.dram		= &kirkwood_mbus_dram_info,
+	.tx_csum_limit	= 1600,
 };
 
 static struct resource kirkwood_ge00_shared_resources[] = {
@@ -183,6 +193,7 @@
 struct mv643xx_eth_shared_platform_data kirkwood_ge01_shared_data = {
 	.dram		= &kirkwood_mbus_dram_info,
 	.shared_smi	= &kirkwood_ge00_shared,
+	.tx_csum_limit	= 1600,
 };
 
 static struct resource kirkwood_ge01_shared_resources[] = {
@@ -450,13 +461,43 @@
 	platform_device_register(&kirkwood_spi);
 }
 
+/*****************************************************************************
+ * TDM SPI
+ ****************************************************************************/
+static struct orion_tdm_spi_info kirkwood_tdm_spi_plat_data = {
+};
+
+static struct resource kirkwood_tdm_spi_resources[] = {
+	{
+		.start	= TDM_SPI_PHYS_BASE,
+		.end	= TDM_SPI_PHYS_BASE + SZ_64K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device kirkwood_tdm_spi = {
+	.name		= "orion_tdm_spi",
+	.id		= 0,
+	.resource	= kirkwood_tdm_spi_resources,
+	.dev		= {
+		.platform_data	= &kirkwood_tdm_spi_plat_data,
+	},
+	.num_resources	= ARRAY_SIZE(kirkwood_tdm_spi_resources),
+};
+
+void __init kirkwood_tdm_spi_init(int *cs_gpio)
+{
+	kirkwood_clk_ctrl |= CGC_TDM;
+	memcpy(kirkwood_tdm_spi_plat_data.cs_use_gpio, cs_gpio,
+	       sizeof (kirkwood_tdm_spi_plat_data.cs_use_gpio));
+	platform_device_register(&kirkwood_tdm_spi);
+}
+
 
 /*****************************************************************************
  * I2C
  ****************************************************************************/
 static struct mv64xxx_i2c_pdata kirkwood_i2c_pdata = {
-	.freq_m		= 8, /* assumes 166 MHz TCLK */
-	.freq_n		= 3,
 	.timeout	= 1000, /* Default timeout of 1 second */
 };
 
@@ -482,8 +523,10 @@
 	},
 };
 
-void __init kirkwood_i2c_init(void)
+void __init kirkwood_i2c_init(unsigned int freq_m, unsigned int freq_n)
 {
+	kirkwood_i2c_pdata.freq_m = freq_m;
+	kirkwood_i2c_pdata.freq_n = freq_n;
 	platform_device_register(&kirkwood_i2c);
 }
 
@@ -987,6 +1030,7 @@
 	kirkwood_ge00_shared_data.t_clk = kirkwood_tclk;
 	kirkwood_ge01_shared_data.t_clk = kirkwood_tclk;
 	kirkwood_spi_plat_data.tclk = kirkwood_tclk;
+	kirkwood_tdm_spi_plat_data.tclk = kirkwood_tclk;
 	kirkwood_uart0_data[0].uartclk = kirkwood_tclk;
 	kirkwood_uart1_data[0].uartclk = kirkwood_tclk;
 	kirkwood_i2s_data.tclk = kirkwood_tclk;
diff -ruw linux-2.6.39.4/arch/arm/mach-kirkwood/common.h linux-2.6.39.4-fbx/arch/arm/mach-kirkwood/common.h
--- linux-2.6.39.4/arch/arm/mach-kirkwood/common.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/arch/arm/mach-kirkwood/common.h	2011-06-15 18:56:40.815448769 +0200
@@ -44,7 +44,8 @@
 void kirkwood_sata_init(struct mv_sata_platform_data *sata_data);
 void kirkwood_sdio_init(struct mvsdio_platform_data *mvsdio_data);
 void kirkwood_spi_init(void);
-void kirkwood_i2c_init(void);
+void kirkwood_tdm_spi_init(int cs_gpio[2]);
+void kirkwood_i2c_init(unsigned int freq_m, unsigned int freq_n);
 void kirkwood_uart0_init(void);
 void kirkwood_uart1_init(void);
 void kirkwood_nand_init(struct mtd_partition *parts, int nr_parts, int delay);
diff -ruw linux-2.6.39.4/arch/arm/mach-kirkwood/include/mach/bridge-regs.h linux-2.6.39.4-fbx/arch/arm/mach-kirkwood/include/mach/bridge-regs.h
--- linux-2.6.39.4/arch/arm/mach-kirkwood/include/mach/bridge-regs.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/arch/arm/mach-kirkwood/include/mach/bridge-regs.h	2011-06-15 18:56:40.815448769 +0200
@@ -17,6 +17,7 @@
 #define CPU_CONFIG_ERROR_PROP	0x00000004
 
 #define CPU_CONTROL		(BRIDGE_VIRT_BASE | 0x0104)
+#define PCIE0_ENABLE		0x00000001
 #define CPU_RESET		0x00000002
 
 #define RSTOUTn_MASK		(BRIDGE_VIRT_BASE | 0x0108)
diff -ruw linux-2.6.39.4/arch/arm/mach-kirkwood/include/mach/kirkwood.h linux-2.6.39.4-fbx/arch/arm/mach-kirkwood/include/mach/kirkwood.h
--- linux-2.6.39.4/arch/arm/mach-kirkwood/include/mach/kirkwood.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/arch/arm/mach-kirkwood/include/mach/kirkwood.h	2011-06-15 18:56:40.815448769 +0200
@@ -67,11 +67,17 @@
 
 #define DEV_BUS_PHYS_BASE	(KIRKWOOD_REGS_PHYS_BASE | 0x10000)
 #define DEV_BUS_VIRT_BASE	(KIRKWOOD_REGS_VIRT_BASE | 0x10000)
+#define  MPP_VIRT_BASE		(DEV_BUS_VIRT_BASE | 0x0000)
 #define  SAMPLE_AT_RESET	(DEV_BUS_VIRT_BASE | 0x0030)
 #define  DEVICE_ID		(DEV_BUS_VIRT_BASE | 0x0034)
 #define  GPIO_LOW_VIRT_BASE	(DEV_BUS_VIRT_BASE | 0x0100)
 #define  GPIO_HIGH_VIRT_BASE	(DEV_BUS_VIRT_BASE | 0x0140)
 #define  RTC_PHYS_BASE		(DEV_BUS_PHYS_BASE | 0x0300)
+#define  NAND_PHYS_BASE		(DEV_BUS_PHYS_BASE | 0x0400)
+#define  NAND_VIRT_BASE		(DEV_BUS_VIRT_BASE | 0x0400)
+#define   NAND_RD_PARAM_OFF	0x0018
+#define   NAND_WR_PARAM_OFF	0x001C
+#define   NAND_FLASH_CTL_OFF	0x0070
 #define  SPI_PHYS_BASE		(DEV_BUS_PHYS_BASE | 0x0600)
 #define  I2C_PHYS_BASE		(DEV_BUS_PHYS_BASE | 0x1000)
 #define  UART0_PHYS_BASE	(DEV_BUS_PHYS_BASE | 0x2000)
@@ -116,6 +122,9 @@
 #define AUDIO_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE | 0xA0000)
 #define AUDIO_VIRT_BASE		(KIRKWOOD_REGS_VIRT_BASE | 0xA0000)
 
+#define TDM_SPI_PHYS_BASE	(KIRKWOOD_REGS_PHYS_BASE | 0xd0000)
+#define TDM_SPI_VIRT_BASE	(KIRKWOOD_REGS_VIRT_BASE | 0xd0000)
+
 /*
  * Supported devices and revisions.
  */
diff -ruw linux-2.6.39.4/arch/arm/mach-kirkwood/Kconfig linux-2.6.39.4-fbx/arch/arm/mach-kirkwood/Kconfig
--- linux-2.6.39.4/arch/arm/mach-kirkwood/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/arch/arm/mach-kirkwood/Kconfig	2011-06-15 18:56:40.815448769 +0200
@@ -130,6 +130,30 @@
 	  Say 'Y' here if you want your kernel to support the
 	  HP t5325 Thin Client.
 
+config MACH_FBXGW1R
+	bool "Freebox Gateway version 1"
+	select FBXSERIAL
+
+config MACH_FBXGW1R_ETHSW_CONFIG
+	bool "initialize ethernet switch"
+	depends on MACH_FBXGW1R
+
+config MACH_FBXGW1R_ETHSW_CONFIG_VLAN
+	bool "setup vlan"
+	depends on MACH_FBXGW1R_ETHSW_CONFIG
+
+config MACH_FBXGW1R_PARTS_WRITE_ALL
+	bool "make all mtd partitions writeable"
+	depends on MACH_FBXGW1R
+
+config MACH_FBXGW1R_NAND_SAFE_READ_TIMINGS
+	bool "use very conservative timings for nand read"
+	depends on MACH_FBXGW1R
+
+config MACH_FBXGW1R_NAND_SAFE_WRITE_TIMINGS
+	bool "use very conservative timings for nand write"
+	depends on MACH_FBXGW1R
+
 endmenu
 
 endif
diff -ruw linux-2.6.39.4/arch/arm/mach-kirkwood/Makefile linux-2.6.39.4-fbx/arch/arm/mach-kirkwood/Makefile
--- linux-2.6.39.4/arch/arm/mach-kirkwood/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/arch/arm/mach-kirkwood/Makefile	2011-06-15 18:56:40.815448769 +0200
@@ -18,5 +18,6 @@
 obj-$(CONFIG_MACH_NET2BIG_V2)		+= netxbig_v2-setup.o lacie_v2-common.o
 obj-$(CONFIG_MACH_NET5BIG_V2)		+= netxbig_v2-setup.o lacie_v2-common.o
 obj-$(CONFIG_MACH_T5325)		+= t5325-setup.o
+obj-$(CONFIG_MACH_FBXGW1R)		+= fbxgw1r-setup.o
 
 obj-$(CONFIG_CPU_IDLE)			+= cpuidle.o
diff -ruw linux-2.6.39.4/arch/arm/plat-orion/include/plat/pcie.h linux-2.6.39.4-fbx/arch/arm/plat-orion/include/plat/pcie.h
--- linux-2.6.39.4/arch/arm/plat-orion/include/plat/pcie.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/arch/arm/plat-orion/include/plat/pcie.h	2011-06-15 18:56:41.015449332 +0200
@@ -16,6 +16,10 @@
 u32 orion_pcie_dev_id(void __iomem *base);
 u32 orion_pcie_rev(void __iomem *base);
 int orion_pcie_link_up(void __iomem *base);
+void orion_pcie_set_link_disable(void __iomem *base, int v);
+void orion_pcie_set_retrain_link(void __iomem *base, int v);
+int orion_pcie_get_link_training(void __iomem *base);
+int orion_pcie_get_link_disable(void __iomem *base);
 int orion_pcie_x4_mode(void __iomem *base);
 int orion_pcie_get_local_bus_nr(void __iomem *base);
 void orion_pcie_set_local_bus_nr(void __iomem *base, int nr);
diff -ruw linux-2.6.39.4/arch/arm/plat-orion/pcie.c linux-2.6.39.4-fbx/arch/arm/plat-orion/pcie.c
--- linux-2.6.39.4/arch/arm/plat-orion/pcie.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/arch/arm/plat-orion/pcie.c	2011-06-15 18:56:41.015449332 +0200
@@ -23,6 +23,10 @@
 #define PCIE_DEV_REV_OFF	0x0008
 #define PCIE_BAR_LO_OFF(n)	(0x0010 + ((n) << 3))
 #define PCIE_BAR_HI_OFF(n)	(0x0014 + ((n) << 3))
+#define PCIE_LINK_CTRL_OFF	0x0070
+#define  PCIE_LINK_CTRL_LINK_DIS	(1 << 4)
+#define  PCIE_LINK_CTRL_RETR_LINK	(1 << 5)
+#define  PCIE_LINK_CTRL_LINK_TRAINING	(1 << 27)
 #define PCIE_HEADER_LOG_4_OFF	0x0128
 #define PCIE_BAR_CTRL_OFF(n)	(0x1804 + ((n - 1) * 4))
 #define PCIE_WIN04_CTRL_OFF(n)	(0x1820 + ((n) << 4))
@@ -66,6 +70,49 @@
 	return !(readl(base + PCIE_STAT_OFF) & PCIE_STAT_LINK_DOWN);
 }
 
+void orion_pcie_set_link_disable(void __iomem *base, int v)
+{
+	u32 val;
+
+	val = readl(base + PCIE_LINK_CTRL_OFF);
+	if (v)
+		val |= PCIE_LINK_CTRL_LINK_DIS;
+	else
+		val &= ~PCIE_LINK_CTRL_LINK_DIS;
+	writel(val, base + PCIE_LINK_CTRL_OFF);
+}
+
+int orion_pcie_get_link_disable(void __iomem *base)
+{
+	u32 val;
+
+	val = readl(base + PCIE_LINK_CTRL_OFF);
+	if (val & PCIE_LINK_CTRL_LINK_DIS)
+		return 1;
+	return 0;
+}
+
+void orion_pcie_set_retrain_link(void __iomem *base, int v)
+{
+	u32 val;
+
+	val = readl(base + PCIE_LINK_CTRL_OFF);
+	if (v)
+		val |= PCIE_LINK_CTRL_RETR_LINK;
+	else
+		val &= ~PCIE_LINK_CTRL_RETR_LINK;
+	writel(val, base + PCIE_LINK_CTRL_OFF);
+}
+
+int orion_pcie_get_link_training(void __iomem *base)
+{
+	u32 val = readl(base + PCIE_LINK_CTRL_OFF);
+
+	if (val & PCIE_LINK_CTRL_LINK_TRAINING)
+		return 1;
+	return 0;
+}
+
 int __init orion_pcie_x4_mode(void __iomem *base)
 {
 	return !(readl(base + PCIE_CTRL_OFF) & PCIE_CTRL_X1_MODE);
diff -ruw linux-2.6.39.4/arch/arm/tools/mach-types linux-2.6.39.4-fbx/arch/arm/tools/mach-types
--- linux-2.6.39.4/arch/arm/tools/mach-types	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/arch/arm/tools/mach-types	2011-06-15 18:56:41.035449388 +0200
@@ -118,6 +118,7 @@
 omap_osk		MACH_OMAP_OSK		OMAP_OSK		515
 tosa			MACH_TOSA		TOSA			520
 avila			MACH_AVILA		AVILA			526
+fbxgw1r			MACH_FBXGW1R		FBXGW1R			527
 edb9302			MACH_EDB9302		EDB9302			538
 husky			MACH_HUSKY		HUSKY			543
 shepherd		MACH_SHEPHERD		SHEPHERD		545
diff -ruw linux-2.6.39.4/crypto/algboss.c linux-2.6.39.4-fbx/crypto/algboss.c
--- linux-2.6.39.4/crypto/algboss.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/crypto/algboss.c	2011-06-15 18:56:41.855451694 +0200
@@ -219,7 +219,9 @@
 	if (type & CRYPTO_ALG_TESTED)
 		goto skiptest;
 
+#ifdef CONFIG_CRYPTO_BUILTIN_TEST
 	err = alg_test(param->driver, param->alg, type, CRYPTO_ALG_TESTED);
+#endif
 
 skiptest:
 	crypto_alg_tested(param->driver, err);
diff -ruw linux-2.6.39.4/crypto/Kconfig linux-2.6.39.4-fbx/crypto/Kconfig
--- linux-2.6.39.4/crypto/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/crypto/Kconfig	2011-06-15 18:56:41.855451694 +0200
@@ -86,6 +86,10 @@
 	tristate
 	select CRYPTO_ALGAPI2
 
+config CRYPTO_BUILTIN_TEST
+	bool "Include builtin tests"
+	default y
+
 config CRYPTO_MANAGER
 	tristate "Cryptographic algorithm manager"
 	select CRYPTO_MANAGER2
diff -ruw linux-2.6.39.4/crypto/Makefile linux-2.6.39.4-fbx/crypto/Makefile
--- linux-2.6.39.4/crypto/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/crypto/Makefile	2011-06-15 18:56:41.855451694 +0200
@@ -28,7 +28,10 @@
 
 obj-$(CONFIG_CRYPTO_PCOMP2) += pcompress.o
 
-cryptomgr-y := algboss.o testmgr.o
+cryptomgr-y := algboss.o
+ifeq ($(CONFIG_CRYPTO_BUILTIN_TEST),y)
+cryptomgr-y += testmgr.o
+endif
 
 obj-$(CONFIG_CRYPTO_MANAGER2) += cryptomgr.o
 obj-$(CONFIG_CRYPTO_HMAC) += hmac.o
diff -ruw linux-2.6.39.4/drivers/char/Kconfig linux-2.6.39.4-fbx/drivers/char/Kconfig
--- linux-2.6.39.4/drivers/char/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/char/Kconfig	2011-06-15 18:56:41.975452030 +0200
@@ -15,6 +15,15 @@
 	  kind of kernel debugging operations.
 	  When in doubt, say "N".
 
+config DEVPHYSMEM
+	bool "/dev/physmem virtual device support"
+	default n
+	help
+	  Say Y here if you want to support the /dev/physmem device. The
+	  /dev/physmem device allows unprivileged access to physical memory
+	  unused by the kernel.
+	  When in doubt, say "N".
+
 config STALDRV
 	bool "Stallion multiport serial support"
 	depends on SERIAL_NONSTANDARD
diff -ruw linux-2.6.39.4/drivers/char/mem.c linux-2.6.39.4-fbx/drivers/char/mem.c
--- linux-2.6.39.4/drivers/char/mem.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/char/mem.c	2011-06-15 18:56:41.985452058 +0200
@@ -353,6 +353,16 @@
 }
 #endif
 
+#ifdef CONFIG_DEVPHYSMEM
+static int mmap_physmem(struct file * file, struct vm_area_struct * vma)
+{
+	if (vma->vm_pgoff < max_pfn && !capable(CAP_SYS_RAWIO))
+		return -EPERM;
+
+	return mmap_mem(file, vma);
+}
+#endif
+
 #ifdef CONFIG_CRASH_DUMP
 /*
  * Read memory corresponding to the old kernel.
@@ -731,6 +741,13 @@
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
 }
 
+#ifdef CONFIG_DEVPHYSMEM
+static int open_physmem(struct inode * inode, struct file * filp)
+{
+	return 0;
+}
+#endif
+
 #define zero_lseek	null_lseek
 #define full_lseek      null_lseek
 #define write_zero	write_null
@@ -806,6 +823,14 @@
 };
 #endif
 
+#ifdef CONFIG_DEVPHYSMEM
+static const struct file_operations physmem_fops = {
+	.mmap		= mmap_physmem,
+	.open		= open_physmem,
+	.get_unmapped_area = get_unmapped_area_mem,
+};
+#endif
+
 static ssize_t kmsg_write(struct file *file, const char __user *buf,
 			  size_t count, loff_t *ppos)
 {
@@ -854,6 +879,9 @@
 #ifdef CONFIG_CRASH_DUMP
 	[12] = { "oldmem", 0, &oldmem_fops, NULL },
 #endif
+#ifdef CONFIG_DEVPHYSMEM
+	[16] = { "physmem", 0, &physmem_fops, &directly_mappable_cdev_bdi },
+#endif
 };
 
 static int memory_open(struct inode *inode, struct file *filp)
diff -ruw linux-2.6.39.4/drivers/hwmon/adt7475.c linux-2.6.39.4-fbx/drivers/hwmon/adt7475.c
--- linux-2.6.39.4/drivers/hwmon/adt7475.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/hwmon/adt7475.c	2011-07-19 15:41:05.464933563 +0200
@@ -122,7 +122,19 @@
 
 /* Macro to read the registers */
 
-#define adt7475_read(reg) i2c_smbus_read_byte_data(client, (reg))
+static inline s32 __adt7475_read(const struct i2c_client *client, u8 cmd)
+{
+	s32 ret;
+
+	ret = i2c_smbus_read_byte_data(client, cmd);
+	if (ret < 0) {
+		printk("__adt7475_read error: %d\n", ret);
+		return 0;
+	}
+	return ret;
+}
+
+#define adt7475_read(reg) __adt7475_read(client, (reg))
 
 /* Macros to easily index the registers */
 
@@ -276,6 +288,9 @@
 {
 	u16 val;
 
+	if (need_resched())
+		yield();
+
 	val = i2c_smbus_read_byte_data(client, reg);
 	val |= (i2c_smbus_read_byte_data(client, reg + 1) << 8);
 
@@ -828,7 +843,7 @@
 
 	data->range[sattr->index] =
 		adt7475_read(TEMP_TRANGE_REG(sattr->index));
-	data->range[sattr->index] &= ~7;
+	data->range[sattr->index] &= ~0xf;
 	data->range[sattr->index] |= out;
 
 	i2c_smbus_write_byte_data(client, TEMP_TRANGE_REG(sattr->index),
diff -ruw linux-2.6.39.4/drivers/hwmon/lm85.c linux-2.6.39.4-fbx/drivers/hwmon/lm85.c
--- linux-2.6.39.4/drivers/hwmon/lm85.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/hwmon/lm85.c	2011-06-20 17:00:14.246084333 +0200
@@ -205,11 +205,11 @@
 #define RANGE_FROM_REG(val)	lm85_range_map[(val) & 0x0f]
 
 /* These are the PWM frequency encodings */
-static const int lm85_freq_map[8] = { /* 1 Hz */
-	10, 15, 23, 30, 38, 47, 61, 94
+static const int lm85_freq_map[11] = { /* 1 Hz */
+	10, 15, 23, 30, 38, 47, 61, 94, 94, 94, 94
 };
-static const int adm1027_freq_map[8] = { /* 1 Hz */
-	11, 15, 22, 29, 35, 44, 59, 88
+static const int adm1027_freq_map[11] = { /* 1 Hz */
+	11, 15, 22, 29, 35, 44, 59, 88, 88, 88, 25000
 };
 
 static int FREQ_TO_REG(const int *map, int freq)
@@ -217,7 +217,7 @@
 	int i;
 
 	/* Find the closest match */
-	for (i = 0; i < 7; ++i)
+	for (i = 0; i < 10; ++i)
 		if (freq <= (map[i] + map[i + 1]) / 2)
 			break;
 	return i;
@@ -225,7 +225,7 @@
 
 static int FREQ_FROM_REG(const int *map, u8 reg)
 {
-	return map[reg & 0x07];
+	return map[reg & 0x0f];
 }
 
 /* Since we can't use strings, I'm abusing these numbers
@@ -929,7 +929,7 @@
 		TEMP_FROM_REG(data->zone[nr].limit));
 	lm85_write_value(client, LM85_REG_AFAN_RANGE(nr),
 		((data->zone[nr].range & 0x0f) << 4)
-		| (data->pwm_freq[nr] & 0x07));
+		| (data->pwm_freq[nr] & 0x0f));
 
 	mutex_unlock(&data->update_lock);
 	return count;
@@ -960,7 +960,7 @@
 		val - min);
 	lm85_write_value(client, LM85_REG_AFAN_RANGE(nr),
 		((data->zone[nr].range & 0x0f) << 4)
-		| (data->pwm_freq[nr] & 0x07));
+		| (data->pwm_freq[nr] & 0x0f));
 	mutex_unlock(&data->update_lock);
 	return count;
 }
@@ -1146,8 +1146,28 @@
 
 static void lm85_init_client(struct i2c_client *client)
 {
+	struct lm85_data *data = i2c_get_clientdata(client);
 	int value;
 
+	/* workaround for emc2300 (emc6d103s), when auto temp min is
+	 * the default value, pwm can never be controlled manually, so
+	 * change this */
+	if (data->type == emc6d103s) {
+		int nr;
+
+		for (nr = 0; nr < 3; nr++) {
+			data->zone[nr].limit = TEMP_TO_REG(-127000);
+			lm85_write_value(client, LM85_REG_AFAN_LIMIT(nr),
+					 data->zone[nr].limit);
+
+			/* also force high frequency */
+			data->pwm_freq[nr] = 0xa;
+			lm85_write_value(client, LM85_REG_AFAN_RANGE(nr),
+					 data->pwm_freq[nr]);
+		}
+	}
+
+
 	/* Start monitoring if needed */
 	value = lm85_read_value(client, LM85_REG_CONFIG);
 	if (!(value & 0x01)) {
@@ -1570,7 +1590,7 @@
 			data->autofan[i].config =
 			    lm85_read_value(client, LM85_REG_AFAN_CONFIG(i));
 			val = lm85_read_value(client, LM85_REG_AFAN_RANGE(i));
-			data->pwm_freq[i] = val & 0x07;
+			data->pwm_freq[i] = val & 0x0f;
 			data->zone[i].range = val >> 4;
 			data->autofan[i].min_pwm =
 			    lm85_read_value(client, LM85_REG_AFAN_MINPWM(i));
diff -ruw linux-2.6.39.4/drivers/i2c/busses/i2c-mv64xxx.c linux-2.6.39.4-fbx/drivers/i2c/busses/i2c-mv64xxx.c
--- linux-2.6.39.4/drivers/i2c/busses/i2c-mv64xxx.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/i2c/busses/i2c-mv64xxx.c	2011-07-19 15:41:05.464933563 +0200
@@ -18,6 +18,7 @@
 #include <linux/mv643xx_i2c.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
+#include <linux/delay.h>
 
 /* Register defines */
 #define	MV64XXX_I2C_REG_SLAVE_ADDR			0x00
@@ -217,6 +218,11 @@
 	case MV64XXX_I2C_STATUS_MAST_WR_NO_ACK: /* 30 */
 	case MV64XXX_I2C_STATUS_MAST_RD_ADDR_NO_ACK: /* 48 */
 		/* Doesn't seem to be a device at other end */
+		dev_err(&drv_data->adapter.dev,
+			"mv64xxx_i2c_fsm: got no ack -- state: 0x%x, "
+			"status: 0x%x, addr: 0x%x, flags: 0x%x\n",
+			 drv_data->state, status, drv_data->msg->addr,
+			 drv_data->msg->flags);
 		drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
 		drv_data->state = MV64XXX_I2C_STATE_IDLE;
 		drv_data->rc = -ENODEV;
@@ -409,6 +415,34 @@
 				int is_first, int is_last)
 {
 	unsigned long	flags;
+	int limit;
+
+	/*
+	 * wait for (re)start/stop condition to clear from last
+	 * transfer if any
+	 */
+	limit = 1000;
+	do {
+		u32 val;
+
+		val = readl(drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
+		if (!(val & (MV64XXX_I2C_REG_CONTROL_START |
+			     MV64XXX_I2C_REG_CONTROL_STOP)))
+			break;
+
+		udelay(1);
+	} while (limit-- > 0);
+
+	if (limit < 0) {
+		dev_err(&drv_data->adapter.dev,
+			"mv64xxx: start/stop bit won't clear\n");
+	}
+
+	/* according to datasheet, controller is buggy when you do
+	 * register polling and it says to always wait for an IRQ
+	 * (clock domain related), since we busywait for START/STOP
+	 * clear, add a small delay */
+	udelay(5);
 
 	spin_lock_irqsave(&drv_data->lock, flags);
 	mv64xxx_i2c_prepare_for_io(drv_data, msg);
@@ -439,6 +473,7 @@
 
 	drv_data->send_stop = is_last;
 	drv_data->block = 1;
+
 	mv64xxx_i2c_do_action(drv_data);
 	spin_unlock_irqrestore(&drv_data->lock, flags);
 
diff -ruw linux-2.6.39.4/drivers/ide/Kconfig linux-2.6.39.4-fbx/drivers/ide/Kconfig
--- linux-2.6.39.4/drivers/ide/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/ide/Kconfig	2011-06-15 18:56:42.165452564 +0200
@@ -692,6 +692,11 @@
        depends on SOC_AU1200 && BLK_DEV_IDE_AU1XXX
 endchoice
 
+config BLK_DEV_IDE_TANGO2
+	tristate "IDE for Tango2"
+	depends on TANGO2
+	select BLK_DEV_IDEDMA_SFF
+
 config BLK_DEV_IDE_TX4938
 	tristate "TX4938 internal IDE support"
 	depends on SOC_TX4938
diff -ruw linux-2.6.39.4/drivers/ide/Makefile linux-2.6.39.4-fbx/drivers/ide/Makefile
--- linux-2.6.39.4/drivers/ide/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/ide/Makefile	2011-06-15 18:56:42.165452564 +0200
@@ -117,3 +117,4 @@
 obj-$(CONFIG_BLK_DEV_IDE_TX4938)	+= tx4938ide.o
 obj-$(CONFIG_BLK_DEV_IDE_TX4939)	+= tx4939ide.o
 obj-$(CONFIG_BLK_DEV_IDE_AT91)		+= at91_ide.o
+obj-$(CONFIG_BLK_DEV_IDE_TANGO2)	+= tango2ide.o
diff -ruw linux-2.6.39.4/drivers/input/misc/Kconfig linux-2.6.39.4-fbx/drivers/input/misc/Kconfig
--- linux-2.6.39.4/drivers/input/misc/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/input/misc/Kconfig	2011-06-15 18:56:42.215452704 +0200
@@ -467,4 +467,9 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called xen-kbdfront.
 
+config INPUT_SMSC_CAP1066
+	tristate "SMSC CAP1066 capacitive sensor driver"
+	select I2C
+	select INPUT_POLLDEV
+
 endif
diff -ruw linux-2.6.39.4/drivers/input/misc/Makefile linux-2.6.39.4-fbx/drivers/input/misc/Makefile
--- linux-2.6.39.4/drivers/input/misc/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/input/misc/Makefile	2011-06-15 18:56:42.215452704 +0200
@@ -44,4 +44,4 @@
 obj-$(CONFIG_INPUT_WM831X_ON)		+= wm831x-on.o
 obj-$(CONFIG_INPUT_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
-
+obj-$(CONFIG_INPUT_SMSC_CAP1066)	+= smsc_cap1066.o
diff -ruw linux-2.6.39.4/drivers/Kconfig linux-2.6.39.4-fbx/drivers/Kconfig
--- linux-2.6.39.4/drivers/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/Kconfig	2011-06-15 18:56:41.875451750 +0200
@@ -4,8 +4,12 @@
 
 source "drivers/connector/Kconfig"
 
+source "drivers/fbxprocfs/Kconfig"
+
 source "drivers/mtd/Kconfig"
 
+source "drivers/fbxmtd/Kconfig"
+
 source "drivers/of/Kconfig"
 
 source "drivers/parport/Kconfig"
@@ -56,6 +60,10 @@
 
 source "drivers/gpio/Kconfig"
 
+source "drivers/fbxgpio/Kconfig"
+
+source "drivers/fbxjtag/Kconfig"
+
 source "drivers/w1/Kconfig"
 
 source "drivers/power/Kconfig"
@@ -64,6 +72,8 @@
 
 source "drivers/thermal/Kconfig"
 
+source "drivers/fbxwatchdog/Kconfig"
+
 source "drivers/watchdog/Kconfig"
 
 source "drivers/ssb/Kconfig"
@@ -92,6 +102,8 @@
 
 source "drivers/nfc/Kconfig"
 
+source "drivers/fbxpanel/Kconfig"
+
 source "drivers/accessibility/Kconfig"
 
 source "drivers/infiniband/Kconfig"
diff -ruw linux-2.6.39.4/drivers/Makefile linux-2.6.39.4-fbx/drivers/Makefile
--- linux-2.6.39.4/drivers/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/Makefile	2011-06-15 18:56:41.875451750 +0200
@@ -6,6 +6,8 @@
 #
 
 obj-y				+= gpio/
+obj-$(CONFIG_FREEBOX_GPIO)	+= fbxgpio/
+obj-$(CONFIG_FREEBOX_JTAG)	+= fbxjtag/
 obj-$(CONFIG_PCI)		+= pci/
 obj-$(CONFIG_PARISC)		+= parisc/
 obj-$(CONFIG_RAPIDIO)		+= rapidio/
@@ -55,6 +57,9 @@
 obj-$(CONFIG_UIO)		+= uio/
 obj-y				+= cdrom/
 obj-y				+= auxdisplay/
+
+obj-$(CONFIG_FREEBOX_PROCFS)	+= fbxprocfs/
+obj-$(CONFIG_FREEBOX_MTD)	+= fbxmtd/
 obj-$(CONFIG_PCCARD)		+= pcmcia/
 obj-$(CONFIG_DIO)		+= dio/
 obj-$(CONFIG_SBUS)		+= sbus/
@@ -80,6 +85,7 @@
 obj-$(CONFIG_POWER_SUPPLY)	+= power/
 obj-$(CONFIG_HWMON)		+= hwmon/
 obj-$(CONFIG_THERMAL)		+= thermal/
+obj-$(CONFIG_FREEBOX_WATCHDOG)	+= fbxwatchdog/
 obj-$(CONFIG_WATCHDOG)		+= watchdog/
 obj-$(CONFIG_PHONE)		+= telephony/
 obj-$(CONFIG_MD)		+= md/
@@ -96,6 +102,7 @@
 obj-$(CONFIG_MMC)		+= mmc/
 obj-$(CONFIG_MEMSTICK)		+= memstick/
 obj-$(CONFIG_NEW_LEDS)		+= leds/
+obj-$(CONFIG_FREEBOX_PANEL)	+= fbxpanel/
 obj-$(CONFIG_INFINIBAND)	+= infiniband/
 obj-$(CONFIG_SGI_SN)		+= sn/
 obj-y				+= firmware/
diff -ruw linux-2.6.39.4/drivers/md/dm-ioctl.c linux-2.6.39.4-fbx/drivers/md/dm-ioctl.c
--- linux-2.6.39.4/drivers/md/dm-ioctl.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/md/dm-ioctl.c	2011-06-15 18:56:42.315452986 +0200
@@ -1646,7 +1646,10 @@
 	return r;
 }
 
-static long dm_ctl_ioctl(struct file *file, uint command, ulong u)
+#ifndef CONFIG_DMCRYPTATBOOT
+static
+#endif
+long dm_ctl_ioctl(struct file *file, uint command, ulong u)
 {
 	return (long)ctl_ioctl(command, (struct dm_ioctl __user *)u);
 }
diff -ruw linux-2.6.39.4/drivers/media/dvb/dvb-core/dvb_frontend.c linux-2.6.39.4-fbx/drivers/media/dvb/dvb-core/dvb_frontend.c
--- linux-2.6.39.4/drivers/media/dvb/dvb-core/dvb_frontend.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/media/dvb/dvb-core/dvb_frontend.c	2011-06-15 18:56:42.325453014 +0200
@@ -695,6 +695,7 @@
 
 	fepriv->exit = DVB_FE_NORMAL_EXIT;
 	mb();
+	wake_up_all(&fepriv->events.wait_queue);
 
 	if (!fepriv->thread)
 		return;
@@ -1907,6 +1908,9 @@
 
 	poll_wait (file, &fepriv->events.wait_queue, wait);
 
+	if (fepriv->exit)
+		return POLLERR | POLLHUP;
+
 	if (fepriv->events.eventw != fepriv->events.eventr)
 		return (POLLIN | POLLRDNORM | POLLPRI);
 
diff -ruw linux-2.6.39.4/drivers/media/dvb/dvb-usb/dib0700_devices.c linux-2.6.39.4-fbx/drivers/media/dvb/dvb-usb/dib0700_devices.c
--- linux-2.6.39.4/drivers/media/dvb/dvb-usb/dib0700_devices.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/media/dvb/dvb-usb/dib0700_devices.c	2011-06-15 18:56:42.335453042 +0200
@@ -2802,6 +2802,7 @@
 	{ USB_DEVICE(USB_VID_DIBCOM,    USB_PID_DIBCOM_NIM7090) },
 	{ USB_DEVICE(USB_VID_DIBCOM,    USB_PID_DIBCOM_TFE7090PVR) },
 	{ USB_DEVICE(USB_VID_TECHNISAT, USB_PID_TECHNISAT_AIRSTAR_TELESTICK_2) },
+/* 75 */{ USB_DEVICE(USB_VID_DIBCOM,	USB_PID_DIBCOM_HOOK_DEFAULT_STK7770P) },
 	{ 0 }		/* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, dib0700_usb_id_table);
@@ -3440,6 +3441,33 @@
 			.change_protocol  = dib0700_change_protocol,
 		},
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
+
+		.num_adapters = 1,
+		.adapter = {
+			{
+				.caps = DVB_USB_ADAP_HAS_PID_FILTER | DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,
+				.pid_filter_count = 32,
+				.pid_filter       = stk70x0p_pid_filter,
+				.pid_filter_ctrl  = stk70x0p_pid_filter_ctrl,
+				.frontend_attach  = stk7770p_frontend_attach,
+				.tuner_attach     = dib7770p_tuner_attach,
+
+				DIB0700_DEFAULT_STREAMING_CONFIG(0x02),
+
+				.size_of_priv =
+					sizeof(struct dib0700_adapter_state),
+			},
+		},
+
+		.num_device_descs = 1,
+		.devices = {
+			{   "DiBcom STK7770P reference design no IR",
+				{ &dib0700_usb_id_table[75], NULL },
+				{ NULL },
+			},
+		},
+
+	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
 		.num_adapters = 1,
 		.adapter = {
 			{
diff -ruw linux-2.6.39.4/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c linux-2.6.39.4-fbx/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c
--- linux-2.6.39.4/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c	2011-05-24 18:15:55.045722604 +0200
@@ -178,6 +178,9 @@
 	if (adap->props.frontend_attach(adap) == 0 && adap->fe != NULL) {
 		adap->fe_init  = adap->fe->ops.init;  adap->fe->ops.init  = dvb_usb_fe_wakeup;
 		adap->fe_sleep = adap->fe->ops.sleep; adap->fe->ops.sleep = dvb_usb_fe_sleep;
+		/* only attach the tuner if the demod is there */
+		if (adap->props.tuner_attach != NULL)
+			adap->props.tuner_attach(adap);
 
 		if (dvb_register_frontend(&adap->dvb_adap, adap->fe)) {
 			err("Frontend registration failed.");
@@ -186,9 +189,6 @@
 			return -ENODEV;
 		}
 
-		/* only attach the tuner if the demod is there */
-		if (adap->props.tuner_attach != NULL)
-			adap->props.tuner_attach(adap);
 	} else
 		err("no frontend was attached by '%s'",adap->dev->desc->name);
 
diff -ruw linux-2.6.39.4/drivers/media/dvb/dvb-usb/dvb-usb.h linux-2.6.39.4-fbx/drivers/media/dvb/dvb-usb/dvb-usb.h
--- linux-2.6.39.4/drivers/media/dvb/dvb-usb/dvb-usb.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/media/dvb/dvb-usb/dvb-usb.h	2011-06-15 18:56:42.345453070 +0200
@@ -284,7 +284,7 @@
 	int generic_bulk_ctrl_endpoint_response;
 
 	int num_device_descs;
-	struct dvb_usb_device_description devices[12];
+	struct dvb_usb_device_description devices[32];
 };
 
 /**
diff -ruw linux-2.6.39.4/drivers/media/dvb/dvb-usb/dvb-usb-ids.h linux-2.6.39.4-fbx/drivers/media/dvb/dvb-usb/dvb-usb-ids.h
--- linux-2.6.39.4/drivers/media/dvb/dvb-usb/dvb-usb-ids.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/media/dvb/dvb-usb/dvb-usb-ids.h	2011-06-15 18:56:42.345453070 +0200
@@ -93,6 +93,7 @@
 #define USB_PID_CONEXANT_D680_DMB			0x86d6
 #define USB_PID_DIBCOM_HOOK_DEFAULT			0x0064
 #define USB_PID_DIBCOM_HOOK_DEFAULT_REENUM		0x0065
+#define USB_PID_DIBCOM_HOOK_DEFAULT_STK7770P		0x0066
 #define USB_PID_DIBCOM_MOD3000_COLD			0x0bb8
 #define USB_PID_DIBCOM_MOD3000_WARM			0x0bb9
 #define USB_PID_DIBCOM_MOD3001_COLD			0x0bc6
diff -ruw linux-2.6.39.4/drivers/media/dvb/Kconfig linux-2.6.39.4-fbx/drivers/media/dvb/Kconfig
--- linux-2.6.39.4/drivers/media/dvb/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/media/dvb/Kconfig	2011-06-15 18:56:42.325453014 +0200
@@ -64,6 +64,10 @@
 	depends on DVB_CORE && PCI && I2C
 source "drivers/media/dvb/dm1105/Kconfig"
 
+comment "Supported Tango2 Adapters"
+	depends on DVB_CORE && ARCH_FBX5_B
+source "drivers/media/dvb/tango2/Kconfig"
+
 comment "Supported FireWire (IEEE 1394) Adapters"
 	depends on DVB_CORE && FIREWIRE
 source "drivers/media/dvb/firewire/Kconfig"
diff -ruw linux-2.6.39.4/drivers/media/dvb/Makefile linux-2.6.39.4-fbx/drivers/media/dvb/Makefile
--- linux-2.6.39.4/drivers/media/dvb/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/media/dvb/Makefile	2011-05-24 18:15:55.035722645 +0200
@@ -15,6 +15,7 @@
 		dm1105/		\
 		pt1/		\
 		mantis/		\
-		ngene/
+		ngene/		\
+		tango2/
 
 obj-$(CONFIG_DVB_FIREDTV)	+= firewire/
diff -ruw linux-2.6.39.4/drivers/misc/Kconfig linux-2.6.39.4-fbx/drivers/misc/Kconfig
--- linux-2.6.39.4/drivers/misc/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/misc/Kconfig	2011-06-15 18:56:42.585453744 +0200
@@ -438,6 +438,18 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called vmw_balloon.
 
+config INTELCE_PIC16PMU
+	tristate "PIC16 PMU, LED, hwmon support"
+	select INPUT_POLLDEV
+	select NEW_LEDS
+	select I2C
+	select HWMON
+	select ARCH_REQUIRE_GPIOLIB
+	---help---
+	  Freebox v6 HD PIC16 PMU interface support, enables
+	  control of the on-board LEDs and reports the power status,
+	  reset status and button status.
+
 config ARM_CHARLCD
 	bool "ARM Ltd. Character LCD Driver"
 	depends on PLAT_VERSATILE
@@ -475,11 +487,15 @@
 	  To compile this driver as a module, choose M here: the module will
 	  be called pch_phub.
 
+config CRASHZONE
+	bool "crashzone support"
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
 source "drivers/misc/iwmc3200top/Kconfig"
 source "drivers/misc/ti-st/Kconfig"
 source "drivers/misc/lis3lv02d/Kconfig"
+source "drivers/misc/remoti/Kconfig"
 
 endif # MISC_DEVICES
diff -ruw linux-2.6.39.4/drivers/misc/Makefile linux-2.6.39.4-fbx/drivers/misc/Makefile
--- linux-2.6.39.4/drivers/misc/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/misc/Makefile	2011-06-15 18:56:42.585453744 +0200
@@ -22,6 +22,7 @@
 obj-$(CONFIG_ENCLOSURE_SERVICES) += enclosure.o
 obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
 obj-$(CONFIG_SGI_XP)		+= sgi-xp/
+obj-$(CONFIG_INTELCE_PIC16PMU)	+= pic16-pmu.o
 obj-$(CONFIG_SGI_GRU)		+= sgi-gru/
 obj-$(CONFIG_CS5535_MFGPT)	+= cs5535-mfgpt.o
 obj-$(CONFIG_HP_ILO)		+= hpilo.o
@@ -35,6 +36,7 @@
 obj-$(CONFIG_C2PORT)		+= c2port/
 obj-$(CONFIG_IWMC3200TOP)      += iwmc3200top/
 obj-$(CONFIG_HMC6352)		+= hmc6352.o
+obj-$(CONFIG_CRASHZONE)		+= crash_zone.o
 obj-y				+= eeprom/
 obj-y				+= cb710/
 obj-$(CONFIG_SPEAR13XX_PCIE_GADGET)	+= spear13xx_pcie_gadget.o
@@ -44,3 +46,4 @@
 obj-y				+= ti-st/
 obj-$(CONFIG_AB8500_PWM)	+= ab8500-pwm.o
 obj-y				+= lis3lv02d/
+obj-y				+= remoti/
diff -ruw linux-2.6.39.4/drivers/mtd/devices/m25p80.c linux-2.6.39.4-fbx/drivers/mtd/devices/m25p80.c
--- linux-2.6.39.4/drivers/mtd/devices/m25p80.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/mtd/devices/m25p80.c	2011-06-15 18:56:42.615453828 +0200
@@ -42,8 +42,10 @@
 #define	OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
 #define	OPCODE_BE_4K		0x20	/* Erase 4KiB block */
 #define	OPCODE_BE_32K		0x52	/* Erase 32KiB block */
+#define OPCODE_EWRSR		0x50	/* Enable write to status regs */
 #define	OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
 #define	OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
+#define	OPCODE_RDID_ALT		0x90	/* Read ID (alt) */
 #define	OPCODE_RDID		0x9f	/* Read JEDEC ID */
 
 /* Used for SST flashes only. */
@@ -617,6 +619,8 @@
 	u16		flags;
 #define	SECT_4K		0x01		/* OPCODE_BE_4K works uniformly */
 #define	M25P_NO_ERASE	0x02		/* No erase command needed */
+#define ALT_PROBE	0x04		/* use alternate probe method */
+#define ALT_PROBE_ATMEL	0x08		/* use atmel probe method */
 };
 
 #define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)	\
@@ -654,6 +658,8 @@
 	{ "at26df081a", INFO(0x1f4501, 0, 64 * 1024, 16, SECT_4K) },
 	{ "at26df161a", INFO(0x1f4601, 0, 64 * 1024, 32, SECT_4K) },
 	{ "at26df321",  INFO(0x1f4700, 0, 64 * 1024, 64, SECT_4K) },
+	{ "at25f512b",  INFO(0x1f6500, 0x1f65, 32 * 1024, 2,
+			     ALT_PROBE_ATMEL) },
 
 	/* EON -- en25xxx */
 	{ "en25f32", INFO(0x1c3116, 0, 64 * 1024,  64, SECT_4K) },
@@ -674,6 +680,8 @@
 	{ "mx25l12855e", INFO(0xc22618, 0, 64 * 1024, 256, 0) },
 	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, 0) },
 	{ "mx25l25655e", INFO(0xc22619, 0, 64 * 1024, 512, 0) },
+	{ "mx25l512", INFO(0xc20500, 0xc205, 64 * 1024, 1,
+			   ALT_PROBE | SECT_4K) },
 
 	/* Spansion -- single (large) sector size only, at least
 	 * for the chips listed here (without boot sectors).
@@ -692,6 +700,7 @@
 	{ "s25fl064k",  INFO(0xef4017,      0,  64 * 1024, 128, SECT_4K) },
 
 	/* SST -- large erase sizes are "overlays", "sectors" are 4K */
+	{ "sst25vf512a", INFO(0xbf4800, 0xbf48, 32 * 1024, 2, ALT_PROBE) },
 	{ "sst25vf040b", INFO(0xbf258d, 0, 64 * 1024,  8, SECT_4K) },
 	{ "sst25vf080b", INFO(0xbf258e, 0, 64 * 1024, 16, SECT_4K) },
 	{ "sst25vf016b", INFO(0xbf2541, 0, 64 * 1024, 32, SECT_4K) },
@@ -748,6 +757,11 @@
 	{ "cat25c09", CAT25_INFO( 128, 8, 32, 2) },
 	{ "cat25c17", CAT25_INFO( 256, 8, 32, 2) },
 	{ "cat25128", CAT25_INFO(2048, 8, 64, 2) },
+
+	/* EON */
+	{ "en25f05", INFO(0x1c0500, 0x1c05, 64 * 1024, 1,
+			  ALT_PROBE | SECT_4K) },
+
 	{ },
 };
 MODULE_DEVICE_TABLE(spi, m25p_ids);
@@ -791,6 +805,60 @@
 	return ERR_PTR(-ENODEV);
 }
 
+static const struct spi_device_id *__devinit alt_probe(struct spi_device *spi)
+{
+	int			tmp;
+	u8			read_id[4] = { OPCODE_RDID_ALT, 0, 0, 0 };
+	u8			data[2];
+	u16			id;
+	struct flash_info	*info;
+
+	read_id[3] = 0x0;
+	tmp = spi_write_then_read(spi, read_id, 4, data, 2);
+	if (tmp < 0) {
+		DEBUG(MTD_DEBUG_LEVEL0, "%s: error %d reading ALT ID\n",
+			dev_name(&spi->dev), tmp);
+		return ERR_PTR(tmp);
+	}
+
+	id = (data[1] << 8) | data[0];
+
+	for (tmp = 0; tmp < ARRAY_SIZE(m25p_ids) - 1; tmp++) {
+		info = (void *)m25p_ids[tmp].driver_data;
+		if ((info->flags & ALT_PROBE) && (info->ext_id == id))
+			return &m25p_ids[tmp];
+	}
+
+	dev_err(&spi->dev, "unrecognized ALT id %04x\n", id);
+	return ERR_PTR(-ENODEV);
+}
+
+static const struct spi_device_id *__devinit atmel_probe(struct spi_device *spi)
+{
+	int			tmp;
+	u8			opcode = 0x15;
+	u8			data[2];
+	u16			id;
+	struct flash_info	*info;
+
+	tmp = spi_write_then_read(spi, &opcode, 1, data, 2);
+	if (tmp < 0) {
+		DEBUG(MTD_DEBUG_LEVEL0, "%s: error %d reading ATMEL ID\n",
+			dev_name(&spi->dev), tmp);
+		return ERR_PTR(tmp);
+	}
+
+	id = (data[1] << 8) | data[0];
+
+	for (tmp = 0; tmp < ARRAY_SIZE(m25p_ids) - 1; tmp++) {
+		info = (void *)m25p_ids[tmp].driver_data;
+		if ((info->flags & ALT_PROBE_ATMEL) && (info->ext_id == id))
+			return &m25p_ids[tmp];
+	}
+
+	dev_err(&spi->dev, "unrecognized ATMEL id %04x\n", id);
+	return ERR_PTR(-ENODEV);
+}
 
 /*
  * board specific setup should have ensured the SPI clock used here
@@ -799,7 +867,7 @@
  */
 static int __devinit m25p_probe(struct spi_device *spi)
 {
-	const struct spi_device_id	*id = spi_get_device_id(spi);
+	const struct spi_device_id	*id, *jid;
 	struct flash_platform_data	*data;
 	struct m25p			*flash;
 	struct flash_info		*info;
@@ -811,6 +879,7 @@
 	 * newer chips, even if we don't recognize the particular chip.
 	 */
 	data = spi->dev.platform_data;
+	id = NULL;
 	if (data && data->type) {
 		const struct spi_device_id *plat_id;
 
@@ -827,15 +896,18 @@
 			dev_warn(&spi->dev, "unrecognized id %s\n", data->type);
 	}
 
-	info = (void *)id->driver_data;
-
-	if (info->jedec_id) {
-		const struct spi_device_id *jid;
-
+	jid = alt_probe(spi);
+	if (IS_ERR(jid))
+		jid = atmel_probe(spi);
+	if (IS_ERR(jid))
 		jid = jedec_probe(spi);
+
 		if (IS_ERR(jid)) {
-			return PTR_ERR(jid);
-		} else if (jid != id) {
+		dev_err(&spi->dev, "can't probe flash\n");
+		return -ENODEV;
+	}
+
+	if (id && jid != id) {
 			/*
 			 * JEDEC knows better, so overwrite platform ID. We
 			 * can't trust partitions any longer, but we'll let
@@ -845,10 +917,10 @@
 			 */
 			dev_warn(&spi->dev, "found %s, expected %s\n",
 				 jid->name, id->name);
+	}
+
 			id = jid;
 			info = (void *)jid->driver_data;
-		}
-	}
 
 	flash = kzalloc(sizeof *flash, GFP_KERNEL);
 	if (!flash)
@@ -875,6 +947,14 @@
 		write_sr(flash, 0);
 	}
 
+	if (info->ext_id == 0xbf48) {
+		u8 ewrsr = OPCODE_EWRSR;
+
+		write_enable(flash);
+		spi_write_then_read(flash->spi, &ewrsr, 1, NULL, 0);
+		write_sr(flash, 0);
+	}
+
 	if (data && data->name)
 		flash->mtd.name = data->name;
 	else
diff -ruw linux-2.6.39.4/drivers/mtd/Kconfig linux-2.6.39.4-fbx/drivers/mtd/Kconfig
--- linux-2.6.39.4/drivers/mtd/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/mtd/Kconfig	2011-06-15 18:56:42.605453800 +0200
@@ -33,6 +33,9 @@
 	  should normally be compiled as kernel modules. The modules perform
 	  various checks and verifications when loaded.
 
+config MTD_ERASE_PRINTK
+	bool "write to kernel log when a block is erased"
+
 config MTD_PARTITIONS
 	bool "MTD partitioning support"
 	help
@@ -164,6 +167,17 @@
 	---help---
 	  TI AR7 partitioning support
 
+config MTD_FBX6HD_PARTS
+	tristate "Freebox V6 HD partitioning support"
+	help
+	  Freebox V6 HD partitioning support
+
+config MTD_FBX6HD_PARTS_WRITE_ALL
+	bool "make all partitions writeable"
+	depends on MTD_FBX6HD_PARTS
+	help
+	  Freebox V6 HD partitions support
+
 endif # MTD_PARTITIONS
 
 comment "User Modules And Translation Layers"
diff -ruw linux-2.6.39.4/drivers/mtd/Makefile linux-2.6.39.4-fbx/drivers/mtd/Makefile
--- linux-2.6.39.4/drivers/mtd/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/mtd/Makefile	2011-06-15 18:56:42.605453800 +0200
@@ -12,6 +12,7 @@
 obj-$(CONFIG_MTD_CMDLINE_PARTS) += cmdlinepart.o
 obj-$(CONFIG_MTD_AFS_PARTS)	+= afs.o
 obj-$(CONFIG_MTD_AR7_PARTS)	+= ar7part.o
+obj-$(CONFIG_MTD_FBX6HD_PARTS)	+= fbx6hd-mtdparts.o
 
 # 'Users' - code which presents functionality to userspace.
 obj-$(CONFIG_MTD_CHAR)		+= mtdchar.o
diff -ruw linux-2.6.39.4/drivers/mtd/mtdchar.c linux-2.6.39.4-fbx/drivers/mtd/mtdchar.c
--- linux-2.6.39.4/drivers/mtd/mtdchar.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/mtd/mtdchar.c	2011-06-15 18:56:42.615453828 +0200
@@ -218,6 +218,7 @@
 		{
 			struct mtd_oob_ops ops;
 
+			memset(&ops, 0, sizeof (ops));
 			ops.mode = MTD_OOB_RAW;
 			ops.datbuf = kbuf;
 			ops.oobbuf = NULL;
@@ -321,6 +322,7 @@
 		{
 			struct mtd_oob_ops ops;
 
+			memset(&ops, 0, sizeof (ops));
 			ops.mode = MTD_OOB_RAW;
 			ops.datbuf = kbuf;
 			ops.oobbuf = NULL;
@@ -656,6 +658,10 @@
 			erase->callback = mtdchar_erase_callback;
 			erase->priv = (unsigned long)&waitq;
 
+#ifdef CONFIG_MTD_ERASE_PRINTK
+			printk(KERN_DEBUG "mtd: %s: ERASE offset=@%08llx\n",
+			       mtd->name, erase->addr);
+#endif
 			/*
 			  FIXME: Allow INTERRUPTIBLE. Which means
 			  not having the wait_queue head on the stack.
diff -ruw linux-2.6.39.4/drivers/mtd/mtdcore.c linux-2.6.39.4-fbx/drivers/mtd/mtdcore.c
--- linux-2.6.39.4/drivers/mtd/mtdcore.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/mtd/mtdcore.c	2011-06-22 19:20:26.542924107 +0200
@@ -250,6 +250,33 @@
 }
 static DEVICE_ATTR(name, S_IRUGO, mtd_name_show, NULL);
 
+static ssize_t mtd_nand_type_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", mtd->nand_type);
+}
+static DEVICE_ATTR(nand_type, S_IRUGO, mtd_nand_type_show, NULL);
+
+static ssize_t mtd_nand_manufacturer_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", mtd->nand_manufacturer);
+}
+static DEVICE_ATTR(nand_manufacturer, S_IRUGO, mtd_nand_manufacturer_show, NULL);
+
+static ssize_t mtd_nand_onfi_version_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", mtd->onfi_version);
+}
+static DEVICE_ATTR(onfi_version, S_IRUGO, mtd_nand_onfi_version_show, NULL);
+
 static struct attribute *mtd_attrs[] = {
 	&dev_attr_type.attr,
 	&dev_attr_flags.attr,
@@ -260,6 +287,9 @@
 	&dev_attr_oobsize.attr,
 	&dev_attr_numeraseregions.attr,
 	&dev_attr_name.attr,
+	&dev_attr_nand_type.attr,
+	&dev_attr_nand_manufacturer.attr,
+	&dev_attr_onfi_version.attr,
 	NULL,
 };
 
diff -ruw linux-2.6.39.4/drivers/mtd/mtdpart.c linux-2.6.39.4-fbx/drivers/mtd/mtdpart.c
--- linux-2.6.39.4/drivers/mtd/mtdpart.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/mtd/mtdpart.c	2011-06-22 19:20:26.542924107 +0200
@@ -405,6 +405,9 @@
 	slave->mtd.oobsize = master->oobsize;
 	slave->mtd.oobavail = master->oobavail;
 	slave->mtd.subpage_sft = master->subpage_sft;
+	slave->mtd.nand_type = master->nand_type;
+	slave->mtd.nand_manufacturer = master->nand_manufacturer;
+	slave->mtd.onfi_version = master->onfi_version;
 
 	slave->mtd.name = name;
 	slave->mtd.owner = master->owner;
diff -ruw linux-2.6.39.4/drivers/mtd/nand/Kconfig linux-2.6.39.4-fbx/drivers/mtd/nand/Kconfig
--- linux-2.6.39.4/drivers/mtd/nand/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/mtd/nand/Kconfig	2011-06-15 18:56:42.615453828 +0200
@@ -58,6 +58,15 @@
 	  NAND chips (page size 256 byte, erase size 4-8KiB). The IDs
 	  of these chips were reused by later, larger chips.
 
+config MTD_FORCE_BAD_BLOCK_ERASE
+	bool "Force erase on bad blocks (useful for bootloader parts)"
+	depends on MTD_NAND
+	default n
+	help
+	  Enable this option only when you need to force an erase on
+	  blocks being marked as "bad" by Linux (i.e: other ECC/bad block
+	  marker layout).
+
 config MTD_NAND_AUTCPU12
 	tristate "SmartMediaCard on autronix autcpu12 board"
 	depends on ARCH_AUTCPU12
@@ -531,4 +540,9 @@
 	  Enables support for NAND Flash chips on the ST Microelectronics
 	  Flexible Static Memory Controller (FSMC)
 
+config MTD_NAND_DENALI_FBX
+	tristate "NAND Denali controller support"
+	depends on MTD_NAND && PCI
+	default n
+
 endif # MTD_NAND
diff -ruw linux-2.6.39.4/drivers/mtd/nand/Makefile linux-2.6.39.4-fbx/drivers/mtd/nand/Makefile
--- linux-2.6.39.4/drivers/mtd/nand/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/mtd/nand/Makefile	2011-06-15 18:56:42.615453828 +0200
@@ -49,5 +49,6 @@
 obj-$(CONFIG_MTD_NAND_MPC5121_NFC)	+= mpc5121_nfc.o
 obj-$(CONFIG_MTD_NAND_RICOH)		+= r852.o
 obj-$(CONFIG_MTD_NAND_JZ4740)		+= jz4740_nand.o
+obj-$(CONFIG_MTD_NAND_DENALI_FBX)	+= denali_nand.o
 
 nand-objs := nand_base.o nand_bbt.o
diff -ruw linux-2.6.39.4/drivers/mtd/nand/nand_base.c linux-2.6.39.4-fbx/drivers/mtd/nand/nand_base.c
--- linux-2.6.39.4/drivers/mtd/nand/nand_base.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/mtd/nand/nand_base.c	2011-06-22 19:20:26.542924107 +0200
@@ -2578,6 +2578,7 @@
 		/*
 		 * heck if we have a bad block, we do not erase bad blocks !
 		 */
+#ifndef CONFIG_MTD_FORCE_BAD_BLOCK_ERASE
 		if (nand_block_checkbad(mtd, ((loff_t) page) <<
 					chip->page_shift, 0, allowbbt)) {
 			printk(KERN_WARNING "%s: attempt to erase a bad block "
@@ -2585,6 +2586,7 @@
 			instr->state = MTD_ERASE_FAILED;
 			goto erase_exit;
 		}
+#endif
 
 		/*
 		 * Invalidate the page cache, if we erase the block which
@@ -2916,6 +2918,7 @@
 	int i, maf_idx;
 	u8 id_data[8];
 	int ret;
+	char onfi_version[5];
 
 	/* Select the device */
 	chip->select_chip(mtd, 0);
@@ -3140,6 +3143,7 @@
 			 *maf_id == NAND_MFR_MICRON))
 		chip->options |= NAND_BBT_SCAN2NDPAGE;
 
+#if 0
 	/*
 	 * Numonyx/ST 2K pages, x8 bus use BOTH byte 1 and 6
 	 */
@@ -3149,6 +3153,7 @@
 		chip->options |= NAND_BBT_SCANBYTE1AND6;
 		chip->badblockpos = 0;
 	}
+#endif
 
 	/* Check for AND chips with 4 page planes */
 	if (chip->options & NAND_4PAGE_ARRAY)
@@ -3166,7 +3171,38 @@
 		nand_manuf_ids[maf_idx].name,
 		chip->onfi_version ? chip->onfi_params.model : type->name);
 
+	mtd->nand_type = kstrdup(type->name, GFP_KERNEL);
+	if (!mtd->nand_type)
+		return ERR_PTR(-ENOMEM);
+
+	mtd->nand_manufacturer = kstrdup(nand_manuf_ids[maf_idx].name,
+						GFP_KERNEL);
+	if (!mtd->nand_manufacturer) {
+		ret = -ENOMEM;
+		goto out_nand_type;
+	}
+
+	snprintf(onfi_version, sizeof(onfi_version), "0");
+
+	if (chip->onfi_version)
+		snprintf(onfi_version, sizeof(onfi_version), "%d.%d",
+					chip->onfi_version / 10,
+					chip->onfi_version % 10);
+
+	mtd->onfi_version = kstrdup(onfi_version, GFP_KERNEL);
+	if (!mtd->onfi_version) {
+		ret = -ENOMEM;
+		goto out_nand_manufacturer;
+	}
+
 	return type;
+
+out_nand_manufacturer:
+	kfree(mtd->nand_manufacturer);
+out_nand_type:
+	kfree(mtd->nand_type);
+
+	return ERR_PTR(ret);
 }
 
 /**
@@ -3186,6 +3222,7 @@
 	int i, busw, nand_maf_id, nand_dev_id;
 	struct nand_chip *chip = mtd->priv;
 	struct nand_flash_dev *type;
+	int err;
 
 	/* Get buswidth to select the correct functions */
 	busw = chip->options & NAND_BUSWIDTH_16;
@@ -3200,7 +3237,8 @@
 		if (!(chip->options & NAND_SCAN_SILENT_NODEV))
 			printk(KERN_WARNING "No NAND device found.\n");
 		chip->select_chip(mtd, -1);
-		return PTR_ERR(type);
+		err = PTR_ERR(type);
+		goto out_error;
 	}
 
 	/* Check for a chip array */
@@ -3223,6 +3261,16 @@
 	mtd->size = i * chip->chipsize;
 
 	return 0;
+
+out_error:
+	if (mtd->nand_type)
+		kfree(mtd->nand_type);
+	if (mtd->nand_manufacturer)
+		kfree(mtd->nand_manufacturer);
+	if (mtd->onfi_version)
+		kfree(mtd->onfi_version);
+
+	return err;
 }
 EXPORT_SYMBOL(nand_scan_ident);
 
@@ -3345,9 +3393,13 @@
 		chip->ecc.read_page = nand_read_page_swecc;
 		chip->ecc.read_subpage = nand_read_subpage;
 		chip->ecc.write_page = nand_write_page_swecc;
+		if (!chip->ecc.read_page_raw)
 		chip->ecc.read_page_raw = nand_read_page_raw;
+		if (!chip->ecc.write_page_raw)
 		chip->ecc.write_page_raw = nand_write_page_raw;
+		if (!chip->ecc.read_oob)
 		chip->ecc.read_oob = nand_read_oob_std;
+		if (!chip->ecc.write_oob)
 		chip->ecc.write_oob = nand_write_oob_std;
 		if (!chip->ecc.size)
 			chip->ecc.size = 256;
diff -ruw linux-2.6.39.4/drivers/net/Kconfig linux-2.6.39.4-fbx/drivers/net/Kconfig
--- linux-2.6.39.4/drivers/net/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/net/Kconfig	2011-06-15 18:56:42.645453912 +0200
@@ -569,6 +569,21 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called sunhme.
 
+config TANGO2_ENET
+	tristate "SMP863x Builtin Ethernet support"
+	depends on NET_ETHERNET && TANGO2
+	select MII
+	select CRC32
+	help
+	 This option adds support for the SMP863x integrated Ethernet
+	 controller.  This driver uses NAPI and generic Linux MII
+	 support.
+
+config TANGO2_PCINET_H
+	tristate "SMP863x network over PCI support (smp863x side)"
+	depends on NET_ETHERNET && TANGO2
+
+
 config SUNBMAC
 	tristate "Sun BigMAC 10/100baseT support (EXPERIMENTAL)"
 	depends on SBUS && EXPERIMENTAL
@@ -2451,6 +2466,7 @@
 	depends on (MV64X60 || PPC32 || PLAT_ORION) && INET
 	select INET_LRO
 	select PHYLIB
+	select MII
 	help
 	  This driver supports the gigabit ethernet MACs in the
 	  Marvell Discovery PPC/MIPS chipset family (MV643XX) and
diff -ruw linux-2.6.39.4/drivers/net/Makefile linux-2.6.39.4-fbx/drivers/net/Makefile
--- linux-2.6.39.4/drivers/net/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/net/Makefile	2011-06-15 18:56:42.645453912 +0200
@@ -58,6 +58,8 @@
 obj-$(CONFIG_SUNLANCE) += sunlance.o
 obj-$(CONFIG_SUNQE) += sunqe.o
 obj-$(CONFIG_SUNBMAC) += sunbmac.o
+obj-$(CONFIG_TANGO2_ENET) += tango2_enet.o
+obj-$(CONFIG_TANGO2_PCINET_H) += tango2_pcinet_h.o
 obj-$(CONFIG_MYRI_SBUS) += myri_sbus.o
 obj-$(CONFIG_SUNGEM) += sungem.o sungem_phy.o
 obj-$(CONFIG_CASSINI) += cassini.o
diff -ruw linux-2.6.39.4/drivers/net/mv643xx_eth.c linux-2.6.39.4-fbx/drivers/net/mv643xx_eth.c
--- linux-2.6.39.4/drivers/net/mv643xx_eth.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/net/mv643xx_eth.c	2011-06-15 18:56:42.825454419 +0200
@@ -57,6 +57,7 @@
 #include <linux/types.h>
 #include <linux/inet_lro.h>
 #include <linux/slab.h>
+#include <linux/if_vlan.h>
 #include <asm/system.h>
 
 static char mv643xx_eth_driver_name[] = "mv643xx_eth";
@@ -136,6 +137,8 @@
 #define INT_MASK			0x0068
 #define INT_MASK_EXT			0x006c
 #define TX_FIFO_URGENT_THRESHOLD	0x0074
+#define RX_DISCARD_CTR			0x0084
+#define RX_OVERRUN_CTR			0x0088
 #define TXQ_FIX_PRIO_CONF_MOVED		0x00dc
 #define TX_BW_RATE_MOVED		0x00e0
 #define TX_BW_MTU_MOVED			0x00e8
@@ -226,6 +229,11 @@
 
 /* RX & TX descriptor status */
 #define ERROR_SUMMARY			0x00000001
+#define ERROR_CODE_RX_CRC		(0x0 << 1)
+#define ERROR_CODE_RX_OVERRUN		(0x1 << 1)
+#define ERROR_CODE_RX_MAX_LENGTH	(0x2 << 1)
+#define ERROR_CODE_RX_RESOURCE		(0x3 << 1)
+#define ERROR_CODE_MASK			(0x3 << 1)
 
 /* RX descriptor status */
 #define LAYER_4_CHECKSUM_OK		0x40000000
@@ -342,6 +350,11 @@
 	u32 lro_no_desc;
 };
 
+struct mac_counters {
+	u32 rx_discard;
+	u32 rx_overrun;
+};
+
 struct rx_queue {
 	int index;
 
@@ -393,6 +406,8 @@
 	spinlock_t mib_counters_lock;
 	struct mib_counters mib_counters;
 
+	struct mac_counters mac_counters;
+
 	struct lro_counters lro_counters;
 
 	struct work_struct tx_timeout_task;
@@ -408,6 +423,7 @@
 
 	int skb_size;
 	struct sk_buff_head rx_recycle;
+	struct vlan_group *vlgrp;
 
 	/*
 	 * RX state.
@@ -518,6 +534,15 @@
 	}
 }
 
+static void mv643xx_eth_vlan_rx_register(struct net_device *dev,
+					 struct vlan_group *grp)
+{
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
+
+	napi_disable(&mp->napi);
+	mp->vlgrp = grp;
+	napi_enable(&mp->napi);
+}
 
 /* rx napi ******************************************************************/
 static int
@@ -612,6 +637,20 @@
 
 		if (cmd_sts & LAYER_4_CHECKSUM_OK)
 			skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+		if (mp->vlgrp && (cmd_sts & RX_PKT_IS_VLAN_TAGGED)) {
+			struct vlan_hdr *vhdr;
+			u16 tci;
+
+			vhdr = (struct vlan_hdr *)(skb->data + 14);
+			tci = ntohs(vhdr->h_vlan_TCI);
+			memmove(skb->data + 4, skb->data, 12);
+			skb_pull_rcsum(skb, 4);
+			skb->protocol = eth_type_trans(skb, mp->dev);
+			vlan_hwaccel_receive_skb(skb, mp->vlgrp, tci);
+			continue;
+		}
+
 		skb->protocol = eth_type_trans(skb, mp->dev);
 
 		if (skb->dev->features & NETIF_F_LRO &&
@@ -633,8 +672,22 @@
 					   "received packet spanning multiple descriptors\n");
 		}
 
-		if (cmd_sts & ERROR_SUMMARY)
+		if (cmd_sts & ERROR_SUMMARY) {
 			stats->rx_errors++;
+			if (cmd_sts & RX_FIRST_DESC) {
+				switch (cmd_sts & ERROR_CODE_MASK) {
+				case ERROR_CODE_RX_MAX_LENGTH:
+					stats->rx_length_errors++;
+					break;
+				case ERROR_CODE_RX_CRC:
+					stats->rx_crc_errors++;
+					break;
+				case ERROR_CODE_RX_OVERRUN:
+					stats->rx_fifo_errors++;
+					break;
+				}
+			}
+		}
 
 		dev_kfree_skb(skb);
 	}
@@ -1115,9 +1168,10 @@
 	return 0;
 }
 
-static int smi_bus_read(struct mii_bus *bus, int addr, int reg)
+static int __smi_bus_read(struct mv643xx_eth_shared_private *msp,
+			  int addr, int reg)
 {
-	struct mv643xx_eth_shared_private *msp = bus->priv;
+	
 	void __iomem *smi_reg = msp->base + SMI_REG;
 	int ret;
 
@@ -1142,9 +1196,14 @@
 	return ret & 0xffff;
 }
 
-static int smi_bus_write(struct mii_bus *bus, int addr, int reg, u16 val)
+static int smi_bus_read(struct mii_bus *bus, int addr, int reg)
+{
+	return __smi_bus_read(bus->priv, addr, reg);
+}
+
+static int __smi_bus_write(struct mv643xx_eth_shared_private *msp,
+			   int addr, int reg, u16 val)
 {
-	struct mv643xx_eth_shared_private *msp = bus->priv;
 	void __iomem *smi_reg = msp->base + SMI_REG;
 
 	if (smi_wait_ready(msp)) {
@@ -1163,6 +1222,10 @@
 	return 0;
 }
 
+static int smi_bus_write(struct mii_bus *bus, int addr, int reg, u16 val)
+{
+	return __smi_bus_write(bus->priv, addr, reg, val);
+}
 
 /* statistics ***************************************************************/
 static struct net_device_stats *mv643xx_eth_get_stats(struct net_device *dev)
@@ -1189,6 +1252,18 @@
 	return stats;
 }
 
+static void mac_stats_clear(struct mv643xx_eth_private *mp)
+{
+	rdlp(mp, RX_DISCARD_CTR);
+	rdlp(mp, RX_OVERRUN_CTR);
+}
+
+static void mv643xx_eth_grab_mac_stats(struct mv643xx_eth_private *mp)
+{
+	mp->mac_counters.rx_discard += rdlp(mp, RX_DISCARD_CTR);
+	mp->mac_counters.rx_overrun += rdlp(mp, RX_OVERRUN_CTR);
+}
+
 static void mv643xx_eth_grab_lro_stats(struct mv643xx_eth_private *mp)
 {
 	u32 lro_aggregated = 0;
@@ -1369,6 +1444,10 @@
 	{ #m, FIELD_SIZEOF(struct lro_counters, m),		\
 	  -1, offsetof(struct mv643xx_eth_private, lro_counters.m) }
 
+#define MACSTAT(m)						\
+	{ #m, FIELD_SIZEOF(struct mac_counters, m),		\
+	  -1, offsetof(struct mv643xx_eth_private, mac_counters.m) }
+
 static const struct mv643xx_eth_stats mv643xx_eth_stats[] = {
 	SSTAT(rx_packets),
 	SSTAT(tx_packets),
@@ -1411,6 +1490,8 @@
 	LROSTAT(lro_aggregated),
 	LROSTAT(lro_flushed),
 	LROSTAT(lro_no_desc),
+	MACSTAT(rx_discard),
+	MACSTAT(rx_overrun),
 };
 
 static int
@@ -1617,6 +1698,7 @@
 	mv643xx_eth_get_stats(dev);
 	mib_counters_update(mp);
 	mv643xx_eth_grab_lro_stats(mp);
+	mv643xx_eth_grab_mac_stats(mp);
 
 	for (i = 0; i < ARRAY_SIZE(mv643xx_eth_stats); i++) {
 		const struct mv643xx_eth_stats *stat;
@@ -2446,12 +2528,43 @@
 	return 0;
 }
 
+/*
+ * MII read callback from mii core
+ */
+static int smi_bus_read_mii(struct net_device *dev, int mii_id,
+			    int regnum)
+{
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
+	return __smi_bus_read(mp->shared, mii_id, regnum);
+}
+
+/*
+ * MII write callback from mii core
+ */
+static void smi_bus_write_mii(struct net_device *dev, int mii_id,
+			      int regnum, int value)
+{
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
+	__smi_bus_write(mp->shared, mii_id, regnum, value);
+}
+
 static int mv643xx_eth_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
 	struct mv643xx_eth_private *mp = netdev_priv(dev);
 
 	if (mp->phy != NULL)
 		return phy_mii_ioctl(mp->phy, ifr, cmd);
+	else {
+		struct mii_if_info mii;
+
+		mii.dev = dev;
+		mii.mdio_read = smi_bus_read_mii;
+		mii.mdio_write = smi_bus_write_mii;
+		mii.phy_id = 0;
+		mii.phy_id_mask = 0x3f;
+		mii.reg_num_mask = 0x1f;
+		return generic_mii_ioctl(&mii, if_mii(ifr), cmd, NULL);
+	}
 
 	return -EOPNOTSUPP;
 }
@@ -2853,6 +2966,7 @@
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller	= mv643xx_eth_netpoll,
 #endif
+	.ndo_vlan_rx_register	= mv643xx_eth_vlan_rx_register,
 };
 
 static int mv643xx_eth_probe(struct platform_device *pdev)
@@ -2893,6 +3007,16 @@
 
 	if (pd->phy_addr != MV643XX_ETH_PHY_NONE)
 		mp->phy = phy_scan(mp, pd->phy_addr);
+	else {
+		if (pd->mii_config &&
+		    pd->mii_config(dev, 1,
+				   smi_bus_read_mii,
+				   smi_bus_write_mii)) {
+			dev_err(&pdev->dev, "unable to configure mdio bus\n");
+			err = -EIO;
+			goto out;
+		}
+	}
 
 	if (mp->phy != NULL)
 		phy_init(mp, pd->speed, pd->duplex);
@@ -2930,7 +3054,7 @@
 	dev->watchdog_timeo = 2 * HZ;
 	dev->base_addr = 0;
 
-	dev->features = NETIF_F_SG | NETIF_F_IP_CSUM;
+	dev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_HW_VLAN_RX;
 	dev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM;
 
 	SET_NETDEV_DEV(dev, &pdev->dev);
@@ -2955,6 +3079,7 @@
 	if (mp->tx_desc_sram_size > 0)
 		netdev_notice(dev, "configured with sram\n");
 
+	mac_stats_clear(mp);
 	return 0;
 
 out:
diff -ruw linux-2.6.39.4/drivers/net/ppp_generic.c linux-2.6.39.4-fbx/drivers/net/ppp_generic.c
--- linux-2.6.39.4/drivers/net/ppp_generic.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/net/ppp_generic.c	2011-06-15 18:56:42.845454475 +0200
@@ -162,6 +162,7 @@
 	struct ppp	*ppp;		/* ppp unit we're connected to */
 	struct net	*chan_net;	/* the net channel belongs to */
 	struct list_head clist;		/* link in list of channels per unit */
+	int		stopped;	/* channel is stopped */
 	rwlock_t	upl;		/* protects `ppp' */
 #ifdef CONFIG_PPP_MULTILINK
 	u8		avail;		/* flag used in multilink stuff */
@@ -1061,8 +1062,21 @@
 			ppp_send_frame(ppp, skb);
 		/* If there's no work left to do, tell the core net
 		   code that we can accept some more. */
-		if (!ppp->xmit_pending && !skb_peek(&ppp->file.xq))
+		if (!ppp->xmit_pending && !skb_peek(&ppp->file.xq)) {
+			/* only  enable  net  queue  if at  least  one
+			 * channel is not stopped */
+			struct list_head *list;
+			struct channel *pch;
+
+			list = &ppp->channels;
+			while ((list = list->next) != &ppp->channels) {
+				pch = list_entry(list, struct channel, clist);
+				if (!pch->stopped) {
 			netif_wake_queue(ppp->dev);
+					break;
+				}
+			}
+		}
 	}
 	ppp_xmit_unlock(ppp);
 }
@@ -2263,10 +2277,24 @@
 
 	if (!pch)
 		return;
+	pch->stopped = 0;
 	ppp_channel_push(pch);
 }
 
 /*
+ * Callback from a channel when it want to prevent further transmit on it
+ */
+void
+ppp_output_stop(struct ppp_channel *chan)
+{
+	struct channel *pch = chan->ppp;
+
+	if (pch == 0)
+		return;
+	pch->stopped = 1;
+}
+
+/*
  * Compression control.
  */
 
@@ -2947,6 +2975,7 @@
 EXPORT_SYMBOL(ppp_input);
 EXPORT_SYMBOL(ppp_input_error);
 EXPORT_SYMBOL(ppp_output_wakeup);
+EXPORT_SYMBOL(ppp_output_stop);
 EXPORT_SYMBOL(ppp_register_compressor);
 EXPORT_SYMBOL(ppp_unregister_compressor);
 MODULE_LICENSE("GPL");
diff -ruw linux-2.6.39.4/drivers/net/wireless/mwl8k.c linux-2.6.39.4-fbx/drivers/net/wireless/mwl8k.c
--- linux-2.6.39.4/drivers/net/wireless/mwl8k.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/net/wireless/mwl8k.c	2011-09-06 15:55:33.966661794 +0200
@@ -63,6 +63,7 @@
 #define MWL8K_HIU_A2H_INTERRUPT_CLEAR_SEL	0x00000c38
 #define MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK	0x00000c3c
 #define  MWL8K_A2H_INT_DUMMY			 (1 << 20)
+#define  MWL8K_A2H_INT_BA_WATCHDOG		 (1 << 14)
 #define  MWL8K_A2H_INT_CHNL_SWITCHED		 (1 << 11)
 #define  MWL8K_A2H_INT_QUEUE_EMPTY		 (1 << 10)
 #define  MWL8K_A2H_INT_RADAR_DETECT		 (1 << 7)
@@ -73,6 +74,14 @@
 #define  MWL8K_A2H_INT_RX_READY			 (1 << 1)
 #define  MWL8K_A2H_INT_TX_DONE			 (1 << 0)
 
+/* HW micro second timer register
+ * located at offset 0xA600. This
+ * will be used to timestamp tx
+ * packets.
+ */
+
+#define	MWL8K_HW_TIMER_REGISTER			0x0000a600
+
 #define MWL8K_A2H_EVENTS	(MWL8K_A2H_INT_DUMMY | \
 				 MWL8K_A2H_INT_CHNL_SWITCHED | \
 				 MWL8K_A2H_INT_QUEUE_EMPTY | \
@@ -82,10 +91,14 @@
 				 MWL8K_A2H_INT_MAC_EVENT | \
 				 MWL8K_A2H_INT_OPC_DONE | \
 				 MWL8K_A2H_INT_RX_READY | \
-				 MWL8K_A2H_INT_TX_DONE)
+				 MWL8K_A2H_INT_TX_DONE | \
+				 MWL8K_A2H_INT_BA_WATCHDOG)
 
 #define MWL8K_RX_QUEUES		1
-#define MWL8K_TX_QUEUES		4
+#define MWL8K_TX_WMM_QUEUES	4
+#define MWL8K_MAX_AMPDU_QUEUES	8
+#define MWL8K_MAX_TX_QUEUES	(MWL8K_TX_WMM_QUEUES + MWL8K_MAX_AMPDU_QUEUES)
+#define mwl8k_tx_queues(priv)	(MWL8K_TX_WMM_QUEUES + (priv)->num_ampdu_queues)
 
 struct rxd_ops {
 	int rxd_size;
@@ -134,6 +147,21 @@
 	struct sk_buff **skb;
 };
 
+enum {
+	AMPDU_NO_STREAM,
+	AMPDU_STREAM_NEW,
+	AMPDU_STREAM_IN_PROGRESS,
+	AMPDU_STREAM_ACTIVE,
+};
+
+struct mwl8k_ampdu_stream {
+	struct ieee80211_sta *sta;
+	u8 tid;
+	u8 state;
+	u8 idx;
+	u8 txq_idx; /* index of this stream in priv->txq */
+};
+
 struct mwl8k_priv {
 	struct ieee80211_hw *hw;
 	struct pci_dev *pdev;
@@ -160,6 +188,12 @@
 	u32 ap_macids_supported;
 	u32 sta_macids_supported;
 
+	/* Ampdu stream information */
+	u8 num_ampdu_queues;
+	spinlock_t stream_lock;
+	struct mwl8k_ampdu_stream ampdu[MWL8K_MAX_AMPDU_QUEUES];
+	struct work_struct watchdog_ba_handle;
+
 	/* firmware access */
 	struct mutex fw_mutex;
 	struct task_struct *fw_mutex_owner;
@@ -191,7 +225,8 @@
 	int pending_tx_pkts;
 
 	struct mwl8k_rx_queue rxq[MWL8K_RX_QUEUES];
-	struct mwl8k_tx_queue txq[MWL8K_TX_QUEUES];
+	struct mwl8k_tx_queue txq[MWL8K_MAX_TX_QUEUES];
+	u32 txq_offset[MWL8K_MAX_TX_QUEUES];
 
 	bool radio_on;
 	bool radio_short_preamble;
@@ -224,7 +259,7 @@
 	 * preserve the queue configurations so they can be restored if/when
 	 * the firmware image is swapped.
 	 */
-	struct ieee80211_tx_queue_params wmm_params[MWL8K_TX_QUEUES];
+	struct ieee80211_tx_queue_params wmm_params[MWL8K_TX_WMM_QUEUES];
 
 	/* async firmware loading state */
 	unsigned fw_state;
@@ -262,9 +297,17 @@
 #define MWL8K_VIF(_vif) ((struct mwl8k_vif *)&((_vif)->drv_priv))
 #define IEEE80211_KEY_CONF(_u8) ((struct ieee80211_key_conf *)(_u8))
 
+struct tx_traffic_info {
+	u32 start_time;
+	u32 pkts;
+};
+
+#define MWL8K_MAX_TID 8
 struct mwl8k_sta {
 	/* Index into station database. Returned by UPDATE_STADB.  */
 	u8 peer_id;
+	u8 is_ampdu_allowed;
+	struct tx_traffic_info tx_stats[MWL8K_MAX_TID];
 };
 #define MWL8K_STA(_sta) ((struct mwl8k_sta *)&((_sta)->drv_priv))
 
@@ -352,10 +395,12 @@
 #define MWL8K_CMD_ENABLE_SNIFFER	0x0150
 #define MWL8K_CMD_SET_MAC_ADDR		0x0202		/* per-vif */
 #define MWL8K_CMD_SET_RATEADAPT_MODE	0x0203
+#define MWL8K_CMD_GET_WATCHDOG_BITMAP	0x0205
 #define MWL8K_CMD_BSS_START		0x1100		/* per-vif */
 #define MWL8K_CMD_SET_NEW_STN		0x1111		/* per-vif */
 #define MWL8K_CMD_UPDATE_ENCRYPTION	0x1122		/* per-vif */
 #define MWL8K_CMD_UPDATE_STADB		0x1123
+#define MWL8K_CMD_BASTREAM		0x1125
 
 static const char *mwl8k_cmd_name(__le16 cmd, char *buf, int bufsize)
 {
@@ -395,6 +440,8 @@
 		MWL8K_CMDNAME(SET_NEW_STN);
 		MWL8K_CMDNAME(UPDATE_ENCRYPTION);
 		MWL8K_CMDNAME(UPDATE_STADB);
+		MWL8K_CMDNAME(BASTREAM);
+		MWL8K_CMDNAME(GET_WATCHDOG_BITMAP);
 	default:
 		snprintf(buf, bufsize, "0x%x", cmd);
 	}
@@ -669,7 +716,7 @@
 			       "helper image\n", pci_name(priv->pdev));
 			return rc;
 		}
-		msleep(5);
+		msleep(20);
 
 		rc = mwl8k_feed_fw_image(priv, fw->data, fw->size);
 	} else {
@@ -734,8 +781,11 @@
 		skb_pull(skb, sizeof(*tr) - hdrlen);
 }
 
+#define REDUCED_TX_HEADROOM	8
+
 static void
-mwl8k_add_dma_header(struct sk_buff *skb, int tail_pad)
+mwl8k_add_dma_header(struct mwl8k_priv *priv, struct sk_buff *skb,
+						int head_pad, int tail_pad)
 {
 	struct ieee80211_hdr *wh;
 	int hdrlen;
@@ -751,7 +801,23 @@
 	wh = (struct ieee80211_hdr *)skb->data;
 
 	hdrlen = ieee80211_hdrlen(wh->frame_control);
-	reqd_hdrlen = sizeof(*tr);
+
+	/*
+	 * Check if skb_resize is required because of
+	 * tx_headroom adjustment.
+	 */
+	if (priv->ap_fw && (hdrlen < (sizeof(struct ieee80211_cts)
+						+ REDUCED_TX_HEADROOM))) {
+		if (pskb_expand_head(skb, REDUCED_TX_HEADROOM, 0, GFP_ATOMIC)) {
+
+			wiphy_err(priv->hw->wiphy,
+					"Failed to reallocate TX buffer\n");
+			return;
+		}
+		skb->truesize += REDUCED_TX_HEADROOM;
+	}
+
+	reqd_hdrlen = sizeof(*tr) + head_pad;
 
 	if (hdrlen != reqd_hdrlen)
 		skb_push(skb, reqd_hdrlen - hdrlen);
@@ -773,12 +839,14 @@
 	tr->fwlen = cpu_to_le16(skb->len - sizeof(*tr) + tail_pad);
 }
 
-static void mwl8k_encapsulate_tx_frame(struct sk_buff *skb)
+static void mwl8k_encapsulate_tx_frame(struct mwl8k_priv *priv,
+		struct sk_buff *skb)
 {
 	struct ieee80211_hdr *wh;
 	struct ieee80211_tx_info *tx_info;
 	struct ieee80211_key_conf *key_conf;
 	int data_pad;
+	int head_pad = 0;
 
 	wh = (struct ieee80211_hdr *)skb->data;
 
@@ -790,9 +858,7 @@
 
 	/*
 	 * Make sure the packet header is in the DMA header format (4-address
-	 * without QoS), the necessary crypto padding between the header and the
-	 * payload has already been provided by mac80211, but it doesn't add tail
-	 * padding when HW crypto is enabled.
+	 * without QoS), and add head & tail padding when HW crypto is enabled.
 	 *
 	 * We have the following trailer padding requirements:
 	 * - WEP: 4 trailer bytes (ICV)
@@ -801,6 +867,7 @@
 	 */
 	data_pad = 0;
 	if (key_conf != NULL) {
+		head_pad = key_conf->iv_len;
 		switch (key_conf->cipher) {
 		case WLAN_CIPHER_SUITE_WEP40:
 		case WLAN_CIPHER_SUITE_WEP104:
@@ -814,7 +881,7 @@
 			break;
 		}
 	}
-	mwl8k_add_dma_header(skb, data_pad);
+	mwl8k_add_dma_header(priv, skb, head_pad, data_pad);
 }
 
 /*
@@ -1127,6 +1194,9 @@
 	struct mwl8k_rx_queue *rxq = priv->rxq + index;
 	int i;
 
+	if (rxq->rxd == NULL)
+		return;
+
 	for (i = 0; i < MWL8K_RX_DESCS; i++) {
 		if (rxq->buf[i].skb != NULL) {
 			pci_unmap_single(priv->pdev,
@@ -1319,7 +1389,7 @@
 	__le16 pkt_len;
 	__u8 dest_MAC_addr[ETH_ALEN];
 	__le32 next_txd_phys_addr;
-	__le32 reserved;
+	__le32 timestamp;
 	__le16 rate_info;
 	__u8 peer_id;
 	__u8 tx_frag_cnt;
@@ -1383,7 +1453,7 @@
 	struct mwl8k_priv *priv = hw->priv;
 	int i;
 
-	for (i = 0; i < MWL8K_TX_QUEUES; i++) {
+	for (i = 0; i < mwl8k_tx_queues(priv); i++) {
 		struct mwl8k_tx_queue *txq = priv->txq + i;
 		int fw_owned = 0;
 		int drv_owned = 0;
@@ -1452,9 +1522,8 @@
 
 		if (timeout) {
 			WARN_ON(priv->pending_tx_pkts);
-			if (retry) {
+			if (retry)
 				wiphy_notice(hw->wiphy, "tx rings drained\n");
-			}
 			break;
 		}
 
@@ -1484,6 +1553,41 @@
 		     MWL8K_TXD_STATUS_OK_RETRY |		\
 		     MWL8K_TXD_STATUS_OK_MORE_RETRY))
 
+static int mwl8k_tid_queue_mapping(u8 tid)
+{
+	BUG_ON(tid > 7);
+
+	switch (tid) {
+	case 0:
+	case 3:
+		return IEEE80211_AC_BE;
+		break;
+	case 1:
+	case 2:
+		return IEEE80211_AC_BK;
+		break;
+	case 4:
+	case 5:
+		return IEEE80211_AC_VI;
+		break;
+	case 6:
+	case 7:
+		return IEEE80211_AC_VO;
+		break;
+	default:
+		return -1;
+		break;
+	}
+}
+
+/* The firmware will fill in the rate information
+ * for each packet that gets queued in the hardware
+ * and these macros will interpret that info.
+ */
+
+#define RI_FORMAT(a)		  (a & 0x0001)
+#define RI_RATE_ID_MCS(a)	 ((a & 0x01f8) >> 3)
+
 static int
 mwl8k_txq_reclaim(struct ieee80211_hw *hw, int index, int limit, int force)
 {
@@ -1500,6 +1604,10 @@
 		struct sk_buff *skb;
 		struct ieee80211_tx_info *info;
 		u32 status;
+		struct ieee80211_sta *sta;
+		struct mwl8k_sta *sta_info = NULL;
+		u16 rate_info;
+		struct ieee80211_hdr *wh;
 
 		tx = txq->head;
 		tx_desc = txq->txd + tx;
@@ -1528,11 +1636,33 @@
 
 		mwl8k_remove_dma_header(skb, tx_desc->qos_control);
 
+		wh = (struct ieee80211_hdr *) skb->data;
+
 		/* Mark descriptor as unused */
 		tx_desc->pkt_phys_addr = 0;
 		tx_desc->pkt_len = 0;
 
 		info = IEEE80211_SKB_CB(skb);
+		if (ieee80211_is_data(wh->frame_control)) {
+			sta = info->control.sta;
+			if (sta) {
+				sta_info = MWL8K_STA(sta);
+				BUG_ON(sta_info == NULL);
+				rate_info = le16_to_cpu(tx_desc->rate_info);
+				/* If rate is < 6.5 Mpbs for an ht station
+				 * do not form an ampdu. If the station is a
+				 * legacy station (format = 0), do not form an
+				 * ampdu
+				 */
+				if (RI_RATE_ID_MCS(rate_info) < 1 ||
+				    RI_FORMAT(rate_info) == 0) {
+					sta_info->is_ampdu_allowed = false;
+				} else {
+					sta_info->is_ampdu_allowed = true;
+				}
+			}
+		}
+
 		ieee80211_tx_info_clear_status(info);
 
 		/* Rate control is happening in the firmware.
@@ -1549,9 +1679,6 @@
 		processed++;
 	}
 
-	if (processed && priv->radio_on && !mutex_is_locked(&priv->fw_mutex))
-		ieee80211_wake_queue(hw, index);
-
 	return processed;
 }
 
@@ -1561,6 +1688,9 @@
 	struct mwl8k_priv *priv = hw->priv;
 	struct mwl8k_tx_queue *txq = priv->txq + index;
 
+	if (txq->txd == NULL)
+		return;
+
 	mwl8k_txq_reclaim(hw, index, INT_MAX, 1);
 
 	kfree(txq->skb);
@@ -1572,12 +1702,116 @@
 	txq->txd = NULL;
 }
 
+/* caller must hold priv->stream_lock when calling the stream functions */
+static struct mwl8k_ampdu_stream *
+mwl8k_add_stream(struct ieee80211_hw *hw, struct ieee80211_sta *sta, u8 tid)
+{
+	struct mwl8k_ampdu_stream *stream;
+	struct mwl8k_priv *priv = hw->priv;
+	int i;
+
+	for (i = 0; i < priv->num_ampdu_queues; i++) {
+		stream = &priv->ampdu[i];
+		if (stream->state == AMPDU_NO_STREAM) {
+			stream->sta = sta;
+			stream->state = AMPDU_STREAM_NEW;
+			stream->tid = tid;
+			stream->idx = i;
+			stream->txq_idx = MWL8K_TX_WMM_QUEUES + i;
+			wiphy_debug(hw->wiphy, "Added a new stream for %pM %d",
+				    sta->addr, tid);
+			return stream;
+		}
+	}
+	return NULL;
+}
+
+static int
+mwl8k_start_stream(struct ieee80211_hw *hw, struct mwl8k_ampdu_stream *stream)
+{
+	int ret;
+
+	/* if the stream has already been started, don't start it again */
+	if (stream->state != AMPDU_STREAM_NEW)
+		return 0;
+	ret = ieee80211_start_tx_ba_session(stream->sta, stream->tid, 0);
+	if (ret)
+		wiphy_debug(hw->wiphy, "Failed to start stream for %pM %d: "
+			    "%d\n", stream->sta->addr, stream->tid, ret);
+	else
+		wiphy_debug(hw->wiphy, "Started stream for %pM %d\n",
+			    stream->sta->addr, stream->tid);
+	return ret;
+}
+
+static void
+mwl8k_remove_stream(struct ieee80211_hw *hw, struct mwl8k_ampdu_stream *stream)
+{
+	wiphy_debug(hw->wiphy, "Remove stream for %pM %d\n", stream->sta->addr,
+		    stream->tid);
+	memset(stream, 0, sizeof(*stream));
+}
+
+static struct mwl8k_ampdu_stream *
+mwl8k_lookup_stream(struct ieee80211_hw *hw, u8 *addr, u8 tid)
+{
+	struct mwl8k_priv *priv = hw->priv;
+	int i;
+
+	for (i = 0 ; i < priv->num_ampdu_queues; i++) {
+		struct mwl8k_ampdu_stream *stream;
+		stream = &priv->ampdu[i];
+		if (stream->state == AMPDU_NO_STREAM)
+			continue;
+		if (!memcmp(stream->sta->addr, addr, ETH_ALEN) &&
+		    stream->tid == tid)
+			return stream;
+	}
+	return NULL;
+}
+
+#define MWL8K_AMPDU_PACKET_THRESHOLD 64
+static inline bool mwl8k_ampdu_allowed(struct ieee80211_sta *sta, u8 tid)
+{
+	struct mwl8k_sta *sta_info = MWL8K_STA(sta);
+	struct tx_traffic_info *tx_stats;
+
+	BUG_ON(tid >= MWL8K_MAX_TID);
+	tx_stats = &sta_info->tx_stats[tid];
+
+	return sta_info->is_ampdu_allowed &&
+		tx_stats->pkts > MWL8K_AMPDU_PACKET_THRESHOLD;
+}
+
+static inline void mwl8k_tx_count_packet(struct ieee80211_sta *sta, u8 tid)
+{
+	struct mwl8k_sta *sta_info = MWL8K_STA(sta);
+	struct tx_traffic_info *tx_stats;
+
+	BUG_ON(tid >= MWL8K_MAX_TID);
+	tx_stats = &sta_info->tx_stats[tid];
+
+	if (tx_stats->start_time == 0)
+		tx_stats->start_time = jiffies;
+
+	/* reset the packet count after each second elapses.  If the number of
+	 * packets ever exceeds the ampdu_min_traffic threshold, we will allow
+	 * an ampdu stream to be started.
+	 */
+	if (jiffies - tx_stats->start_time > HZ) {
+		tx_stats->pkts = 0;
+		tx_stats->start_time = 0;
+	} else
+		tx_stats->pkts++;
+}
+
 static void
 mwl8k_txq_xmit(struct ieee80211_hw *hw, int index, struct sk_buff *skb)
 {
 	struct mwl8k_priv *priv = hw->priv;
 	struct ieee80211_tx_info *tx_info;
 	struct mwl8k_vif *mwl8k_vif;
+	struct ieee80211_sta *sta;
 	struct ieee80211_hdr *wh;
 	struct mwl8k_tx_queue *txq;
 	struct mwl8k_tx_desc *tx;
@@ -1585,6 +1819,12 @@
 	u32 txstatus;
 	u8 txdatarate;
 	u16 qos;
+	int txpriority;
+	u8 tid = 0;
+	struct mwl8k_ampdu_stream *stream = NULL;
+	bool start_ba_session = false;
+	bool mgmtframe = false;
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
 
 	wh = (struct ieee80211_hdr *)skb->data;
 	if (ieee80211_is_data_qos(wh->frame_control))
@@ -1592,14 +1832,18 @@
 	else
 		qos = 0;
 
+	if (ieee80211_is_mgmt(wh->frame_control))
+		mgmtframe = true;
+
 	if (priv->ap_fw)
-		mwl8k_encapsulate_tx_frame(skb);
+		mwl8k_encapsulate_tx_frame(priv, skb);
 	else
-		mwl8k_add_dma_header(skb, 0);
+		mwl8k_add_dma_header(priv, skb, 0, 0);
 
 	wh = &((struct mwl8k_dma_data *)skb->data)->wh;
 
 	tx_info = IEEE80211_SKB_CB(skb);
+	sta = tx_info->control.sta;
 	mwl8k_vif = MWL8K_VIF(tx_info->control.vif);
 
 	if (tx_info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {
@@ -1627,12 +1871,91 @@
 			qos |= MWL8K_QOS_ACK_POLICY_NORMAL;
 	}
 
+	/* Queue ADDBA request in the respective data queue.  While setting up
+	 * the ampdu stream, mac80211 queues further packets for that
+	 * particular ra/tid pair.  However, packets piled up in the hardware
+	 * for that ra/tid pair will still go out. ADDBA request and the
+	 * related data packets going out from different queues asynchronously
+	 * will cause a shift in the receiver window which might result in
+	 * ampdu packets getting dropped at the receiver after the stream has
+	 * been setup.
+	 */
+	if (unlikely(ieee80211_is_action(wh->frame_control) &&
+	    mgmt->u.action.category == WLAN_CATEGORY_BACK &&
+	    mgmt->u.action.u.addba_req.action_code == WLAN_ACTION_ADDBA_REQ &&
+	    priv->ap_fw)) {
+		u16 capab = le16_to_cpu(mgmt->u.action.u.addba_req.capab);
+		tid = (capab & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;
+		index = mwl8k_tid_queue_mapping(tid);
+	}
+
+	txpriority = index;
+
+	if (ieee80211_is_data_qos(wh->frame_control) &&
+	    skb->protocol != cpu_to_be16(ETH_P_PAE) &&
+	    sta->ht_cap.ht_supported && priv->ap_fw) {
+		tid = qos & 0xf;
+		mwl8k_tx_count_packet(sta, tid);
+		spin_lock(&priv->stream_lock);
+		stream = mwl8k_lookup_stream(hw, sta->addr, tid);
+		if (stream != NULL) {
+			if (stream->state == AMPDU_STREAM_ACTIVE) {
+				txpriority = stream->txq_idx;
+				index = stream->txq_idx;
+			} else if (stream->state == AMPDU_STREAM_NEW) {
+				/* We get here if the driver sends us packets
+				 * after we've initiated a stream, but before
+				 * our ampdu_action routine has been called
+				 * with IEEE80211_AMPDU_TX_START to get the SSN
+				 * for the ADDBA request.  So this packet can
+				 * go out with no risk of sequence number
+				 * mismatch.  No special handling is required.
+				 */
+			} else {
+				/* Drop packets that would go out after the
+				 * ADDBA request was sent but before the ADDBA
+				 * response is received.  If we don't do this,
+				 * the recipient would probably receive it
+				 * after the ADDBA request with SSN 0.  This
+				 * will cause the recipient's BA receive window
+				 * to shift, which would cause the subsequent
+				 * packets in the BA stream to be discarded.
+				 * mac80211 queues our packets for us in this
+				 * case, so this is really just a safety check.
+				 */
+				wiphy_warn(hw->wiphy,
+					   "Cannot send packet while ADDBA "
+					   "dialog is underway.\n");
+				spin_unlock(&priv->stream_lock);
+				dev_kfree_skb(skb);
+				return;
+			}
+		} else {
+			/* Defer calling mwl8k_start_stream so that the current
+			 * skb can go out before the ADDBA request.  This
+			 * prevents sequence number mismatch at the recepient
+			 * as described above.
+			 */
+			if (mwl8k_ampdu_allowed(sta, tid)) {
+				stream = mwl8k_add_stream(hw, sta, tid);
+				if (stream != NULL)
+					start_ba_session = true;
+			}
+		}
+		spin_unlock(&priv->stream_lock);
+	}
+
 	dma = pci_map_single(priv->pdev, skb->data,
 				skb->len, PCI_DMA_TODEVICE);
 
 	if (pci_dma_mapping_error(priv->pdev, dma)) {
 		wiphy_debug(hw->wiphy,
 			    "failed to dma map skb, dropping TX frame.\n");
+		if (start_ba_session) {
+			spin_lock(&priv->stream_lock);
+			mwl8k_remove_stream(hw, stream);
+			spin_unlock(&priv->stream_lock);
+		}
 		dev_kfree_skb(skb);
 		return;
 	}
@@ -1641,12 +1964,34 @@
 
 	txq = priv->txq + index;
 
+	/* Mgmt frames that go out frequently are probe
+	 * responses. Other mgmt frames got out relatively
+	 * infrequently. Hence reserve 2 buffers so that
+	 * other mgmt frames do not get dropped due to an
+	 * already queued probe response in one of the
+	 * reserved buffers.
+	 */
+
+	if (txq->len >= MWL8K_TX_DESCS - 2) {
+		if (mgmtframe == false ||
+			txq->len == MWL8K_TX_DESCS) {
+			if (start_ba_session) {
+				spin_lock(&priv->stream_lock);
+				mwl8k_remove_stream(hw, stream);
+				spin_unlock(&priv->stream_lock);
+			}
+			spin_unlock_bh(&priv->tx_lock);
+			dev_kfree_skb(skb);
+			return;
+		}
+	}
+
 	BUG_ON(txq->skb[txq->tail] != NULL);
 	txq->skb[txq->tail] = skb;
 
 	tx = txq->txd + txq->tail;
 	tx->data_rate = txdatarate;
-	tx->tx_priority = index;
+	tx->tx_priority = txpriority;
 	tx->qos_control = cpu_to_le16(qos);
 	tx->pkt_phys_addr = cpu_to_le32(dma);
 	tx->pkt_len = cpu_to_le16(skb->len);
@@ -1655,6 +2000,11 @@
 		tx->peer_id = MWL8K_STA(tx_info->control.sta)->peer_id;
 	else
 		tx->peer_id = 0;
+
+	if (priv->ap_fw)
+		tx->timestamp = cpu_to_le32(ioread32(priv->regs +
+						MWL8K_HW_TIMER_REGISTER));
+
 	wmb();
 	tx->status = cpu_to_le32(MWL8K_TXD_STATUS_FW_OWNED | txstatus);
 
@@ -1665,12 +2015,17 @@
 	if (txq->tail == MWL8K_TX_DESCS)
 		txq->tail = 0;
 
-	if (txq->head == txq->tail)
-		ieee80211_stop_queue(hw, index);
-
 	mwl8k_tx_start(priv);
 
 	spin_unlock_bh(&priv->tx_lock);
+
+	/* Initiate the ampdu session here */
+	if (start_ba_session) {
+		spin_lock(&priv->stream_lock);
+		if (mwl8k_start_stream(hw, stream))
+			mwl8k_remove_stream(hw, stream);
+		spin_unlock(&priv->stream_lock);
+	}
 }
 
 
@@ -1868,7 +2223,7 @@
 	__u8 mcs_bitmap[16];
 	__le32 rx_queue_ptr;
 	__le32 num_tx_queues;
-	__le32 tx_queue_ptrs[MWL8K_TX_QUEUES];
+	__le32 tx_queue_ptrs[MWL8K_TX_WMM_QUEUES];
 	__le32 caps2;
 	__le32 num_tx_desc_per_queue;
 	__le32 total_rxd;
@@ -1974,8 +2329,8 @@
 	memset(cmd->perm_addr, 0xff, sizeof(cmd->perm_addr));
 	cmd->ps_cookie = cpu_to_le32(priv->cookie_dma);
 	cmd->rx_queue_ptr = cpu_to_le32(priv->rxq[0].rxd_dma);
-	cmd->num_tx_queues = cpu_to_le32(MWL8K_TX_QUEUES);
-	for (i = 0; i < MWL8K_TX_QUEUES; i++)
+	cmd->num_tx_queues = cpu_to_le32(mwl8k_tx_queues(priv));
+	for (i = 0; i < mwl8k_tx_queues(priv); i++)
 		cmd->tx_queue_ptrs[i] = cpu_to_le32(priv->txq[i].txd_dma);
 	cmd->num_tx_desc_per_queue = cpu_to_le32(MWL8K_TX_DESCS);
 	cmd->total_rxd = cpu_to_le32(MWL8K_RX_DESCS);
@@ -2017,13 +2372,16 @@
 	__le32 wcbbase2;
 	__le32 wcbbase3;
 	__le32 fw_api_version;
+	__le32 caps;
+	__le32 num_of_ampdu_queues;
+	__le32 wcbbase_ampdu[MWL8K_MAX_AMPDU_QUEUES];
 } __packed;
 
 static int mwl8k_cmd_get_hw_spec_ap(struct ieee80211_hw *hw)
 {
 	struct mwl8k_priv *priv = hw->priv;
 	struct mwl8k_cmd_get_hw_spec_ap *cmd;
-	int rc;
+	int rc, i;
 	u32 api_version;
 
 	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
@@ -2055,27 +2413,31 @@
 		priv->num_mcaddrs = le16_to_cpu(cmd->num_mcaddrs);
 		priv->fw_rev = le32_to_cpu(cmd->fw_rev);
 		priv->hw_rev = cmd->hw_rev;
-		mwl8k_setup_2ghz_band(hw);
+		mwl8k_set_caps(hw, le32_to_cpu(cmd->caps));
 		priv->ap_macids_supported = 0x000000ff;
 		priv->sta_macids_supported = 0x00000000;
-
-		off = le32_to_cpu(cmd->wcbbase0) & 0xffff;
-		iowrite32(priv->txq[0].txd_dma, priv->sram + off);
-
+		priv->num_ampdu_queues = le32_to_cpu(cmd->num_of_ampdu_queues);
+		if (priv->num_ampdu_queues > MWL8K_MAX_AMPDU_QUEUES) {
+			wiphy_warn(hw->wiphy, "fw reported %d ampdu queues"
+				   " but we only support %d.\n",
+				   priv->num_ampdu_queues,
+				   MWL8K_MAX_AMPDU_QUEUES);
+			priv->num_ampdu_queues = MWL8K_MAX_AMPDU_QUEUES;
+		}
 		off = le32_to_cpu(cmd->rxwrptr) & 0xffff;
 		iowrite32(priv->rxq[0].rxd_dma, priv->sram + off);
 
 		off = le32_to_cpu(cmd->rxrdptr) & 0xffff;
 		iowrite32(priv->rxq[0].rxd_dma, priv->sram + off);
 
-		off = le32_to_cpu(cmd->wcbbase1) & 0xffff;
-		iowrite32(priv->txq[1].txd_dma, priv->sram + off);
-
-		off = le32_to_cpu(cmd->wcbbase2) & 0xffff;
-		iowrite32(priv->txq[2].txd_dma, priv->sram + off);
-
-		off = le32_to_cpu(cmd->wcbbase3) & 0xffff;
-		iowrite32(priv->txq[3].txd_dma, priv->sram + off);
+		priv->txq_offset[0] = le32_to_cpu(cmd->wcbbase0) & 0xffff;
+		priv->txq_offset[1] = le32_to_cpu(cmd->wcbbase1) & 0xffff;
+		priv->txq_offset[2] = le32_to_cpu(cmd->wcbbase2) & 0xffff;
+		priv->txq_offset[3] = le32_to_cpu(cmd->wcbbase3) & 0xffff;
+
+		for (i = 0; i < priv->num_ampdu_queues; i++)
+			priv->txq_offset[i + MWL8K_TX_WMM_QUEUES] =
+				le32_to_cpu(cmd->wcbbase_ampdu[i]) & 0xffff;
 	}
 
 done:
@@ -2098,12 +2460,21 @@
 	__le32 caps;
 	__le32 rx_queue_ptr;
 	__le32 num_tx_queues;
-	__le32 tx_queue_ptrs[MWL8K_TX_QUEUES];
+	__le32 tx_queue_ptrs[MWL8K_MAX_TX_QUEUES];
 	__le32 flags;
 	__le32 num_tx_desc_per_queue;
 	__le32 total_rxd;
 } __packed;
 
+/* If enabled, MWL8K_SET_HW_SPEC_FLAG_ENABLE_LIFE_TIME_EXPIRY will cause
+ * packets to expire 500 ms after the timestamp in the tx descriptor.  That is,
+ * the packets that are queued for more than 500ms, will be dropped in the
+ * hardware. This helps minimizing the issues caused due to head-of-line
+ * blocking where a slow client can hog the bandwidth and affect traffic to a
+ * faster client.
+ */
+#define MWL8K_SET_HW_SPEC_FLAG_ENABLE_LIFE_TIME_EXPIRY	0x00000400
+#define MWL8K_SET_HW_SPEC_FLAG_GENERATE_CCMP_HDR	0x00000200
 #define MWL8K_SET_HW_SPEC_FLAG_HOST_DECR_MGMT		0x00000080
 #define MWL8K_SET_HW_SPEC_FLAG_HOSTFORM_PROBERESP	0x00000020
 #define MWL8K_SET_HW_SPEC_FLAG_HOSTFORM_BEACON		0x00000010
@@ -2124,7 +2495,7 @@
 
 	cmd->ps_cookie = cpu_to_le32(priv->cookie_dma);
 	cmd->rx_queue_ptr = cpu_to_le32(priv->rxq[0].rxd_dma);
-	cmd->num_tx_queues = cpu_to_le32(MWL8K_TX_QUEUES);
+	cmd->num_tx_queues = cpu_to_le32(mwl8k_tx_queues(priv));
 
 	/*
 	 * Mac80211 stack has Q0 as highest priority and Q3 as lowest in
@@ -2132,14 +2503,16 @@
 	 * in that order. Map Q3 of mac80211 to Q0 of firmware so that the
 	 * priority is interpreted the right way in firmware.
 	 */
-	for (i = 0; i < MWL8K_TX_QUEUES; i++) {
-		int j = MWL8K_TX_QUEUES - 1 - i;
+	for (i = 0; i < mwl8k_tx_queues(priv); i++) {
+		int j = mwl8k_tx_queues(priv) - 1 - i;
 		cmd->tx_queue_ptrs[i] = cpu_to_le32(priv->txq[j].txd_dma);
 	}
 
 	cmd->flags = cpu_to_le32(MWL8K_SET_HW_SPEC_FLAG_HOST_DECR_MGMT |
 				 MWL8K_SET_HW_SPEC_FLAG_HOSTFORM_PROBERESP |
-				 MWL8K_SET_HW_SPEC_FLAG_HOSTFORM_BEACON);
+				 MWL8K_SET_HW_SPEC_FLAG_HOSTFORM_BEACON |
+				 MWL8K_SET_HW_SPEC_FLAG_ENABLE_LIFE_TIME_EXPIRY |
+				 MWL8K_SET_HW_SPEC_FLAG_GENERATE_CCMP_HDR);
 	cmd->num_tx_desc_per_queue = cpu_to_le32(MWL8K_TX_DESCS);
 	cmd->total_rxd = cpu_to_le32(MWL8K_RX_DESCS);
 
@@ -2356,7 +2729,7 @@
 	__le16 bw;
 	__le16 sub_ch;
 	__le16 power_level_list[MWL8K_TX_POWER_LEVEL_TOTAL];
-} __attribute__((packed));
+} __packed;
 
 static int mwl8k_cmd_tx_power(struct ieee80211_hw *hw,
 				     struct ieee80211_conf *conf,
@@ -3123,6 +3496,65 @@
 }
 
 /*
+ * CMD_GET_WATCHDOG_BITMAP.
+ */
+struct mwl8k_cmd_get_watchdog_bitmap {
+	struct mwl8k_cmd_pkt header;
+	u8	bitmap;
+} __packed;
+
+static int mwl8k_cmd_get_watchdog_bitmap(struct ieee80211_hw *hw, u8 *bitmap)
+{
+	struct mwl8k_cmd_get_watchdog_bitmap *cmd;
+	int rc;
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (cmd == NULL)
+		return -ENOMEM;
+
+	cmd->header.code = cpu_to_le16(MWL8K_CMD_GET_WATCHDOG_BITMAP);
+	cmd->header.length = cpu_to_le16(sizeof(*cmd));
+
+	rc = mwl8k_post_cmd(hw, &cmd->header);
+	if (!rc)
+		*bitmap = cmd->bitmap;
+
+	kfree(cmd);
+
+	return rc;
+}
+
+#define INVALID_BA	0xAA
+static void mwl8k_watchdog_ba_events(struct work_struct *work)
+{
+	int rc;
+	u8 bitmap = 0, stream_index;
+	struct mwl8k_ampdu_stream *streams;
+	struct mwl8k_priv *priv =
+		container_of(work, struct mwl8k_priv, watchdog_ba_handle);
+
+	rc = mwl8k_cmd_get_watchdog_bitmap(priv->hw, &bitmap);
+	if (rc)
+		return;
+
+	if (bitmap == INVALID_BA)
+		return;
+
+	/* the bitmap is the hw queue number.  Map it to the ampdu queue. */
+	stream_index = bitmap - MWL8K_TX_WMM_QUEUES;
+
+	BUG_ON(stream_index >= priv->num_ampdu_queues);
+
+	streams = &priv->ampdu[stream_index];
+
+	if (streams->state == AMPDU_STREAM_ACTIVE)
+		ieee80211_stop_tx_ba_session(streams->sta, streams->tid);
+
+	return;
+}
+
+
+/*
  * CMD_BSS_START.
  */
 struct mwl8k_cmd_bss_start {
@@ -3151,6 +3583,152 @@
 }
 
 /*
+ * CMD_BASTREAM.
+ */
+
+/*
+ * UPSTREAM is tx direction
+ */
+#define BASTREAM_FLAG_DIRECTION_UPSTREAM	0x00
+#define BASTREAM_FLAG_IMMEDIATE_TYPE		0x01
+
+enum ba_stream_action_type {
+	MWL8K_BA_CREATE,
+	MWL8K_BA_UPDATE,
+	MWL8K_BA_DESTROY,
+	MWL8K_BA_FLUSH,
+	MWL8K_BA_CHECK,
+};
+
+
+struct mwl8k_create_ba_stream {
+	__le32	flags;
+	__le32	idle_thrs;
+	__le32	bar_thrs;
+	__le32	window_size;
+	u8	peer_mac_addr[6];
+	u8	dialog_token;
+	u8	tid;
+	u8	queue_id;
+	u8	param_info;
+	__le32	ba_context;
+	u8	reset_seq_no_flag;
+	__le16	curr_seq_no;
+	u8	sta_src_mac_addr[6];
+} __packed;
+
+struct mwl8k_destroy_ba_stream {
+	__le32	flags;
+	__le32	ba_context;
+} __packed;
+
+struct mwl8k_cmd_bastream {
+	struct mwl8k_cmd_pkt	header;
+	__le32	action;
+	union {
+		struct mwl8k_create_ba_stream	create_params;
+		struct mwl8k_destroy_ba_stream	destroy_params;
+	};
+} __packed;
+
+static int
+mwl8k_check_ba(struct ieee80211_hw *hw, struct mwl8k_ampdu_stream *stream)
+{
+	struct mwl8k_cmd_bastream *cmd;
+	int rc;
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (cmd == NULL)
+		return -ENOMEM;
+
+	cmd->header.code = cpu_to_le16(MWL8K_CMD_BASTREAM);
+	cmd->header.length = cpu_to_le16(sizeof(*cmd));
+
+	cmd->action = cpu_to_le32(MWL8K_BA_CHECK);
+
+	cmd->create_params.queue_id = stream->idx;
+	memcpy(&cmd->create_params.peer_mac_addr[0], stream->sta->addr,
+	       ETH_ALEN);
+	cmd->create_params.tid = stream->tid;
+
+	cmd->create_params.flags =
+		cpu_to_le32(BASTREAM_FLAG_IMMEDIATE_TYPE) |
+		cpu_to_le32(BASTREAM_FLAG_DIRECTION_UPSTREAM);
+
+	rc = mwl8k_post_cmd(hw, &cmd->header);
+
+	kfree(cmd);
+
+	return rc;
+}
+
+static int
+mwl8k_create_ba(struct ieee80211_hw *hw, struct mwl8k_ampdu_stream *stream,
+		u8 buf_size)
+{
+	struct mwl8k_cmd_bastream *cmd;
+	int rc;
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (cmd == NULL)
+		return -ENOMEM;
+
+
+	cmd->header.code = cpu_to_le16(MWL8K_CMD_BASTREAM);
+	cmd->header.length = cpu_to_le16(sizeof(*cmd));
+
+	cmd->action = cpu_to_le32(MWL8K_BA_CREATE);
+
+	cmd->create_params.bar_thrs = cpu_to_le32((u32)buf_size);
+	cmd->create_params.window_size = cpu_to_le32((u32)buf_size);
+	cmd->create_params.queue_id = stream->idx;
+
+	memcpy(cmd->create_params.peer_mac_addr, stream->sta->addr, ETH_ALEN);
+	cmd->create_params.tid = stream->tid;
+	cmd->create_params.curr_seq_no = cpu_to_le16(0);
+	cmd->create_params.reset_seq_no_flag = 1;
+
+	cmd->create_params.param_info =
+		(stream->sta->ht_cap.ampdu_factor &
+		 IEEE80211_HT_AMPDU_PARM_FACTOR) |
+		((stream->sta->ht_cap.ampdu_density << 2) &
+		 IEEE80211_HT_AMPDU_PARM_DENSITY);
+
+	cmd->create_params.flags =
+		cpu_to_le32(BASTREAM_FLAG_IMMEDIATE_TYPE |
+					BASTREAM_FLAG_DIRECTION_UPSTREAM);
+
+	rc = mwl8k_post_cmd(hw, &cmd->header);
+
+	wiphy_debug(hw->wiphy, "Created a BA stream for %pM : tid %d\n",
+		stream->sta->addr, stream->tid);
+	kfree(cmd);
+
+	return rc;
+}
+
+static void mwl8k_destroy_ba(struct ieee80211_hw *hw,
+			     struct mwl8k_ampdu_stream *stream)
+{
+	struct mwl8k_cmd_bastream *cmd;
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (cmd == NULL)
+		return;
+
+	cmd->header.code = cpu_to_le16(MWL8K_CMD_BASTREAM);
+	cmd->header.length = cpu_to_le16(sizeof(*cmd));
+	cmd->action = cpu_to_le32(MWL8K_BA_DESTROY);
+
+	cmd->destroy_params.ba_context = cpu_to_le32(stream->idx);
+	mwl8k_post_cmd(hw, &cmd->header);
+
+	wiphy_debug(hw->wiphy, "Deleted BA stream index %d\n", stream->idx);
+
+	kfree(cmd);
+}
+
+/*
  * CMD_SET_NEW_STN.
  */
 struct mwl8k_cmd_set_new_stn {
@@ -3274,7 +3852,7 @@
 	__u8 mac_addr[6];
 	__u8 encr_type;
 
-} __attribute__((packed));
+} __packed;
 
 struct mwl8k_cmd_set_key {
 	struct mwl8k_cmd_pkt header;
@@ -3294,7 +3872,7 @@
 	__le16 tkip_tsc_low;
 	__le32 tkip_tsc_high;
 	__u8 mac_addr[6];
-} __attribute__((packed));
+} __packed;
 
 enum {
 	MWL8K_ENCR_ENABLE,
@@ -3422,7 +4000,7 @@
 			mwl8k_vif->wep_key_conf[idx].enabled = 1;
 		}
 
-		keymlen = 0;
+		keymlen = key->keylen;
 		action = MWL8K_ENCR_SET_KEY;
 		break;
 	case WLAN_CIPHER_SUITE_TKIP:
@@ -3496,7 +4074,6 @@
 		addr = sta->addr;
 
 	if (cmd_param == SET_KEY) {
-		key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
 		rc = mwl8k_cmd_encryption_set_key(hw, vif, addr, key);
 		if (rc)
 			goto out;
@@ -3520,7 +4097,7 @@
 		if (rc)
 			goto out;
 
-		mwl8k_vif->is_hw_crypto_enabled = false;
+//		mwl8k_vif->is_hw_crypto_enabled = false;
 
 	}
 out:
@@ -3671,6 +4248,11 @@
 		tasklet_schedule(&priv->poll_rx_task);
 	}
 
+	if (status & MWL8K_A2H_INT_BA_WATCHDOG) {
+		status &= ~MWL8K_A2H_INT_BA_WATCHDOG;
+		ieee80211_queue_work(hw, &priv->watchdog_ba_handle);
+	}
+
 	if (status)
 		iowrite32(~status, priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS);
 
@@ -3699,7 +4281,7 @@
 
 	spin_lock_bh(&priv->tx_lock);
 
-	for (i = 0; i < MWL8K_TX_QUEUES; i++)
+	for (i = 0; i < mwl8k_tx_queues(priv); i++)
 		limit -= mwl8k_txq_reclaim(hw, i, limit, 0);
 
 	if (!priv->pending_tx_pkts && priv->tx_wait != NULL) {
@@ -3774,6 +4356,8 @@
 
 	/* Enable interrupts */
 	iowrite32(MWL8K_A2H_EVENTS, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);
+	iowrite32(MWL8K_A2H_EVENTS,
+		  priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK);
 
 	rc = mwl8k_fw_lock(hw);
 	if (!rc) {
@@ -3829,6 +4413,7 @@
 
 	/* Stop finalize join worker */
 	cancel_work_sync(&priv->finalize_join_worker);
+	cancel_work_sync(&priv->watchdog_ba_handle);
 	if (priv->beacon_skb != NULL)
 		dev_kfree_skb(priv->beacon_skb);
 
@@ -3837,7 +4422,7 @@
 	tasklet_disable(&priv->poll_rx_task);
 
 	/* Return all skbs to mac80211 */
-	for (i = 0; i < MWL8K_TX_QUEUES; i++)
+	for (i = 0; i < mwl8k_tx_queues(priv); i++)
 		mwl8k_txq_reclaim(hw, i, INT_MAX, 1);
 }
 
@@ -3958,9 +4543,12 @@
 		conf->power_level = 18;
 
 	if (priv->ap_fw) {
+
+		if (conf->flags & IEEE80211_CONF_CHANGE_POWER) {
 		rc = mwl8k_cmd_tx_power(hw, conf, conf->power_level);
 		if (rc)
 			goto out;
+		}
 
 		rc = mwl8k_cmd_rf_antenna(hw, MWL8K_RF_ANTENNA_RX, 0x3);
 		if (rc)
@@ -3987,7 +4575,7 @@
 			   struct ieee80211_bss_conf *info, u32 changed)
 {
 	struct mwl8k_priv *priv = hw->priv;
-	u32 ap_legacy_rates;
+	u32 ap_legacy_rates = 0;
 	u8 ap_mcs_rates[16];
 	int rc;
 
@@ -4291,9 +4879,13 @@
 			    struct ieee80211_sta *sta)
 {
 	struct mwl8k_priv *priv = hw->priv;
+	int rc;
 
-	if (priv->ap_fw)
-		return mwl8k_cmd_set_new_stn_del(hw, vif, sta->addr);
+	if (priv->ap_fw) {
+		rc = mwl8k_cmd_set_new_stn_del(hw, vif, sta->addr);
+		printk(KERN_DEBUG "sta_remove: Vif addr %pM : sta addr %pM with error %d\n", vif->addr, sta->addr, rc);
+		return rc;
+	}
 	else
 		return mwl8k_cmd_update_stadb_del(hw, vif, sta->addr);
 }
@@ -4312,11 +4904,14 @@
 		ret = mwl8k_cmd_update_stadb_add(hw, vif, sta);
 		if (ret >= 0) {
 			MWL8K_STA(sta)->peer_id = ret;
+			if (sta->ht_cap.ht_supported)
+				MWL8K_STA(sta)->is_ampdu_allowed = true;
 			ret = 0;
 		}
 
 	} else {
 		ret = mwl8k_cmd_set_new_stn_add(hw, vif, sta);
+		printk(KERN_DEBUG "sta_add: Vif addr %pM : sta addr %pM with error %d\n", vif->addr, sta->addr, ret);
 	}
 
 	for (i = 0; i < NUM_WEP_KEYS; i++) {
@@ -4335,14 +4930,14 @@
 
 	rc = mwl8k_fw_lock(hw);
 	if (!rc) {
-		BUG_ON(queue > MWL8K_TX_QUEUES - 1);
+		BUG_ON(queue > MWL8K_TX_WMM_QUEUES - 1);
 		memcpy(&priv->wmm_params[queue], params, sizeof(*params));
 
 		if (!priv->wmm_enabled)
 			rc = mwl8k_cmd_set_wmm_mode(hw, 1);
 
 		if (!rc) {
-			int q = MWL8K_TX_QUEUES - 1 - queue;
+			int q = MWL8K_TX_WMM_QUEUES - 1 - queue;
 			rc = mwl8k_cmd_set_edca_params(hw, q,
 						       params->cw_min,
 						       params->cw_max,
@@ -4378,21 +4973,118 @@
 	return 0;
 }
 
+#define MAX_AMPDU_ATTEMPTS 5
+
 static int
 mwl8k_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		   enum ieee80211_ampdu_mlme_action action,
 		   struct ieee80211_sta *sta, u16 tid, u16 *ssn,
 		   u8 buf_size)
 {
+
+	int i, rc = 0;
+	struct mwl8k_priv *priv = hw->priv;
+	struct mwl8k_ampdu_stream *stream;
+	u8 *addr = sta->addr;
+
+	if (!(hw->flags & IEEE80211_HW_AMPDU_AGGREGATION))
+		return -ENOTSUPP;
+
+	spin_lock(&priv->stream_lock);
+	stream = mwl8k_lookup_stream(hw, addr, tid);
+
 	switch (action) {
 	case IEEE80211_AMPDU_RX_START:
 	case IEEE80211_AMPDU_RX_STOP:
-		if (!(hw->flags & IEEE80211_HW_AMPDU_AGGREGATION))
-			return -ENOTSUPP;
-		return 0;
+		break;
+	case IEEE80211_AMPDU_TX_START:
+		/* By the time we get here the hw queues may contain outgoing
+		 * packets for this RA/TID that are not part of this BA
+		 * session.  The hw will assign sequence numbers to these
+		 * packets as they go out.  So if we query the hw for its next
+		 * sequence number and use that for the SSN here, it may end up
+		 * being wrong, which will lead to sequence number mismatch at
+		 * the recipient.  To avoid this, we reset the sequence number
+		 * to O for the first MPDU in this BA stream.
+		 */
+		*ssn = 0;
+		if (stream == NULL) {
+			/* This means that somebody outside this driver called
+			 * ieee80211_start_tx_ba_session.  This is unexpected
+			 * because we do our own rate control.  Just warn and
+			 * move on.
+			 */
+			wiphy_warn(hw->wiphy, "Unexpected call to %s.  "
+				   "Proceeding anyway.\n", __func__);
+			stream = mwl8k_add_stream(hw, sta, tid);
+		}
+		if (stream == NULL) {
+			wiphy_debug(hw->wiphy, "no free AMPDU streams\n");
+			rc = -EBUSY;
+			break;
+		}
+		stream->state = AMPDU_STREAM_IN_PROGRESS;
+
+		/* Release the lock before we do the time consuming stuff */
+		spin_unlock(&priv->stream_lock);
+		for (i = 0; i < MAX_AMPDU_ATTEMPTS; i++) {
+			rc = mwl8k_check_ba(hw, stream);
+
+			if (!rc)
+				break;
+			/*
+			 * HW queues take time to be flushed, give them
+			 * sufficient time
+			 */
+
+			msleep(1000);
+		}
+		spin_lock(&priv->stream_lock);
+		if (rc) {
+			wiphy_err(hw->wiphy, "Stream for tid %d busy after %d"
+				" attempts\n", tid, MAX_AMPDU_ATTEMPTS);
+			mwl8k_remove_stream(hw, stream);
+			rc = -EBUSY;
+			break;
+		}
+		ieee80211_start_tx_ba_cb_irqsafe(vif, addr, tid);
+		break;
+	case IEEE80211_AMPDU_TX_STOP:
+		if (stream == NULL)
+			break;
+		if (stream->state == AMPDU_STREAM_ACTIVE) {
+			spin_unlock(&priv->stream_lock);
+			mwl8k_destroy_ba(hw, stream);
+			spin_lock(&priv->stream_lock);
+		}
+		mwl8k_remove_stream(hw, stream);
+		ieee80211_stop_tx_ba_cb_irqsafe(vif, addr, tid);
+		break;
+	case IEEE80211_AMPDU_TX_OPERATIONAL:
+		BUG_ON(stream == NULL);
+		BUG_ON(stream->state != AMPDU_STREAM_IN_PROGRESS);
+		spin_unlock(&priv->stream_lock);
+		rc = mwl8k_create_ba(hw, stream, buf_size);
+		spin_lock(&priv->stream_lock);
+		if (!rc)
+			stream->state = AMPDU_STREAM_ACTIVE;
+		else {
+			spin_unlock(&priv->stream_lock);
+			mwl8k_destroy_ba(hw, stream);
+			spin_lock(&priv->stream_lock);
+			wiphy_debug(hw->wiphy,
+				"Failed adding stream for sta %pM tid %d\n",
+				addr, tid);
+			mwl8k_remove_stream(hw, stream);
+		}
+		break;
+
 	default:
-		return -ENOTSUPP;
+		rc = -ENOTSUPP;
 	}
+
+	spin_unlock(&priv->stream_lock);
+	return rc;
 }
 
 static const struct ieee80211_ops mwl8k_ops = {
@@ -4441,7 +5133,7 @@
 	MWL8366,
 };
 
-#define MWL8K_8366_AP_FW_API 1
+#define MWL8K_8366_AP_FW_API 2
 #define _MWL8K_8366_AP_FW(api) "mwl8k/fmimage_8366_ap-" #api ".fw"
 #define MWL8K_8366_AP_FW(api) _MWL8K_8366_AP_FW(api)
 
@@ -4607,6 +5299,23 @@
 	return rc;
 }
 
+static int mwl8k_init_txqs(struct ieee80211_hw *hw)
+{
+	struct mwl8k_priv *priv = hw->priv;
+	int rc = 0;
+	int i;
+
+	for (i = 0; i < mwl8k_tx_queues(priv); i++) {
+		rc = mwl8k_txq_init(hw, i);
+		if (rc)
+			break;
+		if (priv->ap_fw)
+			iowrite32(priv->txq[i].txd_dma,
+				  priv->sram + priv->txq_offset[i]);
+	}
+	return rc;
+}
+
 /* initialize hw after successfully loading a firmware image */
 static int mwl8k_probe_hw(struct ieee80211_hw *hw)
 {
@@ -4634,17 +5343,26 @@
 		goto err_stop_firmware;
 	rxq_refill(hw, 0, INT_MAX);
 
-	for (i = 0; i < MWL8K_TX_QUEUES; i++) {
-		rc = mwl8k_txq_init(hw, i);
+	/* For the sta firmware, we need to know the dma addresses of tx queues
+	 * before sending MWL8K_CMD_GET_HW_SPEC.  So we must initialize them
+	 * prior to issuing this command.  But for the AP case, we learn the
+	 * total number of queues from the result CMD_GET_HW_SPEC, so for this
+	 * case we must initialize the tx queues after.
+	 */
+	priv->num_ampdu_queues = 0;
+	if (!priv->ap_fw) {
+		rc = mwl8k_init_txqs(hw);
 		if (rc)
 			goto err_free_queues;
 	}
 
 	iowrite32(0, priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS);
 	iowrite32(0, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);
-	iowrite32(MWL8K_A2H_INT_TX_DONE | MWL8K_A2H_INT_RX_READY,
+	iowrite32(MWL8K_A2H_INT_TX_DONE|MWL8K_A2H_INT_RX_READY|
+		  MWL8K_A2H_INT_BA_WATCHDOG,
 		  priv->regs + MWL8K_HIU_A2H_INTERRUPT_CLEAR_SEL);
-	iowrite32(0xffffffff, priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK);
+	iowrite32(MWL8K_A2H_INT_OPC_DONE,
+		  priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK);
 
 	rc = request_irq(priv->pdev->irq, mwl8k_interrupt,
 			 IRQF_SHARED, MWL8K_NAME, hw);
@@ -4653,6 +5371,8 @@
 		goto err_free_queues;
 	}
 
+	memset(priv->ampdu, 0, sizeof(priv->ampdu));
+
 	/*
 	 * Temporarily enable interrupts.  Initial firmware host
 	 * commands use interrupts and avoid polling.  Disable
@@ -4664,6 +5384,8 @@
 	if (priv->ap_fw) {
 		rc = mwl8k_cmd_get_hw_spec_ap(hw);
 		if (!rc)
+			rc = mwl8k_init_txqs(hw);
+		if (!rc)
 			rc = mwl8k_cmd_set_hw_spec(hw);
 	} else {
 		rc = mwl8k_cmd_get_hw_spec_sta(hw);
@@ -4705,7 +5427,7 @@
 	free_irq(priv->pdev->irq, hw);
 
 err_free_queues:
-	for (i = 0; i < MWL8K_TX_QUEUES; i++)
+	for (i = 0; i < mwl8k_tx_queues(priv); i++)
 		mwl8k_txq_deinit(hw, i);
 	mwl8k_rxq_deinit(hw, 0);
 
@@ -4727,7 +5449,7 @@
 	mwl8k_stop(hw);
 	mwl8k_rxq_deinit(hw, 0);
 
-	for (i = 0; i < MWL8K_TX_QUEUES; i++)
+	for (i = 0; i < mwl8k_tx_queues(priv); i++)
 		mwl8k_txq_deinit(hw, i);
 
 	rc = mwl8k_init_firmware(hw, fw_image, false);
@@ -4746,7 +5468,7 @@
 	if (rc)
 		goto fail;
 
-	for (i = 0; i < MWL8K_TX_QUEUES; i++) {
+	for (i = 0; i < MWL8K_TX_WMM_QUEUES; i++) {
 		rc = mwl8k_conf_tx(hw, i, &priv->wmm_params[i]);
 		if (rc)
 			goto fail;
@@ -4778,12 +5500,22 @@
 	hw->extra_tx_headroom =
 		sizeof(struct mwl8k_dma_data) - sizeof(struct ieee80211_cts);
 
+	hw->extra_tx_headroom -= priv->ap_fw ? REDUCED_TX_HEADROOM : 0;
+
 	hw->channel_change_time = 10;
 
-	hw->queues = MWL8K_TX_QUEUES;
+	hw->queues = MWL8K_TX_WMM_QUEUES;
 
 	/* Set rssi values to dBm */
 	hw->flags |= IEEE80211_HW_SIGNAL_DBM | IEEE80211_HW_HAS_RATE_CONTROL;
+
+	/*
+	 * Ask mac80211 to not to trigger PS mode
+	 * based on PM bit of incoming frames.
+	 */
+	if (priv->ap_fw)
+		hw->flags |= IEEE80211_HW_AP_LINK_PS;
+
 	hw->vif_data_size = sizeof(struct mwl8k_vif);
 	hw->sta_data_size = sizeof(struct mwl8k_sta);
 
@@ -4796,6 +5528,8 @@
 
 	/* Finalize join worker */
 	INIT_WORK(&priv->finalize_join_worker, mwl8k_finalize_join_worker);
+	/* Handle watchdog ba events */
+	INIT_WORK(&priv->watchdog_ba_handle, mwl8k_watchdog_ba_events);
 
 	/* TX reclaim and RX tasklets.  */
 	tasklet_init(&priv->poll_tx_task, mwl8k_tx_poll, (unsigned long)hw);
@@ -4815,6 +5549,8 @@
 
 	spin_lock_init(&priv->tx_lock);
 
+	spin_lock_init(&priv->stream_lock);
+
 	priv->tx_wait = NULL;
 
 	rc = mwl8k_probe_hw(hw);
@@ -4836,7 +5572,7 @@
 	return 0;
 
 err_unprobe_hw:
-	for (i = 0; i < MWL8K_TX_QUEUES; i++)
+	for (i = 0; i < mwl8k_tx_queues(priv); i++)
 		mwl8k_txq_deinit(hw, i);
 	mwl8k_rxq_deinit(hw, 0);
 
@@ -4995,10 +5731,10 @@
 	mwl8k_hw_reset(priv);
 
 	/* Return all skbs to mac80211 */
-	for (i = 0; i < MWL8K_TX_QUEUES; i++)
+	for (i = 0; i < mwl8k_tx_queues(priv); i++)
 		mwl8k_txq_reclaim(hw, i, INT_MAX, 1);
 
-	for (i = 0; i < MWL8K_TX_QUEUES; i++)
+	for (i = 0; i < mwl8k_tx_queues(priv); i++)
 		mwl8k_txq_deinit(hw, i);
 
 	mwl8k_rxq_deinit(hw, 0);
diff -ruw linux-2.6.39.4/drivers/platform/Kconfig linux-2.6.39.4-fbx/drivers/platform/Kconfig
--- linux-2.6.39.4/drivers/platform/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/platform/Kconfig	2011-06-15 18:56:43.185455429 +0200
@@ -1,3 +1,11 @@
 if X86
 source "drivers/platform/x86/Kconfig"
 endif
+
+if TANGO2
+source "drivers/platform/tango2/Kconfig"
+endif
+
+if X86_INTEL_CE
+source "drivers/platform/intelce/Kconfig"
+endif
diff -ruw linux-2.6.39.4/drivers/platform/Makefile linux-2.6.39.4-fbx/drivers/platform/Makefile
--- linux-2.6.39.4/drivers/platform/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/platform/Makefile	2011-06-15 18:56:43.185455429 +0200
@@ -3,3 +3,5 @@
 #
 
 obj-$(CONFIG_X86)		+= x86/
+obj-$(CONFIG_TANGO2)		+= tango2/
+obj-$(CONFIG_X86_INTEL_CE)	+= intelce/
diff -ruw linux-2.6.39.4/drivers/spi/Kconfig linux-2.6.39.4-fbx/drivers/spi/Kconfig
--- linux-2.6.39.4/drivers/spi/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/spi/Kconfig	2011-06-15 18:56:43.425456103 +0200
@@ -289,6 +289,12 @@
 	help
 	  This selects a driver for the PPC4xx SPI Controller.
 
+config SPI_TDM_ORION
+	tristate "Orion TDM SPI master"
+	depends on PLAT_ORION
+	help
+	  This enables using the TDM SPI master controller on the Orion chips.
+
 config SPI_PXA2XX
 	tristate "PXA2xx SSP SPI master"
 	depends on (ARCH_PXA || (X86_32 && PCI)) && EXPERIMENTAL
diff -ruw linux-2.6.39.4/drivers/spi/Makefile linux-2.6.39.4-fbx/drivers/spi/Makefile
--- linux-2.6.39.4/drivers/spi/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/spi/Makefile	2011-06-15 18:56:43.425456103 +0200
@@ -35,6 +35,7 @@
 obj-$(CONFIG_SPI_ORION)			+= orion_spi.o
 obj-$(CONFIG_SPI_PL022)			+= amba-pl022.o
 obj-$(CONFIG_SPI_MPC512x_PSC)		+= mpc512x_psc_spi.o
+obj-$(CONFIG_SPI_TDM_ORION)		+= orion_tdm_spi.o
 obj-$(CONFIG_SPI_MPC52xx_PSC)		+= mpc52xx_psc_spi.o
 obj-$(CONFIG_SPI_MPC52xx)		+= mpc52xx_spi.o
 obj-$(CONFIG_SPI_FSL_LIB)		+= spi_fsl_lib.o
diff -ruw linux-2.6.39.4/drivers/tty/serial/8250.c linux-2.6.39.4-fbx/drivers/tty/serial/8250.c
--- linux-2.6.39.4/drivers/tty/serial/8250.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/tty/serial/8250.c	2011-06-15 18:56:43.975457646 +0200
@@ -46,6 +46,12 @@
 
 #include "8250.h"
 
+#ifdef CONFIG_TANGO2
+#include <asm/mach-tango2/tango2_gbus.h>
+
+extern unsigned long em8xxx_sys_frequency;
+#endif
+
 #ifdef CONFIG_SPARC
 #include "suncore.h"
 #endif
@@ -403,14 +409,45 @@
 
 static unsigned int mem_serial_in(struct uart_port *p, int offset)
 {
+
+#ifdef CONFIG_TANGO2
+	unsigned long v;
+
+	/* no EFR on tango2 */
+	if (offset == UART_EFR)
+		v = 0;
+	else
+		v = gbus_readl((unsigned long)p->membase +
+			       (offset << p->regshift));
+	return v;
+#else
 	offset = map_8250_in_reg(p, offset) << p->regshift;
 	return readb(p->membase + offset);
+#endif
 }
 
 static void mem_serial_out(struct uart_port *p, int offset, int value)
 {
+#ifdef CONFIG_TANGO2
+	/*
+	 * we add a special case for UART_DL register, since
+	 * register content has a different meaning for us.
+	 */
+	if (offset == UART_DL) {
+		/* select right clock source */
+		value = (em8xxx_sys_frequency / p->uartclk);
+	}
+
+	/* no EFR on tango2 */
+	if (offset != UART_EFR) {
+		offset = offset << p->regshift;
+		gbus_writel((unsigned long)p->membase + offset,
+			    value);
+	}
+#else
 	offset = map_8250_out_reg(p, offset) << p->regshift;
 	writeb(value, p->membase + offset);
+#endif
 }
 
 static void mem32_serial_out(struct uart_port *p, int offset, int value)
@@ -584,6 +621,7 @@
 #define serial_inp(up, offset)		serial_in(up, offset)
 #define serial_outp(up, offset, value)	serial_out(up, offset, value)
 
+#ifndef CONFIG_TANGO2
 /* Uart divisor latch read */
 static inline int _serial_dl_read(struct uart_8250_port *up)
 {
@@ -636,6 +674,7 @@
 #define serial_dl_read(up) _serial_dl_read(up)
 #define serial_dl_write(up, value) _serial_dl_write(up, value)
 #endif
+#endif
 
 /*
  * For the 16C950
@@ -769,7 +808,11 @@
 static int size_fifo(struct uart_8250_port *up)
 {
 	unsigned char old_fcr, old_mcr, old_lcr;
+#ifdef CONFIG_TANGO2
+	unsigned short old_dll, old_dlm;
+#else
 	unsigned short old_dl;
+#endif
 	int count;
 
 	old_lcr = serial_inp(up, UART_LCR);
@@ -780,8 +823,14 @@
 		    UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
 	serial_outp(up, UART_MCR, UART_MCR_LOOP);
 	serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_A);
+#ifdef CONFIG_TANGO2
+	old_dll = serial_inp(up, UART_DL) & 0xff;
+	old_dlm = serial_inp(up, UART_DL) >> 8;
+	serial_outp(up, UART_DL, 0x01);
+#else
 	old_dl = serial_dl_read(up);
 	serial_dl_write(up, 0x0001);
+#endif
 	serial_outp(up, UART_LCR, 0x03);
 	for (count = 0; count < 256; count++)
 		serial_outp(up, UART_TX, count);
@@ -792,7 +841,11 @@
 	serial_outp(up, UART_FCR, old_fcr);
 	serial_outp(up, UART_MCR, old_mcr);
 	serial_outp(up, UART_LCR, UART_LCR_CONF_MODE_A);
+#ifdef CONFIG_TANGO2
+	serial_outp(up, UART_DL, (old_dlm << 8) | old_dll);
+#else
 	serial_dl_write(up, old_dl);
+#endif
 	serial_outp(up, UART_LCR, old_lcr);
 
 	return count;
@@ -811,6 +864,16 @@
 	old_lcr = serial_inp(p, UART_LCR);
 	serial_outp(p, UART_LCR, UART_LCR_CONF_MODE_A);
 
+#ifdef CONFIG_TANGO2
+	old_dll = serial_inp(p, UART_DL) & 0xff;
+	old_dlm = serial_inp(p, UART_DL) >> 8;
+
+	serial_outp(p, UART_DL, 0);
+
+	id = serial_inp(p, UART_DL);
+
+	serial_outp(p, UART_DL, (old_dlm << 8) | old_dll);
+#else
 	old_dll = serial_inp(p, UART_DLL);
 	old_dlm = serial_inp(p, UART_DLM);
 
@@ -821,6 +884,7 @@
 
 	serial_outp(p, UART_DLL, old_dll);
 	serial_outp(p, UART_DLM, old_dlm);
+#endif
 	serial_outp(p, UART_LCR, old_lcr);
 
 	return id;
@@ -1039,11 +1103,20 @@
 
 			serial_outp(up, UART_LCR, 0xE0);
 
+#ifdef CONFIG_TANGO2
+			quot = serial_inp(up, UART_DL);
+#else
 			quot = serial_dl_read(up);
+#endif
 			quot <<= 3;
 
-			if (ns16550a_goto_highspeed(up))
+			if (ns16550a_goto_highspeed(up)) {
+#ifdef CONFIG_TANGO2
+				serial_outp(up, UART_DL, quot);
+#else
 				serial_dl_write(up, quot);
+#endif
+			}
 
 			serial_outp(up, UART_LCR, 0);
 
@@ -2441,7 +2514,11 @@
 		serial_outp(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
 	}
 
+#ifdef CONFIG_TANGO2
+	serial_outp(up, UART_DL, quot);
+#else
 	serial_dl_write(up, quot);
+#endif
 
 	/*
 	 * LCR DLAB must be set to enable 64-byte FIFO mode. If the FCR
diff -ruw linux-2.6.39.4/drivers/tty/serial/8250_early.c linux-2.6.39.4-fbx/drivers/tty/serial/8250_early.c
--- linux-2.6.39.4/drivers/tty/serial/8250_early.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/tty/serial/8250_early.c	2011-06-15 18:56:43.985457674 +0200
@@ -121,8 +121,13 @@
 
 	lcr = serial_in(port, UART_LCR);
 	serial_out(port, UART_LCR, lcr | UART_LCR_DLAB);
+#ifdef CONFIG_TANGO2
+	dll = serial_in(port, UART_DL) & 0xff;
+	dlm = serial_in(port, UART_DL) >> 8;
+#else
 	dll = serial_in(port, UART_DLL);
 	dlm = serial_in(port, UART_DLM);
+#endif
 	serial_out(port, UART_LCR, lcr);
 
 	quot = (dlm << 8) | dll;
@@ -143,8 +148,12 @@
 	divisor = port->uartclk / (16 * device->baud);
 	c = serial_in(port, UART_LCR);
 	serial_out(port, UART_LCR, c | UART_LCR_DLAB);
+#ifdef CONFIG_TANGO2
+	serial_out(port, UART_DL, divisor & 0xffff);
+#else
 	serial_out(port, UART_DLL, divisor & 0xff);
 	serial_out(port, UART_DLM, (divisor >> 8) & 0xff);
+#endif
 	serial_out(port, UART_LCR, c & ~UART_LCR_DLAB);
 }
 
diff -ruw linux-2.6.39.4/drivers/tty/serial/8250_pci.c linux-2.6.39.4-fbx/drivers/tty/serial/8250_pci.c
--- linux-2.6.39.4/drivers/tty/serial/8250_pci.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/tty/serial/8250_pci.c	2011-06-15 18:56:43.995457702 +0200
@@ -964,7 +964,7 @@
 {
 	int ret;
 
-	ret = setup_port(priv, port, 0, 0, board->reg_shift);
+	ret = setup_port(priv, port, idx, 0, board->reg_shift);
 	port->iotype = UPIO_MEM32;
 	port->type = PORT_XSCALE;
 	port->flags = (port->flags | UPF_FIXED_PORT | UPF_FIXED_TYPE);
@@ -2307,8 +2307,8 @@
 		.first_offset	= 0x1000,
 	},
 	[pbn_ce4100_1_115200] = {
-		.flags		= FL_BASE0,
-		.num_ports	= 1,
+		.flags		= FL_BASE_BARS,
+		.num_ports	= 2,
 		.base_baud	= 921600,
 		.reg_shift      = 2,
 	},
diff -ruw linux-2.6.39.4/drivers/usb/host/ehci.h linux-2.6.39.4-fbx/drivers/usb/host/ehci.h
--- linux-2.6.39.4/drivers/usb/host/ehci.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/usb/host/ehci.h	2011-06-15 18:56:44.115458040 +0200
@@ -134,6 +134,7 @@
 	unsigned		amd_pll_fix:1;
 	unsigned		fs_i_thresh:1;	/* Intel iso scheduling */
 	unsigned		use_dummy_qh:1;	/* AMD Frame List table quirk*/
+	unsigned		has_synopsys_hc_bug:1; /* Synopsys HC */
 
 	/* required for usb32 quirk */
 	#define OHCI_CTRL_HCFS          (3 << 6)
diff -ruw linux-2.6.39.4/drivers/usb/host/ehci-hcd.c linux-2.6.39.4-fbx/drivers/usb/host/ehci-hcd.c
--- linux-2.6.39.4/drivers/usb/host/ehci-hcd.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/usb/host/ehci-hcd.c	2011-06-15 18:56:44.105458012 +0200
@@ -1267,6 +1267,16 @@
 #define PLATFORM_DRIVER		tegra_ehci_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_BCM63XX
+#include "ehci-bcm63xx.c"
+#define	PLATFORM_DRIVER		ehci_hcd_bcm63xx_driver
+#endif
+
+#ifdef CONFIG_TANGO2
+#include "ehci-tango2.c"
+#define	PLATFORM_DRIVER		ehci_hcd_tango2_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER) && \
     !defined(XILINX_OF_PLATFORM_DRIVER)
diff -ruw linux-2.6.39.4/drivers/usb/host/ehci-hub.c linux-2.6.39.4-fbx/drivers/usb/host/ehci-hub.c
--- linux-2.6.39.4/drivers/usb/host/ehci-hub.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/usb/host/ehci-hub.c	2011-06-15 18:56:44.115458040 +0200
@@ -883,11 +883,13 @@
 			 * power switching; they're allowed to just limit the
 			 * current.  khubd will turn the power back on.
 			 */
+#ifndef CONFIG_BCM63XX
 			if (HCS_PPC (ehci->hcs_params)){
 				ehci_writel(ehci,
 					temp & ~(PORT_RWC_BITS | PORT_POWER),
 					status_reg);
 			}
+#endif
 		}
 
 		/* whoever resumes must GetPortStatus to complete it!! */
diff -ruw linux-2.6.39.4/drivers/usb/host/ehci-orion.c linux-2.6.39.4-fbx/drivers/usb/host/ehci-orion.c
--- linux-2.6.39.4/drivers/usb/host/ehci-orion.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/usb/host/ehci-orion.c	2011-06-15 18:56:44.115458040 +0200
@@ -25,6 +25,7 @@
 #define USB_WINDOW_BASE(i)	(0x324 + ((i) << 4))
 #define USB_IPG			0x360
 #define USB_PHY_PWR_CTRL	0x400
+#define USB_PHY_PLL_CTRL	0x410
 #define USB_PHY_TX_CTRL		0x420
 #define USB_PHY_RX_CTRL		0x430
 #define USB_PHY_IVREF_CTRL	0x440
@@ -100,6 +101,70 @@
 	wrl(USB_MODE, 0x13);
 }
 
+/*
+ * Implement Kirkwood USB controller specification guidelines
+ */
+static void orion_usb_phy_kw_setup(struct usb_hcd *hcd)
+{
+	u32 val;
+
+	/*
+	 * Clear interrupt cause and mask
+	 */
+	wrl(USB_CAUSE, 0);
+	wrl(USB_MASK, 0);
+
+	/*
+	 * Reset controller
+	 */
+	wrl(USB_CMD, rdl(USB_CMD) | 0x2);
+	while (rdl(USB_CMD) & 0x2);
+
+	/*
+	 * GL# USB-10: Set IPG for non start of frame packets
+	 * Bits[14:8]=0xd
+	 */
+	wrl(USB_IPG, (rdl(USB_IPG) & ~0x7f00) | 0xd00);
+
+	val = rdl(USB_PHY_PLL_CTRL);
+	val |= (1 << 21);
+	wrl(USB_PHY_PLL_CTRL, val);
+	udelay(100);
+	val &= ~(1 << 21);
+	wrl(USB_PHY_PLL_CTRL, val);
+
+
+	val = rdl(USB_PHY_TX_CTRL);
+	val |= (1 << 12);
+	wrl(USB_PHY_TX_CTRL, val);
+	udelay(100);
+	val &= ~(1 << 12);
+	wrl(USB_PHY_TX_CTRL, val);
+	val &= ~0x7;
+	val |= 0x4;
+	wrl(USB_PHY_TX_CTRL, val);
+
+
+	val = rdl(USB_PHY_RX_CTRL);
+	val &= ~(0xf << 4);
+	val |= (0x8 << 4);
+	wrl(USB_PHY_RX_CTRL, val);
+
+	/*
+	 * Stop and reset controller
+	 */
+	wrl(USB_CMD, rdl(USB_CMD) & ~0x1);
+	wrl(USB_CMD, rdl(USB_CMD) | 0x2);
+	while (rdl(USB_CMD) & 0x2);
+
+	/*
+	 * GL# USB-5 Streaming disable REG_USB_MODE[4]=1
+	 * TBD: This need to be done after each reset!
+	 * GL# USB-4 Setup USB Host mode
+	 */
+	wrl(USB_MODE, 0x13);
+}
+
 static int ehci_orion_setup(struct usb_hcd *hcd)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
@@ -271,8 +336,10 @@
 	case EHCI_PHY_ORION:
 		orion_usb_phy_v1_setup(hcd);
 		break;
-	case EHCI_PHY_DD:
 	case EHCI_PHY_KW:
+		orion_usb_phy_kw_setup(hcd);
+		break;
+	case EHCI_PHY_DD:
 	default:
 		printk(KERN_WARNING "Orion ehci -USB phy version isn't supported.\n");
 	}
diff -ruw linux-2.6.39.4/drivers/usb/host/ehci-q.c linux-2.6.39.4-fbx/drivers/usb/host/ehci-q.c
--- linux-2.6.39.4/drivers/usb/host/ehci-q.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/usb/host/ehci-q.c	2011-06-15 18:56:44.115458040 +0200
@@ -1183,6 +1183,10 @@
 		ehci->reclaim = NULL;
 		start_unlink_async (ehci, next);
 	}
+
+	if (ehci->has_synopsys_hc_bug)
+		ehci_writel(ehci, (u32) ehci->async->qh_dma,
+			    &ehci->regs->async_next);
 }
 
 /* makes sure the async qh will become idle */
diff -ruw linux-2.6.39.4/drivers/usb/host/Kconfig linux-2.6.39.4-fbx/drivers/usb/host/Kconfig
--- linux-2.6.39.4/drivers/usb/host/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/usb/host/Kconfig	2011-06-15 18:56:44.105458012 +0200
@@ -106,7 +106,7 @@
 	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX || \
 				    ARCH_IXP4XX || XPS_USB_HCD_XILINX || \
 				    PPC_MPC512x || CPU_CAVIUM_OCTEON || \
-				    PMC_MSP)
+				    PMC_MSP || BCM63XX)
 	default y
 
 config USB_EHCI_BIG_ENDIAN_DESC
@@ -129,6 +129,14 @@
 config USB_FSL_MPH_DR_OF
 	tristate
 
+config USB_EHCI_BCM63XX
+	bool "Support for Broadcom 63xx on-chip EHCI USB controller"
+	depends on USB_EHCI_HCD && BCM63XX
+	select USB_EHCI_BIG_ENDIAN_MMIO
+	---help---
+	  Enables support for the on-chip EHCI controller on
+	  BCM6358 and later chips.
+
 config USB_EHCI_FSL
 	bool "Support for Freescale on-chip EHCI USB controller"
 	depends on USB_EHCI_HCD && FSL_SOC
@@ -272,6 +280,15 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called ohci-hcd.
 
+config USB_OHCI_BCM63XX
+	bool "Support for Broadcom 63xx on-chip OHCI USB controller"
+	depends on USB_OHCI_HCD && BCM63XX
+	select USB_OHCI_BIG_ENDIAN_DESC
+	select USB_OHCI_BIG_ENDIAN_MMIO
+	---help---
+	  Enables support for the on-chip OHCI controller on
+	  BCM63XX chips.
+
 config USB_OHCI_HCD_OMAP1
 	bool "OHCI support for OMAP1/2 chips"
 	depends on USB_OHCI_HCD && (ARCH_OMAP1 || ARCH_OMAP2)
diff -ruw linux-2.6.39.4/drivers/usb/serial/cp210x.c linux-2.6.39.4-fbx/drivers/usb/serial/cp210x.c
--- linux-2.6.39.4/drivers/usb/serial/cp210x.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/usb/serial/cp210x.c	2011-06-15 18:56:44.365458742 +0200
@@ -57,6 +57,7 @@
 	{ USB_DEVICE(0x0489, 0xE000) }, /* Pirelli Broadband S.p.A, DP-L10 SIP/GSM Mobile */
 	{ USB_DEVICE(0x0489, 0xE003) }, /* Pirelli Broadband S.p.A, DP-L10 SIP/GSM Mobile */
 	{ USB_DEVICE(0x0745, 0x1000) }, /* CipherLab USB CCD Barcode Scanner 1000 */
+	{ USB_DEVICE(0x0489, 0xE003) }, /* Pirelli wifi/GSM phone */
 	{ USB_DEVICE(0x08e6, 0x5501) }, /* Gemalto Prox-PU/CU contactless smartcard reader */
 	{ USB_DEVICE(0x08FD, 0x000A) }, /* Digianswer A/S , ZigBee/802.15.4 MAC Device */
 	{ USB_DEVICE(0x0BED, 0x1100) }, /* MEI (TM) Cashflow-SC Bill/Voucher Acceptor */
diff -ruw linux-2.6.39.4/drivers/usb/storage/usb.c linux-2.6.39.4-fbx/drivers/usb/storage/usb.c
--- linux-2.6.39.4/drivers/usb/storage/usb.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/usb/storage/usb.c	2011-08-01 20:08:51.909022964 +0200
@@ -78,7 +78,7 @@
 MODULE_DESCRIPTION("USB Mass Storage driver for Linux");
 MODULE_LICENSE("GPL");
 
-static unsigned int delay_use = 1;
+static unsigned int delay_use = 5;
 module_param(delay_use, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(delay_use, "seconds to delay before using a new device");
 
diff -ruw linux-2.6.39.4/drivers/video/Kconfig linux-2.6.39.4-fbx/drivers/video/Kconfig
--- linux-2.6.39.4/drivers/video/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/video/Kconfig	2011-06-15 18:56:44.385458798 +0200
@@ -471,6 +471,17 @@
 	  this driver, say Y or M; otherwise say N. You must specify the
 	  GPIO IO address to be used for setting control and data.
 
+config FB_SSD1327
+	tristate "SSD1327 OLED driver"
+	depends on FB
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_SYS_FOPS
+	select FB_BACKLIGHT
+	select SPI
+	default n
+
 config FB_ATARI
 	bool "Atari native chipset support"
 	depends on (FB = y) && ATARI
diff -ruw linux-2.6.39.4/drivers/video/Makefile linux-2.6.39.4-fbx/drivers/video/Makefile
--- linux-2.6.39.4/drivers/video/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/drivers/video/Makefile	2011-06-15 18:56:44.385458798 +0200
@@ -31,6 +31,7 @@
 # Hardware specific drivers go first
 obj-$(CONFIG_FB_AMIGA)            += amifb.o c2p_planar.o
 obj-$(CONFIG_FB_ARC)              += arcfb.o
+obj-$(CONFIG_FB_SSD1327)          += ssd1327.o
 obj-$(CONFIG_FB_CLPS711X)         += clps711xfb.o
 obj-$(CONFIG_FB_CYBER2000)        += cyber2000fb.o
 obj-$(CONFIG_FB_PM2)              += pm2fb.o
diff -ruw linux-2.6.39.4/fs/exec.c linux-2.6.39.4-fbx/fs/exec.c
--- linux-2.6.39.4/fs/exec.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/fs/exec.c	2011-08-01 20:08:51.999022701 +0200
@@ -61,6 +61,14 @@
 #include <asm/tlb.h>
 #include "internal.h"
 
+enum {
+	CORE_ENV_PID,
+	CORE_ENV_SIGNAL,
+	CORE_ENV_EXECUTABLE,
+	CORE_ENV_TIME,
+	CORE_ENV_NR,
+};
+
 int core_uses_pid;
 char core_pattern[CORENAME_MAX_SIZE] = "core";
 unsigned int core_pipe_limit;
@@ -1925,7 +1933,8 @@
 	struct cred *cred;
 	int retval = 0;
 	int flag = 0;
-	int ispipe;
+	int ispipe, i;
+	char *helper_envp[CORE_ENV_NR + 1];
 	static atomic_t core_dump_count = ATOMIC_INIT(0);
 	struct coredump_params cprm = {
 		.signr = signr,
@@ -1939,6 +1948,7 @@
 		.mm_flags = mm->flags,
 	};
 
+	memset(helper_envp, 0, sizeof (helper_envp));
 	audit_core_dumps(signr);
 
 	binfmt = mm->binfmt;
@@ -1984,6 +1994,7 @@
  	if (ispipe) {
 		int dump_count;
 		char **helper_argv;
+		struct timeval tv;
 
 		if (cprm.limit == 1) {
 			/*
@@ -2023,9 +2034,22 @@
 			goto fail_dropcount;
 		}
 
+		/* Set pipe helper environment */
+		do_gettimeofday(&tv);
+
+		helper_envp[CORE_ENV_PID] = kasprintf(GFP_KERNEL,
+			"CORE_PID=%d", current->tgid);
+		helper_envp[CORE_ENV_SIGNAL] = kasprintf(GFP_KERNEL,
+			"CORE_SIGNAL=%ld", signr);
+		helper_envp[CORE_ENV_EXECUTABLE] = kasprintf(GFP_KERNEL,
+			"CORE_EXECUTABLE=%s", current->comm);
+		helper_envp[CORE_ENV_TIME] = kasprintf(GFP_KERNEL,
+			"CORE_TIME=%lu", tv.tv_sec);
+		helper_envp[CORE_ENV_NR] = NULL;
+
 		retval = call_usermodehelper_fns(helper_argv[0], helper_argv,
-					NULL, UMH_WAIT_EXEC, umh_pipe_setup,
-					NULL, &cprm);
+					helper_envp, UMH_WAIT_EXEC,
+					umh_pipe_setup, NULL, &cprm);
 		argv_free(helper_argv);
 		if (retval) {
  			printk(KERN_INFO "Core dump to %s pipe failed\n",
@@ -2083,6 +2107,9 @@
 	kfree(cn.corename);
 fail_corename:
 	coredump_finish(mm);
+	for (i = 0; i < CORE_ENV_NR; i++)
+		kfree(helper_envp[i]);
+
 	revert_creds(old_cred);
 fail_creds:
 	put_cred(cred);
diff -ruw linux-2.6.39.4/fs/hfsplus/hfsplus_fs.h linux-2.6.39.4-fbx/fs/hfsplus/hfsplus_fs.h
--- linux-2.6.39.4/fs/hfsplus/hfsplus_fs.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/fs/hfsplus/hfsplus_fs.h	2011-09-09 16:11:25.380446444 +0200
@@ -160,6 +160,7 @@
 #define HFSPLUS_SB_HFSX		3
 #define HFSPLUS_SB_CASEFOLD	4
 #define HFSPLUS_SB_NOBARRIER	5
+#define HFSPLUS_SB_NOOWNERS	6
 
 static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)
 {
diff -ruw linux-2.6.39.4/fs/hfsplus/inode.c linux-2.6.39.4-fbx/fs/hfsplus/inode.c
--- linux-2.6.39.4/fs/hfsplus/inode.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/fs/hfsplus/inode.c	2011-09-09 16:11:25.380446444 +0200
@@ -231,11 +231,13 @@
 	mode = be16_to_cpu(perms->mode);
 
 	inode->i_uid = be32_to_cpu(perms->owner);
-	if (!inode->i_uid && !mode)
+	if ((!inode->i_uid && !mode) ||
+	    test_bit(HFSPLUS_SB_NOOWNERS, &sbi->flags))
 		inode->i_uid = sbi->uid;
 
 	inode->i_gid = be32_to_cpu(perms->group);
-	if (!inode->i_gid && !mode)
+	if ((!inode->i_gid && !mode) ||
+	    test_bit(HFSPLUS_SB_NOOWNERS, &sbi->flags))
 		inode->i_gid = sbi->gid;
 
 	if (dir) {
@@ -288,12 +290,16 @@
 static int hfsplus_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	struct inode *inode = dentry->d_inode;
+	struct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);
 	int error;
 
 	error = inode_change_ok(inode, attr);
 	if (error)
 		return error;
 
+	if (test_bit(HFSPLUS_SB_NOOWNERS, &sbi->flags))
+		attr->ia_valid &= ~(ATTR_UID | ATTR_GID);
+
 	if ((attr->ia_valid & ATTR_SIZE) &&
 	    attr->ia_size != i_size_read(inode)) {
 		error = vmtruncate(inode, attr->ia_size);
@@ -377,8 +383,13 @@
 
 	inode->i_ino = sbi->next_cnid++;
 	inode->i_mode = mode;
+	if (test_bit(HFSPLUS_SB_NOOWNERS, &sbi->flags)) {
+		inode->i_uid = sbi->uid;
+		inode->i_gid = sbi->gid;
+	} else {
 	inode->i_uid = current_fsuid();
 	inode->i_gid = current_fsgid();
+	}
 	inode->i_nlink = 1;
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;
 
diff -ruw linux-2.6.39.4/fs/hfsplus/options.c linux-2.6.39.4-fbx/fs/hfsplus/options.c
--- linux-2.6.39.4/fs/hfsplus/options.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/fs/hfsplus/options.c	2011-09-09 16:11:25.380446444 +0200
@@ -24,7 +24,7 @@
 	opt_part, opt_session, opt_nls,
 	opt_nodecompose, opt_decompose,
 	opt_barrier, opt_nobarrier,
-	opt_force, opt_err
+	opt_force, opt_noowners, opt_err
 };
 
 static const match_table_t tokens = {
@@ -41,6 +41,7 @@
 	{ opt_barrier, "barrier" },
 	{ opt_nobarrier, "nobarrier" },
 	{ opt_force, "force" },
+	{ opt_noowners, "noowners" },
 	{ opt_err, NULL }
 };
 
@@ -188,6 +189,9 @@
 		case opt_force:
 			set_bit(HFSPLUS_SB_FORCE, &sbi->flags);
 			break;
+		case opt_noowners:
+			set_bit(HFSPLUS_SB_NOOWNERS, &sbi->flags);
+			break;
 		default:
 			return 0;
 		}
@@ -226,5 +230,7 @@
 		seq_printf(seq, ",nodecompose");
 	if (test_bit(HFSPLUS_SB_NOBARRIER, &sbi->flags))
 		seq_printf(seq, ",nobarrier");
+	if (test_bit(HFSPLUS_SB_NOOWNERS, &sbi->flags))
+		seq_printf(seq, ",noowners");
 	return 0;
 }
diff -ruw linux-2.6.39.4/fs/Kconfig linux-2.6.39.4-fbx/fs/Kconfig
--- linux-2.6.39.4/fs/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/fs/Kconfig	2011-06-15 18:56:45.295461349 +0200
@@ -148,6 +148,17 @@
 config HUGETLB_PAGE
 	def_bool HUGETLBFS
 
+config RAMFS_XATTR
+	bool
+	default n
+ 
+config RAMFS_XATTR_USER
+	bool "Enable user extended attributes on RAMFS filesystem"
+	select RAMFS_XATTR
+	help
+	  Select this to enable extended user attributes on RAMFS
+	  filesystem.
+
 source "fs/configfs/Kconfig"
 
 endmenu
diff -ruw linux-2.6.39.4/fs/namespace.c linux-2.6.39.4-fbx/fs/namespace.c
--- linux-2.6.39.4/fs/namespace.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/fs/namespace.c	2011-06-15 18:56:45.445461769 +0200
@@ -1695,7 +1695,7 @@
 
 static int flags_to_propagation_type(int flags)
 {
-	int type = flags & ~MS_REC;
+	int type = flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE);
 
 	/* Fail if any non-propagation flags are set */
 	if (type & ~(MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))
diff -ruw linux-2.6.39.4/fs/ramfs/file-mmu.c linux-2.6.39.4-fbx/fs/ramfs/file-mmu.c
--- linux-2.6.39.4/fs/ramfs/file-mmu.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/fs/ramfs/file-mmu.c	2011-05-24 18:15:56.905714926 +0200
@@ -27,6 +27,7 @@
 #include <linux/fs.h>
 #include <linux/mm.h>
 #include <linux/ramfs.h>
+#include <linux/xattr.h>
 
 #include "internal.h"
 
@@ -52,4 +53,11 @@
 const struct inode_operations ramfs_file_inode_operations = {
 	.setattr	= simple_setattr,
 	.getattr	= simple_getattr,
+#ifdef CONFIG_RAMFS_XATTR
+	.setxattr	= generic_setxattr,
+	.getxattr	= generic_getxattr,
+	.listxattr	= generic_listxattr,
+	.removexattr	= generic_removexattr,
+#endif
 };
+
diff -ruw linux-2.6.39.4/fs/ramfs/inode.c linux-2.6.39.4-fbx/fs/ramfs/inode.c
--- linux-2.6.39.4/fs/ramfs/inode.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/fs/ramfs/inode.c	2011-06-15 18:56:45.535462021 +0200
@@ -37,12 +37,14 @@
 #include <linux/magic.h>
 #include <linux/slab.h>
 #include <asm/uaccess.h>
+#include <linux/xattr.h>
 #include "internal.h"
 
 #define RAMFS_DEFAULT_MODE	0755
 
 static const struct super_operations ramfs_ops;
 static const struct inode_operations ramfs_dir_inode_operations;
+static struct kmem_cache *ramfs_inode_cache;
 
 static struct backing_dev_info ramfs_backing_dev_info = {
 	.name		= "ramfs",
@@ -52,6 +54,28 @@
 			  BDI_CAP_READ_MAP | BDI_CAP_WRITE_MAP | BDI_CAP_EXEC_MAP,
 };
 
+static struct inode *ramfs_alloc_inode(struct super_block *sb)
+{
+	struct ramfs_inode_info *rii;
+
+	rii = kmem_cache_alloc(ramfs_inode_cache, GFP_KERNEL);
+	if (!rii)
+		return NULL;
+	return &rii->vfs_inode;
+}
+
+static void ramfs_destroy_inode(struct inode *ino)
+{
+	struct ramfs_inode_info *rii;
+
+	rii = RAMFS_I(ino);
+
+#ifdef CONFIG_RAMFS_XATTR
+	ramfs_inode_purge_xattrs(rii);
+#endif
+	kmem_cache_free(ramfs_inode_cache, rii);
+}
+
 struct inode *ramfs_get_inode(struct super_block *sb,
 				const struct inode *dir, int mode, dev_t dev)
 {
@@ -149,9 +173,17 @@
 	.rmdir		= simple_rmdir,
 	.mknod		= ramfs_mknod,
 	.rename		= simple_rename,
+#ifdef CONFIG_RAMFS_XATTR
+	.setxattr	= generic_setxattr,
+	.getxattr	= generic_getxattr,
+	.listxattr	= generic_listxattr,
+	.removexattr	= generic_removexattr,
+#endif
 };
 
 static const struct super_operations ramfs_ops = {
+	.alloc_inode	= ramfs_alloc_inode,
+	.destroy_inode	= ramfs_destroy_inode,
 	.statfs		= simple_statfs,
 	.drop_inode	= generic_delete_inode,
 	.show_options	= generic_show_options,
@@ -233,6 +265,9 @@
 	sb->s_magic		= RAMFS_MAGIC;
 	sb->s_op		= &ramfs_ops;
 	sb->s_time_gran		= 1;
+#ifdef CONFIG_RAMFS_XATTR
+	sb->s_xattr = ramfs_xattr_handlers;
+#endif
 
 	inode = ramfs_get_inode(sb, NULL, S_IFDIR | fsi->mount_opts.mode, 0);
 	if (!inode) {
@@ -284,6 +319,16 @@
 	.kill_sb	= kill_litter_super,
 };
 
+static void ramfs_inode_init_once(void *ptr)
+{
+	struct ramfs_inode_info *p = (struct ramfs_inode_info *)ptr;
+
+	inode_init_once(&p->vfs_inode);
+#ifdef CONFIG_RAMFS_XATTR_USER
+	INIT_LIST_HEAD(&p->xattr_user_list);
+#endif
+}
+
 static int __init init_ramfs_fs(void)
 {
 	return register_filesystem(&ramfs_fs_type);
@@ -305,10 +350,19 @@
 	if (err)
 		return err;
 
-	err = register_filesystem(&rootfs_fs_type);
-	if (err)
+	ramfs_inode_cache = kmem_cache_create("ramfs_inode_cache",
+					      sizeof (struct ramfs_inode_info),
+					      0, 0, ramfs_inode_init_once);
+	if (!ramfs_inode_cache) {
 		bdi_destroy(&ramfs_backing_dev_info);
+		return -ENOMEM;
+	}
 
+	err = register_filesystem(&rootfs_fs_type);
+	if (err) {
+		kmem_cache_destroy(ramfs_inode_cache);
+		bdi_destroy(&ramfs_backing_dev_info);
+	}
 	return err;
 }
 
diff -ruw linux-2.6.39.4/fs/ramfs/internal.h linux-2.6.39.4-fbx/fs/ramfs/internal.h
--- linux-2.6.39.4/fs/ramfs/internal.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/fs/ramfs/internal.h	2011-05-24 18:15:56.905714926 +0200
@@ -9,6 +9,42 @@
  * 2 of the License, or (at your option) any later version.
  */
 
+#ifndef RAMFS_INTERNAL_H
+# define RAMFS_INTERNALH
+
+/* need list_head */
+#include <linux/list.h>
 
 extern const struct address_space_operations ramfs_aops;
 extern const struct inode_operations ramfs_file_inode_operations;
+
+
+struct ramfs_xattr
+{
+	char *name;
+	void *data;
+	size_t data_len;
+
+	struct list_head list;
+};
+
+struct ramfs_inode_info
+{
+	struct inode vfs_inode;
+#ifdef CONFIG_RAMFS_XATTR_USER
+	struct list_head xattr_user_list;
+#endif
+};
+
+static inline struct ramfs_inode_info *RAMFS_I(struct inode *inode)
+{
+	return container_of(inode, struct ramfs_inode_info, vfs_inode);
+}
+
+#ifdef CONFIG_RAMFS_XATTR
+void ramfs_inode_purge_xattrs(struct ramfs_inode_info *rii);
+extern const struct xattr_handler *ramfs_xattr_handlers[];
+#endif
+
+
+#endif /* !RAMFS_INTERNAL_H */
diff -ruw linux-2.6.39.4/fs/ramfs/Makefile linux-2.6.39.4-fbx/fs/ramfs/Makefile
--- linux-2.6.39.4/fs/ramfs/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/fs/ramfs/Makefile	2011-05-24 18:15:37.435795533 +0200
@@ -6,4 +6,5 @@
 
 file-mmu-y := file-nommu.o
 file-mmu-$(CONFIG_MMU) := file-mmu.o
-ramfs-objs += inode.o $(file-mmu-y)
+ramfs-xattr-$(CONFIG_RAMFS_XATTR) += xattr.o
+ramfs-objs += inode.o $(file-mmu-y) $(ramfs-xattr-y)
diff -ruw linux-2.6.39.4/fs/xfs/linux-2.6/xfs_buf.c linux-2.6.39.4-fbx/fs/xfs/linux-2.6/xfs_buf.c
--- linux-2.6.39.4/fs/xfs/linux-2.6/xfs_buf.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/fs/xfs/linux-2.6/xfs_buf.c	2011-06-15 18:56:45.555462077 +0200
@@ -377,6 +377,70 @@
 	return error;
 }
 
+#ifdef CONFIG_MIPS
+static void cache_flush_buf_page(xfs_buf_t *bp, int page_id)
+{
+	struct page *page;
+	void *vmaddr, *addr;
+
+	if (!(bp->b_flags & XBF_MAPPED))
+		return;
+
+	if (bp->b_page_count <= 1)
+		return;
+
+	page = bp->b_pages[page_id];
+	vmaddr = bp->b_addr - bp->b_offset + (page_id * PAGE_CACHE_SIZE);
+	addr = page_address(page);
+
+	if (pages_do_alias((unsigned long)addr, (unsigned long)vmaddr)) {
+		local_flush_data_cache_page(vmaddr);
+		local_flush_data_cache_page(addr);
+	}
+}
+
+static void cache_flush_buf(xfs_buf_t *bp)
+{
+	unsigned int i;
+
+	for (i = 0; i < bp->b_page_count; i++)
+		cache_flush_buf_page(bp, i);
+}
+#elif defined(CONFIG_ARM)
+#include <asm/cacheflush.h>
+static void cache_flush_buf_page(xfs_buf_t *bp, int page_id)
+{
+	struct page *page;
+	void *vmaddr, *addr;
+
+	if (!(bp->b_flags & XBF_MAPPED))
+		return;
+
+	if (bp->b_page_count <= 1)
+		return;
+
+	page = bp->b_pages[page_id];
+	vmaddr = bp->b_addr - bp->b_offset + (page_id * PAGE_CACHE_SIZE);
+	addr = page_address(page);
+
+	if ((cache_is_vivt() || cache_is_vipt_aliasing())) {
+		__cpuc_flush_dcache_area(vmaddr, PAGE_SIZE);
+		__cpuc_flush_dcache_area(addr, PAGE_SIZE);
+	}
+}
+
+static void cache_flush_buf(xfs_buf_t *bp)
+{
+	unsigned int i;
+
+	for (i = 0; i < bp->b_page_count; i++)
+		cache_flush_buf_page(bp, i);
+}
+#else
+static inline void cache_flush_buf_page(xfs_buf_t *bp, int page_id) { }
+static inline void cache_flush_buf(xfs_buf_t *bp) { }
+#endif
+
 /*
  *	Map buffer into kernel address-space if necessary.
  */
@@ -405,6 +469,7 @@
 			return -ENOMEM;
 		bp->b_addr += bp->b_offset;
 		bp->b_flags |= XBF_MAPPED;
+		cache_flush_buf(bp);
 	}
 
 	return 0;
@@ -1239,6 +1304,7 @@
 		if (nbytes > size)
 			nbytes = size;
 
+		cache_flush_buf_page(bp, map_i);
 		rbytes = bio_add_page(bio, bp->b_pages[map_i], nbytes, offset);
 		if (rbytes < nbytes)
 			break;
diff -ruw linux-2.6.39.4/fs/xfs/xfs_dir2_block.c linux-2.6.39.4-fbx/fs/xfs/xfs_dir2_block.c
--- linux-2.6.39.4/fs/xfs/xfs_dir2_block.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/fs/xfs/xfs_dir2_block.c	2011-06-15 18:56:45.565462105 +0200
@@ -484,6 +484,9 @@
 	 * Each object is a real entry (dep) or an unused one (dup).
 	 */
 	while (ptr < endptr) {
+		struct xfs_inode *inode;
+		unsigned int type;
+
 		dup = (xfs_dir2_data_unused_t *)ptr;
 		/*
 		 * Unused, skip it.
@@ -508,12 +511,20 @@
 		cook = xfs_dir2_db_off_to_dataptr(mp, mp->m_dirdatablk,
 					    (char *)dep - (char *)block);
 
+		if (xfs_iget(mp, NULL, be64_to_cpu(dep->inumber), 0, 0,
+			     &inode) == 0) {
+			type = (inode->i_d.di_mode >> 12) & 0xf;
+			xfs_iunlock(inode, 0);
+			IRELE(inode);
+		} else
+			type = DT_UNKNOWN;
+
 		/*
 		 * If it didn't fit, set the final offset to here & return.
 		 */
 		if (filldir(dirent, (char *)dep->name, dep->namelen,
 			    cook & 0x7fffffff, be64_to_cpu(dep->inumber),
-			    DT_UNKNOWN)) {
+			    type)) {
 			*offset = cook & 0x7fffffff;
 			xfs_da_brelse(NULL, bp);
 			return 0;
diff -ruw linux-2.6.39.4/fs/xfs/xfs_dir2_leaf.c linux-2.6.39.4-fbx/fs/xfs/xfs_dir2_leaf.c
--- linux-2.6.39.4/fs/xfs/xfs_dir2_leaf.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/fs/xfs/xfs_dir2_leaf.c	2011-06-15 18:56:45.575462133 +0200
@@ -816,6 +816,9 @@
 	 * Get more blocks and readahead as necessary.
 	 */
 	while (curoff < XFS_DIR2_LEAF_OFFSET) {
+		struct xfs_inode *inode;
+		unsigned int type;
+
 		/*
 		 * If we have no buffer, or we're off the end of the
 		 * current buffer, need to get another one.
@@ -1079,9 +1082,17 @@
 		dep = (xfs_dir2_data_entry_t *)ptr;
 		length = xfs_dir2_data_entsize(dep->namelen);
 
+		if (xfs_iget(mp, NULL, be64_to_cpu(dep->inumber), 0, 0,
+			     &inode) == 0) {
+			type = (inode->i_d.di_mode >> 12) & 0xf;
+			xfs_iunlock(inode, 0);
+			IRELE(inode);
+		} else
+			type = DT_UNKNOWN;
+
 		if (filldir(dirent, (char *)dep->name, dep->namelen,
 			    xfs_dir2_byte_to_dataptr(mp, curoff) & 0x7fffffff,
-			    be64_to_cpu(dep->inumber), DT_UNKNOWN))
+			    be64_to_cpu(dep->inumber), type))
 			break;
 
 		/*
diff -ruw linux-2.6.39.4/fs/xfs/xfs_dir2_sf.c linux-2.6.39.4-fbx/fs/xfs/xfs_dir2_sf.c
--- linux-2.6.39.4/fs/xfs/xfs_dir2_sf.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/fs/xfs/xfs_dir2_sf.c	2011-06-15 18:56:45.575462133 +0200
@@ -771,6 +771,9 @@
 	 */
 	sfep = xfs_dir2_sf_firstentry(sfp);
 	for (i = 0; i < sfp->hdr.count; i++) {
+		struct xfs_inode *inode;
+		unsigned int type;
+
 		off = xfs_dir2_db_off_to_dataptr(mp, mp->m_dirdatablk,
 				xfs_dir2_sf_get_offset(sfep));
 
@@ -780,8 +783,16 @@
 		}
 
 		ino = xfs_dir2_sf_get_inumber(sfp, xfs_dir2_sf_inumberp(sfep));
+
+		if (xfs_iget(mp, NULL, ino, 0, 0, &inode) == 0) {
+			type = (inode->i_d.di_mode >> 12) & 0xf;
+			xfs_iunlock(inode, 0);
+			IRELE(inode);
+		} else
+			type = DT_UNKNOWN;
+
 		if (filldir(dirent, (char *)sfep->name, sfep->namelen,
-			    off & 0x7fffffff, ino, DT_UNKNOWN)) {
+			    off & 0x7fffffff, ino, type)) {
 			*offset = off & 0x7fffffff;
 			return 0;
 		}
diff -ruw linux-2.6.39.4/include/linux/if_tunnel.h linux-2.6.39.4-fbx/include/linux/if_tunnel.h
--- linux-2.6.39.4/include/linux/if_tunnel.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/if_tunnel.h	2011-05-24 18:15:56.995714556 +0200
@@ -38,6 +38,11 @@
 	__be16			o_flags;
 	__be32			i_key;
 	__be32			o_key;
+
+	/* this is the first bits to match on ipv6 address */
+	struct in6_addr		fbx6to4_zone;
+	__u8			fbx6to4_prefix;
+
 	struct iphdr		iph;
 };
 
diff -ruw linux-2.6.39.4/include/linux/in.h linux-2.6.39.4-fbx/include/linux/in.h
--- linux-2.6.39.4/include/linux/in.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/in.h	2011-07-20 19:23:09.686239401 +0200
@@ -264,6 +264,9 @@
 		return 0;
 	case IPPROTO_AH:	/* SPI */
 		return 4;
+	case IPPROTO_IPV6:
+		/* third byte of ipv6 destination address */
+		return 36;
 	default:
 		return -EINVAL;
 	}
diff -ruw linux-2.6.39.4/include/linux/Kbuild linux-2.6.39.4-fbx/include/linux/Kbuild
--- linux-2.6.39.4/include/linux/Kbuild	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/Kbuild	2011-06-15 18:56:45.595462190 +0200
@@ -125,6 +125,8 @@
 header-y += fanotify.h
 header-y += fb.h
 header-y += fcntl.h
+header-y += fbxatm.h
+header-y += fbxmtd_map_ioctl.h
 header-y += fd.h
 header-y += fdreg.h
 header-y += fib_rules.h
@@ -396,3 +398,4 @@
 header-y += x25.h
 header-y += xattr.h
 header-y += xfrm.h
+header-y += remoti/
diff -ruw linux-2.6.39.4/include/linux/major.h linux-2.6.39.4-fbx/include/linux/major.h
--- linux-2.6.39.4/include/linux/major.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/major.h	2011-05-24 18:15:37.605794827 +0200
@@ -171,7 +171,16 @@
 
 #define VIOTAPE_MAJOR		230
 
-#define BLOCK_EXT_MAJOR		259
+/*
+ * Until userland gets decent support for large majors number (if the
+ * day ever comes), use 242 for BLOCK_EXT_MAJOR. According to
+ * devices.txt area 240 to 254 is assigned for "LOCAL/EXPERIMENTAL
+ * USE". This kind of hack would fall in this category.
+ */
+/* #define BLOCK_EXT_MAJOR		259 */
+#define BLOCK_EXT_MAJOR		242
+
+
 #define SCSI_OSD_MAJOR		260	/* open-osd's OSD scsi device */
 
 #endif
diff -ruw linux-2.6.39.4/include/linux/mtd/mtd.h linux-2.6.39.4-fbx/include/linux/mtd/mtd.h
--- linux-2.6.39.4/include/linux/mtd/mtd.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/mtd/mtd.h	2011-06-22 19:20:26.592924073 +0200
@@ -168,6 +168,11 @@
 	unsigned int erasesize_mask;
 	unsigned int writesize_mask;
 
+	/* NAND related attributes */
+	const char *nand_type;
+	const char *nand_manufacturer;
+	const char *onfi_version;
+
 	// Kernel-only stuff starts here.
 	const char *name;
 	int index;
diff -ruw linux-2.6.39.4/include/linux/mtd/nand.h linux-2.6.39.4-fbx/include/linux/mtd/nand.h
--- linux-2.6.39.4/include/linux/mtd/nand.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/mtd/nand.h	2011-06-15 18:56:45.675462415 +0200
@@ -213,7 +213,8 @@
 #define NAND_HAS_COPYBACK(chip) ((chip->options & NAND_COPYBACK))
 /* Large page NAND with SOFT_ECC should support subpage reads */
 #define NAND_SUBPAGE_READ(chip) ((chip->ecc.mode == NAND_ECC_SOFT) \
-					&& (chip->page_shift > 9))
+					&& (chip->page_shift > 9) \
+					&& !(chip->options & NAND_NO_RNDOUT))
 
 /* Mask to zero out the chip options, which come from the id table */
 #define NAND_CHIPOPTIONS_MSK	(0x0000ffff & ~NAND_NO_AUTOINCR)
@@ -233,6 +234,7 @@
 #define NAND_OWN_BUFFERS	0x00040000
 /* Chip may not exist, so silence any errors in scan */
 #define NAND_SCAN_SILENT_NODEV	0x00080000
+
 /*
  * If passed additionally to NAND_USE_FLASH_BBT then BBT code will not touch
  * the OOB area.
@@ -241,6 +243,10 @@
 /* Create an empty BBT with no vendor information if the BBT is available */
 #define NAND_CREATE_EMPTY_BBT		0x00200000
 
+
+/* NAND controller does not want RNDOUT commands, even in NAND_ECC_SOFT */
+#define NAND_NO_RNDOUT		0x00400000
+
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */
 #define NAND_CONTROLLER_ALLOC	0x80000000
diff -ruw linux-2.6.39.4/include/linux/mv643xx_eth.h linux-2.6.39.4-fbx/include/linux/mv643xx_eth.h
--- linux-2.6.39.4/include/linux/mv643xx_eth.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/mv643xx_eth.h	2011-05-24 18:15:57.025714432 +0200
@@ -6,6 +6,7 @@
 #define __LINUX_MV643XX_ETH_H
 
 #include <linux/mbus.h>
+#include <linux/netdevice.h>
 
 #define MV643XX_ETH_SHARED_NAME		"mv643xx_eth"
 #define MV643XX_ETH_NAME		"mv643xx_eth_port"
@@ -43,6 +44,15 @@
 	int			phy_addr;
 
 	/*
+	 * if PHY_NONE, called at probe/remove time to configure mii bus
+	 */
+	int (*mii_config)(struct net_device *dev, int probe,
+			  int (*mii_read)(struct net_device *dev,
+					  int phy_id, int reg),
+			  void (*mii_write)(struct net_device *dev,
+					    int phy_id, int reg, int val));
+
+	/*
 	 * Use this MAC address if it is valid, overriding the
 	 * address that is already in the hardware.
 	 */
diff -ruw linux-2.6.39.4/include/linux/netdevice.h linux-2.6.39.4-fbx/include/linux/netdevice.h
--- linux-2.6.39.4/include/linux/netdevice.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/netdevice.h	2011-08-04 19:24:35.731405928 +0200
@@ -1310,6 +1310,11 @@
 	/* GARP */
 	struct garp_port __rcu	*garp_port;
 
+#if defined(CONFIG_FREEBOX_BRIDGE) || defined(CONFIG_FREEBOX_BRIDGE_MODULE)
+	struct fbxbridge	*fbx_bridge;
+	struct fbxbridge	*fbx_bridge_port;
+#endif
+
 	/* class/net/name entry */
 	struct device		dev;
 	/* space for optional device, statistics, and wireless sysfs groups */
diff -ruw linux-2.6.39.4/include/linux/netfilter/nf_conntrack_ftp.h linux-2.6.39.4-fbx/include/linux/netfilter/nf_conntrack_ftp.h
--- linux-2.6.39.4/include/linux/netfilter/nf_conntrack_ftp.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/netfilter/nf_conntrack_ftp.h	2011-05-24 18:15:57.035714391 +0200
@@ -25,6 +25,11 @@
 	u_int32_t seq_aft_nl[IP_CT_DIR_MAX][NUM_SEQ_TO_REMEMBER];
 	/* 0 means seq_match_aft_nl not set */
 	int seq_aft_nl_num[IP_CT_DIR_MAX];
+#if defined(CONFIG_FREEBOX_BRIDGE) || defined(CONFIG_FREEBOX_BRIDGE_MODULE)
+	unsigned int is_fbxbridge;
+	unsigned long fbxbridge_remote;
+	unsigned long fbxbridge_wan;
+#endif
 };
 
 struct nf_conntrack_expect;
diff -ruw linux-2.6.39.4/include/linux/ppp_channel.h linux-2.6.39.4-fbx/include/linux/ppp_channel.h
--- linux-2.6.39.4/include/linux/ppp_channel.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/ppp_channel.h	2011-06-15 18:56:45.705462499 +0200
@@ -49,6 +49,9 @@
 /* Called by the channel when it can send some more data. */
 extern void ppp_output_wakeup(struct ppp_channel *);
 
+/* Called by the channel when it want to prevent further transmit on it */
+extern void ppp_output_stop(struct ppp_channel *);
+
 /* Called by the channel to process a received PPP packet.
    The packet should have just the 2-byte PPP protocol header. */
 extern void ppp_input(struct ppp_channel *, struct sk_buff *);
diff -ruw linux-2.6.39.4/include/linux/printk.h linux-2.6.39.4-fbx/include/linux/printk.h
--- linux-2.6.39.4/include/linux/printk.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/printk.h	2011-06-15 18:56:45.705462499 +0200
@@ -97,6 +97,7 @@
 int vprintk(const char *fmt, va_list args);
 asmlinkage __attribute__ ((format (printf, 1, 2))) __cold
 int printk(const char *fmt, ...);
+extern void console_emergency_dump(char *buf, int *len);
 
 /*
  * Please don't use printk_ratelimit(), because it shares ratelimiting state
@@ -137,6 +138,10 @@
 static inline void log_buf_kexec_setup(void)
 {
 }
+
+static inline void console_emergency_dump(char *buf, int *len)
+{
+}
 #endif
 
 extern void dump_stack(void) __cold;
diff -ruw linux-2.6.39.4/include/linux/serial_reg.h linux-2.6.39.4-fbx/include/linux/serial_reg.h
--- linux-2.6.39.4/include/linux/serial_reg.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/serial_reg.h	2011-06-15 18:56:45.715462527 +0200
@@ -18,9 +18,18 @@
  * DLAB=0
  */
 #define UART_RX		0	/* In:  Receive buffer */
+#ifdef CONFIG_TANGO2
+#define UART_TX		1	/* Out: Transmit buffer */
+#else
 #define UART_TX		0	/* Out: Transmit buffer */
+#endif
 
+#ifdef CONFIG_TANGO2
+#define UART_IER	2	/* Out: Interrupt Enable Register */
+#else
 #define UART_IER	1	/* Out: Interrupt Enable Register */
+#endif
+
 #define UART_IER_MSI		0x08 /* Enable Modem status interrupt */
 #define UART_IER_RLSI		0x04 /* Enable receiver line status interrupt */
 #define UART_IER_THRI		0x02 /* Enable Transmitter holding register int. */
@@ -30,7 +39,12 @@
  */
 #define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
 
+#ifdef CONFIG_TANGO2
+#define UART_IIR	3	/* In:  Interrupt ID Register */
+#else
 #define UART_IIR	2	/* In:  Interrupt ID Register */
+#endif
+
 #define UART_IIR_NO_INT		0x01 /* No interrupts pending */
 #define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
 #define UART_IIR_MSI		0x00 /* Modem status interrupt */
@@ -40,7 +54,12 @@
 
 #define UART_IIR_BUSY		0x07 /* DesignWare APB Busy Detect */
 
+#ifdef CONFIG_TANGO2
+#define UART_FCR	4	/* Out: FIFO Control Register */
+#else
 #define UART_FCR	2	/* Out: FIFO Control Register */
+#endif
+
 #define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
 #define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
 #define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
@@ -83,7 +102,12 @@
 #define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
 #define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
 
+#ifdef CONFIG_TANGO2
+#define UART_LCR	5	/* Out: Line Control Register */
+#else
 #define UART_LCR	3	/* Out: Line Control Register */
+#endif
+
 /*
  * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
  * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
@@ -106,7 +130,11 @@
 #define UART_LCR_CONF_MODE_A	UART_LCR_DLAB	/* Configutation mode A */
 #define UART_LCR_CONF_MODE_B	0xBF		/* Configutation mode B */
 
+#ifdef CONFIG_TANGO2
+#define UART_MCR	6	/* Out: Modem Control Register */
+#else
 #define UART_MCR	4	/* Out: Modem Control Register */
+#endif
 #define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
 #define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
 #define UART_MCR_XONANY		0x20 /* Enable Xon Any (TI16C752, EFR[4]=1) */
@@ -117,7 +145,12 @@
 #define UART_MCR_RTS		0x02 /* RTS complement */
 #define UART_MCR_DTR		0x01 /* DTR complement */
 
+#ifdef CONFIG_TANGO2
+#define UART_LSR	7	/* In:  Line Status Register */
+#else
 #define UART_LSR	5	/* In:  Line Status Register */
+#endif
+
 #define UART_LSR_TEMT		0x40 /* Transmitter empty */
 #define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
 #define UART_LSR_BI		0x10 /* Break interrupt indicator */
@@ -127,7 +160,11 @@
 #define UART_LSR_DR		0x01 /* Receiver data ready */
 #define UART_LSR_BRK_ERROR_BITS	0x1E /* BI, FE, PE, OE bits */
 
+#ifdef CONFIG_TANGO2
+#define UART_MSR	8	/* In:  Modem Status Register */
+#else
 #define UART_MSR	6	/* In:  Modem Status Register */
+#endif
 #define UART_MSR_DCD		0x80 /* Data Carrier Detect */
 #define UART_MSR_RI		0x40 /* Ring Indicator */
 #define UART_MSR_DSR		0x20 /* Data Set Ready */
@@ -138,18 +175,36 @@
 #define UART_MSR_DCTS		0x01 /* Delta CTS */
 #define UART_MSR_ANY_DELTA	0x0F /* Any of the delta bits! */
 
+#ifdef CONFIG_TANGO2
+#define UART_SCR	9	/* I/O: Scratch Register */
+#else
 #define UART_SCR	7	/* I/O: Scratch Register */
+#endif
 
 /*
  * DLAB=1
  */
+#ifdef CONFIG_TANGO2
+/*
+ * smp863x has DLM and DLM in one register
+ */
+#define UART_DL		10
+#define UART_CLKSEL     11      /* Clock selection */
+#else
 #define UART_DLL	0	/* Out: Divisor Latch Low */
 #define UART_DLM	1	/* Out: Divisor Latch High */
+#endif
 
 /*
  * LCR=0xBF (or DLAB=1 for 16C660)
  */
+#ifdef CONFIG_TANGO2
+/* EFR does not exist on TANGO2, we use a magic to catch accesses and
+ * make them nop */
+#define UART_EFR	42
+#else
 #define UART_EFR	2	/* I/O: Extended Features Register */
+#endif
 #define UART_EFR_CTS		0x80 /* CTS flow control */
 #define UART_EFR_RTS		0x40 /* RTS flow control */
 #define UART_EFR_SCD		0x20 /* Special character detect */
diff -ruw linux-2.6.39.4/include/linux/skbuff.h linux-2.6.39.4-fbx/include/linux/skbuff.h
--- linux-2.6.39.4/include/linux/skbuff.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/skbuff.h	2011-06-15 18:56:45.715462527 +0200
@@ -266,6 +266,13 @@
 #define NET_SKBUFF_NF_DEFRAG_NEEDED 1
 #endif
 
+enum {
+	FFN_STATE_INIT = 0,
+	FFN_STATE_FORWARDABLE,
+	FFN_STATE_FAST_FORWARDED,
+	FFN_STATE_INCOMPATIBLE,
+};
+
 /** 
  *	struct sk_buff - socket buffer
  *	@next: Next buffer in list
@@ -376,6 +383,9 @@
 #endif
 #ifdef NET_SKBUFF_NF_DEFRAG_NEEDED
 	struct sk_buff		*nfct_reasm;
+#ifdef CONFIG_IP_FFN
+	int			ffn_state;
+#endif
 #endif
 #ifdef CONFIG_BRIDGE_NETFILTER
 	struct nf_bridge_info	*nf_bridge;
@@ -412,6 +422,8 @@
 		__u32		dropcount;
 	};
 
+	__u32			rx_class;
+
 	__u16			vlan_tci;
 
 	sk_buff_data_t		transport_header;
@@ -1434,6 +1446,10 @@
  * get_rps_cpus() for example only access one 64 bytes aligned block :
  * NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20/40) + ports(8)
  */
+#ifdef CONFIG_NETSKBPAD
+#define NET_SKB_PAD	CONFIG_NETSKBPAD
+#endif
+
 #ifndef NET_SKB_PAD
 #define NET_SKB_PAD	max(32, L1_CACHE_BYTES)
 #endif
diff -ruw linux-2.6.39.4/include/linux/sockios.h linux-2.6.39.4-fbx/include/linux/sockios.h
--- linux-2.6.39.4/include/linux/sockios.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/sockios.h	2011-06-15 18:56:45.725462555 +0200
@@ -127,6 +127,14 @@
 /* hardware time stamping: parameters in linux/net_tstamp.h */
 #define SIOCSHWTSTAMP   0x89b0
 
+/* fbxdiverter call */
+#define SIOCGFBXDIVERT  0x89c0		/* fbxdiverter support          */
+#define SIOCSFBXDIVERT  0x89c1		/* Set fbxdiverter options      */
+
+/* fbxbridge call */
+#define SIOCGFBXBRIDGE	0x89b2		/* fbxbridge support          */
+#define SIOCSFBXBRIDGE	0x89b3		/* Set fbxbridge options      */
+
 /* Device private ioctl calls */
 
 /*
diff -ruw linux-2.6.39.4/include/linux/tty.h linux-2.6.39.4-fbx/include/linux/tty.h
--- linux-2.6.39.4/include/linux/tty.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/linux/tty.h	2011-06-15 18:56:45.745462611 +0200
@@ -5,26 +5,6 @@
  * 'tty.h' defines some structures used by tty_io.c and some defines.
  */
 
-#ifdef __KERNEL__
-#include <linux/fs.h>
-#include <linux/major.h>
-#include <linux/termios.h>
-#include <linux/workqueue.h>
-#include <linux/tty_driver.h>
-#include <linux/tty_ldisc.h>
-#include <linux/mutex.h>
-
-#include <asm/system.h>
-
-
-/*
- * (Note: the *_driver.minor_start values 1, 64, 128, 192 are
- * hardcoded at present.)
- */
-#define NR_UNIX98_PTY_DEFAULT	4096      /* Default maximum for Unix98 ptys */
-#define NR_UNIX98_PTY_MAX	(1 << MINORBITS) /* Absolute limit */
-#define NR_LDISCS		30
-
 /* line disciplines */
 #define N_TTY		0
 #define N_SLIP		1
@@ -50,6 +30,28 @@
 #define N_CAIF		20      /* CAIF protocol for talking to modems */
 #define N_GSM0710	21	/* GSM 0710 Mux */
 #define N_TI_WL		22	/* for TI's WL BT, FM, GPS combo chips */
+#define N_REMOTI	23	/* RemoTI over UART */
+
+
+#ifdef __KERNEL__
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/termios.h>
+#include <linux/workqueue.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_ldisc.h>
+#include <linux/mutex.h>
+
+#include <asm/system.h>
+
+
+/*
+ * (Note: the *_driver.minor_start values 1, 64, 128, 192 are
+ * hardcoded at present.)
+ */
+#define NR_UNIX98_PTY_DEFAULT	4096      /* Default maximum for Unix98 ptys */
+#define NR_UNIX98_PTY_MAX	(1 << MINORBITS) /* Absolute limit */
+#define NR_LDISCS		30
 
 /*
  * This character is the same as _POSIX_VDISABLE: it cannot be used as
diff -ruw linux-2.6.39.4/include/net/ip.h linux-2.6.39.4-fbx/include/net/ip.h
--- linux-2.6.39.4/include/net/ip.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/net/ip.h	2011-06-15 18:56:45.765462667 +0200
@@ -407,6 +407,14 @@
 int ip_frag_nqueues(struct net *net);
 
 /*
+ *     Functions provided by ip_ffn.c
+ */
+extern void ip_ffn_init(void);
+extern int ip_ffn_process(struct sk_buff *skb);
+extern void ip_ffn_add(struct sk_buff *skb);
+extern void ip_ffn_flush_all(void);
+
+/*
  *	Functions provided by ip_forward.c
  */
  
diff -ruw linux-2.6.39.4/include/sound/pcm.h linux-2.6.39.4-fbx/include/sound/pcm.h
--- linux-2.6.39.4/include/sound/pcm.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/include/sound/pcm.h	2011-08-30 20:03:46.426611452 +0200
@@ -1033,6 +1033,8 @@
 
 #define snd_pcm_lib_mmap_vmalloc NULL
 
+int snd_pcm_default_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *area);
+
 static inline void snd_pcm_limit_isa_dma_size(int dma, size_t *max)
 {
 	*max = dma < 4 ? 64 * 1024 : 128 * 1024;
diff -ruw linux-2.6.39.4/init/do_mounts.c linux-2.6.39.4-fbx/init/do_mounts.c
--- linux-2.6.39.4/init/do_mounts.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/init/do_mounts.c	2011-09-09 16:11:25.400446434 +0200
@@ -17,6 +17,10 @@
 #include <linux/fs_struct.h>
 #include <linux/slab.h>
 
+#ifdef CONFIG_DMCRYPTATBOOT
+#include <linux/dm-ioctl.h>
+#endif
+
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>
 #include <linux/nfs_mount.h>
@@ -431,6 +435,121 @@
 #endif
 }
 
+#ifdef CONFIG_DMCRYPTATBOOT
+/*
+ * Create dm device
+ */
+long dm_ctl_ioctl(struct file *file, uint command, ulong u);
+
+static int dm_run_setup(void)
+{
+	struct dm_ioctl dm, *dmp;
+	struct dm_target_spec *spec;
+	uint64_t size;
+	char *data, *tmp, *major, *minor;
+	uint8_t *target_info;
+	dev_t tomap;
+	int ret, fd;
+	uint8_t key[128];
+
+	/* read config */
+	ret = -EINVAL;
+	tmp = CONFIG_DMCRYPTATBOOT_DEVICE;
+	major = minor = NULL;
+	if (tmp)
+		major = strsep(&tmp, ":");
+	if (tmp)
+		minor = strsep(&tmp, ":");
+	if (!major || !minor)
+		goto end;
+
+	/* create device to map */
+	tomap = MKDEV(simple_strtoul(major, NULL, 10),
+		      simple_strtoul(minor, NULL, 10));
+	if (create_dev("/dev/tomap", tomap))
+		goto end;
+
+	fd = sys_open("/dev/tomap", 0, 0);
+	if (fd < 0)
+		goto end;
+
+	/* fetch its size */
+	if (sys_ioctl(fd, BLKGETSIZE64, (unsigned long)&size)) {
+		sys_close(fd);
+		goto end;
+	}
+	sys_close(fd);
+	size /= 512;
+
+	/* create dm device */
+	memset(&dm, 0, sizeof (dm));
+	dm.version[0] = DM_VERSION_MAJOR;
+	dm.version[1] = DM_VERSION_MINOR;
+	dm.version[2] = DM_VERSION_PATCHLEVEL;
+	dm.data_size = sizeof (dm);
+	strcpy(dm.name, "root");
+
+	ret = dm_ctl_ioctl(NULL, DM_DEV_CREATE, (ulong)&dm);
+	if (ret < 0) {
+		printk("dm_ctl_ioctl create failed\n");
+		goto end;
+	}
+
+	/* create table */
+	data = kmalloc(sizeof (*dmp) + sizeof (*spec) + 128, GFP_KERNEL);
+	if (!data)
+		goto end;
+	dmp = (struct dm_ioctl *)data;
+	spec = (struct dm_target_spec *)(dmp + 1);
+	target_info = (uint8_t *)(spec + 1);
+
+	memset(dmp, 0, sizeof (*dmp));
+	dmp->version[0] = DM_VERSION_MAJOR;
+	dmp->version[1] = DM_VERSION_MINOR;
+	dmp->version[2] = DM_VERSION_PATCHLEVEL;
+	dmp->data_size = sizeof (*dmp) + sizeof (*spec) + 128;
+	dmp->data_start = sizeof (*dmp);
+	dmp->target_count = 1;
+	strcpy(dmp->name, "root");
+
+	memset(spec, 0, sizeof (*spec));
+	spec->sector_start = 0;
+	spec->length = size;
+	strcpy(spec->target_type, "crypt");
+
+	strcpy(key, CONFIG_DMCRYPTATBOOT_KEY);
+
+	memset(target_info, 0, 128);
+	snprintf((char *)target_info, 128, "%s %s 0 /dev/tomap 0",
+		 CONFIG_DMCRYPTATBOOT_CIPHER, key);
+	target_info[127] = 0;
+
+	ret = dm_ctl_ioctl(NULL, DM_TABLE_LOAD, (ulong)data);
+	if (ret < 0) {
+		printk("dm_ctl_ioctl table load failed\n");
+		goto end;
+	}
+
+	/* resume device */
+	memset(&dm, 0, sizeof (dm));
+	dm.version[0] = DM_VERSION_MAJOR;
+	dm.version[1] = DM_VERSION_MINOR;
+	dm.version[2] = DM_VERSION_PATCHLEVEL;
+	dm.data_size = sizeof (dm);
+	strcpy(dm.name, "root");
+
+	ret = dm_ctl_ioctl(NULL, DM_DEV_SUSPEND, (ulong)&dm);
+	if (ret < 0) {
+		printk("dm_ctl_ioctl resume failed\n");
+		goto end;
+	}
+
+	strcpy(saved_root_name, "/dev/dm-0");
+end:
+	return ret;
+}
+#endif
+
 /*
  * Prepare the namespace - decide what/where to mount, load ramdisks, etc.
  */
@@ -455,6 +574,16 @@
 
 	md_run_setup();
 
+#ifdef CONFIG_DMCRYPTATBOOT
+#ifdef CONFIG_DMCRYPTATBOOT_ONLY
+	if (dm_run_setup() != 0)
+		/* disallow other root= value */
+		saved_root_name[0] = 0;
+#else
+	dm_run_setup();
+#endif
+#endif
+
 	if (saved_root_name[0]) {
 		root_device_name = saved_root_name;
 		if (!strncmp(root_device_name, "mtd", 3) ||
diff -ruw linux-2.6.39.4/init/initramfs.c linux-2.6.39.4-fbx/init/initramfs.c
--- linux-2.6.39.4/init/initramfs.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/init/initramfs.c	2011-06-15 18:56:45.805462779 +0200
@@ -592,6 +592,16 @@
 		fd = sys_open((const char __user __force *) "/initrd.image",
 			      O_WRONLY|O_CREAT, 0700);
 		if (fd >= 0) {
+#ifdef CONFIG_FBX_DECRYPT_INITRD
+			int err;
+			extern int fbx_decrypt_initrd(char *start,
+						      u32 size);
+
+			err = fbx_decrypt_initrd((char*)initrd_start,
+						 initrd_end - initrd_start);
+			if (err)
+				printk(KERN_ERR "Decrypt failed: %i\n", err);
+#endif
 			sys_write(fd, (char *)initrd_start,
 					initrd_end - initrd_start);
 			sys_close(fd);
diff -ruw linux-2.6.39.4/init/Kconfig linux-2.6.39.4-fbx/init/Kconfig
--- linux-2.6.39.4/init/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/init/Kconfig	2011-06-15 18:56:45.805462779 +0200
@@ -557,6 +557,41 @@
 		     13 =>  8 KB
 		     12 =>  4 KB
 
+
+config DMCRYPTATBOOT
+	bool "Create device-mapper crypt target before root"
+	depends on DM_CRYPT
+	default n
+
+config DMCRYPTATBOOT_DEVICE
+	string "Device major:minor"
+	depends on DMCRYPTATBOOT
+
+config DMCRYPTATBOOT_CIPHER
+	string "Cipher"
+	depends on DMCRYPTATBOOT
+
+config DMCRYPTATBOOT_KEY
+	string "Key"
+	depends on DMCRYPTATBOOT
+
+config DMCRYPTATBOOT_KEY_DECRYPT
+	string "Decryption key"
+	depends on DMCRYPTATBOOT
+
+config DMCRYPTATBOOT_ONLY
+	bool "Refuse to mount something else"
+	depends on DMCRYPTATBOOT
+
+config FBX_DECRYPT_INITRD
+	bool "Decrypt initrd at boot"
+	depends on BLK_DEV_RAM
+	default n
+
+config FBX_DECRYPT_INITRD_KEY
+	string "Decryption key"
+	depends on FBX_DECRYPT_INITRD
+
 #
 # Architectures with an unreliable sched_clock() should select this:
 #
diff -ruw linux-2.6.39.4/init/Makefile linux-2.6.39.4-fbx/init/Makefile
--- linux-2.6.39.4/init/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/init/Makefile	2011-09-09 16:11:25.390446439 +0200
@@ -10,11 +10,17 @@
 endif
 obj-$(CONFIG_GENERIC_CALIBRATE_DELAY) += calibrate.o
 
+obj-$(CONFIG_FBX_DECRYPT_INITRD)+= fbx_decrypt_initrd.o rc4.o
+
 mounts-y			:= do_mounts.o
 mounts-$(CONFIG_BLK_DEV_RAM)	+= do_mounts_rd.o
 mounts-$(CONFIG_BLK_DEV_INITRD)	+= do_mounts_initrd.o
 mounts-$(CONFIG_BLK_DEV_MD)	+= do_mounts_md.o
 
+
+# files to be removed upon make clean
+clean-files := ../include/linux/compile.h dmcryptatboot_decrypt.c
+
 # dependencies on generated files need to be listed explicitly
 $(obj)/version.o: include/generated/compile.h
 
diff -ruw linux-2.6.39.4/kernel/pid.c linux-2.6.39.4-fbx/kernel/pid.c
--- linux-2.6.39.4/kernel/pid.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/kernel/pid.c	2011-06-15 18:56:45.835462863 +0200
@@ -79,7 +79,7 @@
 	.level = 0,
 	.child_reaper = &init_task,
 };
-EXPORT_SYMBOL_GPL(init_pid_ns);
+EXPORT_SYMBOL(init_pid_ns);
 
 int is_container_init(struct task_struct *tsk)
 {
diff -ruw linux-2.6.39.4/kernel/printk.c linux-2.6.39.4-fbx/kernel/printk.c
--- linux-2.6.39.4/kernel/printk.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/kernel/printk.c	2011-06-15 18:56:45.835462863 +0200
@@ -52,6 +52,10 @@
 
 #define __LOG_BUF_LEN	(1 << CONFIG_LOG_BUF_SHIFT)
 
+#ifdef CONFIG_DEBUG_LL
+extern void printascii(char *);
+#endif
+
 /* printk's without a loglevel use this.. */
 #define DEFAULT_MESSAGE_LOGLEVEL CONFIG_DEFAULT_MESSAGE_LOGLEVEL
 
@@ -298,6 +302,29 @@
 	return 0;
 }
 
+/*
+ * dump log buffer content in given buffer
+ */
+void console_emergency_dump(char *buf, int *len)
+{
+	int i, limit;
+
+	if (*len > log_buf_len)
+		*len = log_buf_len;
+	if (*len > logged_chars)
+		*len = logged_chars;
+	limit = log_end;
+
+	for (i = 0; i < *len; i++) {
+		int j;
+
+		j = limit - 1 -i;
+		if (j + log_buf_len < log_end)
+			break;
+		buf[*len - 1 - i] = LOG_BUF(j);
+	}
+}
+
 int do_syslog(int type, char __user *buf, int len, bool from_file)
 {
 	unsigned i, j, limit, count;
@@ -843,6 +870,10 @@
 	printed_len += vscnprintf(printk_buf + printed_len,
 				  sizeof(printk_buf) - printed_len, fmt, args);
 
+#ifdef CONFIG_DEBUG_LL
+	printascii(printk_buf);
+#endif
+
 	p = printk_buf;
 
 	/* Read log level and handle special printk prefix */
diff -ruw linux-2.6.39.4/kernel/sysctl.c linux-2.6.39.4-fbx/kernel/sysctl.c
--- linux-2.6.39.4/kernel/sysctl.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/kernel/sysctl.c	2011-09-09 16:11:25.400446434 +0200
@@ -197,6 +197,21 @@
 
 #endif
 
+/* Return standard mode bits for table entry. */
+static int sysctl_permissions(struct ctl_table_root *root,
+			       struct nsproxy *nsproxy,
+			       struct ctl_table *table)
+{
+	/* Allow system administrator to have same access as root. */
+	if (capable(CAP_SYS_ADMIN)) {
+		int mode = (table->mode >> 6) & 7;
+		return (mode << 6) | (mode << 3) | mode;
+	}
+
+	/* read-only otherwise */
+	return table->mode & ~0222;
+}
+
 static struct ctl_table root_table[];
 static struct ctl_table_root sysctl_table_root;
 static struct ctl_table_header root_table_header = {
@@ -209,6 +224,7 @@
 static struct ctl_table_root sysctl_table_root = {
 	.root_list = LIST_HEAD_INIT(sysctl_table_root.root_list),
 	.default_set.list = LIST_HEAD_INIT(root_table_header.ctl_entry),
+	.permissions = sysctl_permissions,
 };
 
 static struct ctl_table kern_table[];
diff -ruw linux-2.6.39.4/lib/Kconfig linux-2.6.39.4-fbx/lib/Kconfig
--- linux-2.6.39.4/lib/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/lib/Kconfig	2011-06-15 18:56:45.865462947 +0200
@@ -272,4 +272,7 @@
 
 	  If unsure, say N.
 
+config FBXSERIAL
+	bool
+
 endmenu
diff -ruw linux-2.6.39.4/lib/Makefile linux-2.6.39.4-fbx/lib/Makefile
--- linux-2.6.39.4/lib/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/lib/Makefile	2011-06-15 18:56:45.865462947 +0200
@@ -88,6 +88,8 @@
 obj-$(CONFIG_SMP) += percpu_counter.o
 obj-$(CONFIG_AUDIT_GENERIC) += audit.o
 
+obj-$(CONFIG_FBXSERIAL) += fbxserial.o
+
 obj-$(CONFIG_SWIOTLB) += swiotlb.o
 obj-$(CONFIG_IOMMU_HELPER) += iommu-helper.o
 obj-$(CONFIG_FAULT_INJECTION) += fault-inject.o
diff -ruw linux-2.6.39.4/net/8021q/vlan.c linux-2.6.39.4-fbx/net/8021q/vlan.c
--- linux-2.6.39.4/net/8021q/vlan.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/8021q/vlan.c	2011-06-15 18:56:45.925463115 +0200
@@ -234,7 +234,7 @@
 /*  Attach a VLAN device to a mac address (ie Ethernet Card).
  *  Returns 0 if the device was created or a negative error code otherwise.
  */
-static int register_vlan_device(struct net_device *real_dev, u16 vlan_id)
+int register_vlan_device(struct net_device *real_dev, u16 vlan_id)
 {
 	struct net_device *new_dev;
 	struct net *net = dev_net(real_dev);
diff -ruw linux-2.6.39.4/net/8021q/vlan_core.c linux-2.6.39.4-fbx/net/8021q/vlan_core.c
--- linux-2.6.39.4/net/8021q/vlan_core.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/8021q/vlan_core.c	2011-08-30 20:03:22.326572233 +0200
@@ -23,7 +23,6 @@
 		return false;
 
 	skb->dev = vlan_dev;
-	skb->priority = vlan_get_ingress_priority(vlan_dev, skb->vlan_tci);
 	skb->vlan_tci = 0;
 
 	rx_stats = this_cpu_ptr(vlan_dev_info(vlan_dev)->vlan_pcpu_stats);
@@ -68,6 +67,9 @@
 int __vlan_hwaccel_rx(struct sk_buff *skb, struct vlan_group *grp,
 		      u16 vlan_tci, int polling)
 {
+	skb->priority = vlan_get_ingress_priority(skb->dev, vlan_tci);
+	skb->rx_class = skb->priority;
+
 	__vlan_hwaccel_put_tag(skb, vlan_tci);
 	return polling ? netif_receive_skb(skb) : netif_rx(skb);
 }
@@ -76,6 +78,9 @@
 gro_result_t vlan_gro_receive(struct napi_struct *napi, struct vlan_group *grp,
 			      unsigned int vlan_tci, struct sk_buff *skb)
 {
+	skb->priority = vlan_get_ingress_priority(skb->dev, vlan_tci);
+	skb->rx_class = skb->priority;
+
 	__vlan_hwaccel_put_tag(skb, vlan_tci);
 	return napi_gro_receive(napi, skb);
 }
diff -ruw linux-2.6.39.4/net/8021q/vlan_dev.c linux-2.6.39.4-fbx/net/8021q/vlan_dev.c
--- linux-2.6.39.4/net/8021q/vlan_dev.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/8021q/vlan_dev.c	2011-08-01 20:08:52.039022584 +0200
@@ -184,6 +184,7 @@
 		rx_stats->rx_bytes += skb->len;
 
 		skb->priority = vlan_get_ingress_priority(skb->dev, vlan_tci);
+		skb->rx_class = skb->priority;
 
 		pr_debug("%s: priority: %u for TCI: %hu\n",
 			 __func__, skb->priority, vlan_tci);
diff -ruw linux-2.6.39.4/net/core/dev.c linux-2.6.39.4-fbx/net/core/dev.c
--- linux-2.6.39.4/net/core/dev.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/core/dev.c	2011-06-15 18:56:45.955463199 +0200
@@ -133,6 +133,7 @@
 #include <linux/pci.h>
 #include <linux/inetdevice.h>
 #include <linux/cpu_rmap.h>
+#include <linux/kthread.h>
 
 #include "net-sysfs.h"
 
@@ -177,6 +178,19 @@
 static struct list_head ptype_base[PTYPE_HASH_SIZE] __read_mostly;
 static struct list_head ptype_all __read_mostly;	/* Taps */
 
+#ifdef CONFIG_NETRXTHREAD
+
+#define RXTHREAD_MAX_PROCESS    CONFIG_NETRXTHREAD_MAX_PROCESS
+#define RXTHREAD_MAX_PKTS       128
+
+static struct task_struct *krxd;
+static struct sk_buff_head krxd_pkt_queue[CONFIG_NETRXTHREAD_RX_QUEUE];
+static unsigned int krxd_stats_pkts[CONFIG_NETRXTHREAD_RX_QUEUE];
+static unsigned int krxd_stats_dropped[CONFIG_NETRXTHREAD_RX_QUEUE];
+static wait_queue_head_t krxd_wq;
+static unsigned int krxd_pkts_count;
+#endif
+
 /*
  * The @dev_base_head list is protected by @dev_base_lock and the rtnl
  * semaphore.
@@ -2832,6 +2846,23 @@
 	return NET_RX_DROP;
 }
 
+/* Start Freebox added code */
+#if defined(CONFIG_FREEBOX_DIVERTER) || defined(CONFIG_FREEBOX_DIVERTER_MODULE)
+int (*fbxdiverter_hook)(struct sk_buff *);
+
+static int handle_fbxdiverter(struct sk_buff *skb)
+{
+	/* try_module_get is missing here, so there is a race on
+	 * fbxdiverter module deletion */
+	if (!fbxdiverter_hook)
+		return 0;
+	return fbxdiverter_hook(skb);
+}
+
+EXPORT_SYMBOL(fbxdiverter_hook);
+#endif
+
+
 /**
  *	netif_rx	-	post buffer to the network code
  *	@skb: buffer to post
@@ -2967,6 +2998,36 @@
 EXPORT_SYMBOL_GPL(br_fdb_test_addr_hook);
 #endif
 
+#if defined(CONFIG_FREEBOX_BRIDGE) || defined(CONFIG_FREEBOX_BRIDGE_MODULE)
+struct sk_buff *(*fbxbridge_handle_frame_hook)(struct fbxbridge *p, struct sk_buff *skb);
+
+struct fbxbridge;
+
+static inline struct sk_buff *handle_fbxbridge(struct sk_buff *skb,
+					       struct packet_type **pt_prev, int *ret,
+					       struct net_device *orig_dev)
+{
+	struct fbxbridge *fbxbr;
+
+	if (skb->pkt_type == PACKET_LOOPBACK ||
+	    (fbxbr = skb->dev->fbx_bridge_port) == NULL)
+		return skb;
+
+	if (skb->protocol != __constant_htons(ETH_P_IP) &&
+	    skb->protocol != __constant_htons(ETH_P_ARP))
+		return skb;
+
+	if (*pt_prev) {
+		*ret = deliver_skb(skb, *pt_prev, orig_dev);
+		*pt_prev = NULL;
+	}
+
+	return fbxbridge_handle_frame_hook(fbxbr, skb);
+}
+#else
+#define handle_fbxbridge(skb, pt_prev, ret, orig_dev)   (skb)
+#endif
+
 #ifdef CONFIG_NET_CLS_ACT
 /* TODO: Maybe we should just force sch_ingress to be compiled in
  * when CONFIG_NET_CLS_ACT is? otherwise some useless instructions
@@ -3097,7 +3158,9 @@
 	}
 }
 
-static int __netif_receive_skb(struct sk_buff *skb)
+static int __netif_receive_skb(struct sk_buff *skb);
+
+static int __netif_receive_skb_end(struct sk_buff *skb)
 {
 	struct packet_type *ptype, *pt_prev;
 	rx_handler_func_t *rx_handler;
@@ -3107,23 +3170,6 @@
 	int ret = NET_RX_DROP;
 	__be16 type;
 
-	if (!netdev_tstamp_prequeue)
-		net_timestamp_check(skb);
-
-	trace_netif_receive_skb(skb);
-
-	/* if we've gotten here through NAPI, check netpoll */
-	if (netpoll_receive_skb(skb))
-		return NET_RX_DROP;
-
-	if (!skb->skb_iif)
-		skb->skb_iif = skb->dev->ifindex;
-	orig_dev = skb->dev;
-
-	skb_reset_network_header(skb);
-	skb_reset_transport_header(skb);
-	skb->mac_len = skb->network_header - skb->mac_header;
-
 	pt_prev = NULL;
 
 	rcu_read_lock();
@@ -3139,6 +3185,8 @@
 	}
 #endif
 
+	orig_dev = skb->dev;
+
 	list_for_each_entry_rcu(ptype, &ptype_all, list) {
 		if (!ptype->dev || ptype->dev == skb->dev) {
 			if (pt_prev)
@@ -3147,6 +3195,10 @@
 		}
 	}
 
+	skb = handle_fbxbridge(skb, &pt_prev, &ret, orig_dev);
+	if (!skb)
+		goto out;
+
 #ifdef CONFIG_NET_CLS_ACT
 	skb = handle_ing(skb, &pt_prev, &ret, orig_dev);
 	if (!skb)
@@ -3154,6 +3206,18 @@
 ncls:
 #endif
 
+	if (vlan_tx_tag_present(skb)) {
+		if (pt_prev) {
+			ret = deliver_skb(skb, pt_prev, orig_dev);
+			pt_prev = NULL;
+		}
+		if (vlan_hwaccel_do_receive(&skb)) {
+			ret = __netif_receive_skb(skb);
+			goto out;
+		} else if (unlikely(!skb))
+			goto out;
+	}
+
 	rx_handler = rcu_dereference(skb->dev->rx_handler);
 	if (rx_handler) {
 		if (pt_prev) {
@@ -3174,18 +3238,6 @@
 		}
 	}
 
-	if (vlan_tx_tag_present(skb)) {
-		if (pt_prev) {
-			ret = deliver_skb(skb, pt_prev, orig_dev);
-			pt_prev = NULL;
-		}
-		if (vlan_hwaccel_do_receive(&skb)) {
-			ret = __netif_receive_skb(skb);
-			goto out;
-		} else if (unlikely(!skb))
-			goto out;
-	}
-
 	vlan_on_bond_hook(skb);
 
 	/* deliver only exact match when indicated */
@@ -3219,6 +3271,187 @@
 	return ret;
 }
 
+#ifdef CONFIG_NETRXTHREAD
+
+
+static int krxd_action(void *unused)
+{
+	struct sk_buff *skb;
+	unsigned int maxpkt_in_loop;
+
+	set_user_nice(current, -5);
+	current->flags |= PF_NOFREEZE;
+	__set_current_state(TASK_RUNNING);
+
+	maxpkt_in_loop = RXTHREAD_MAX_PROCESS;
+	while (1) {
+		unsigned int i, queue, count;
+
+		local_bh_disable();
+		count = CONFIG_NETRXTHREAD_RX_QUEUE;
+		for (i = 0; i < count; i++) {
+			queue = count - i - 1;
+			skb = skb_dequeue(&krxd_pkt_queue[queue]);
+			if (!skb)
+				continue;
+			krxd_pkts_count--;
+			break;
+		}
+
+		if (!skb) {
+			local_bh_enable();
+			wait_event_interruptible(krxd_wq,
+						 krxd_pkts_count != 0);
+			set_current_state(TASK_RUNNING);
+			maxpkt_in_loop = RXTHREAD_MAX_PROCESS;
+			continue;
+		}
+
+		__netif_receive_skb_end(skb);
+		local_bh_enable();
+
+		/* only schedule when working on lowest prio queue */
+		if (queue == 0) {
+			if (--maxpkt_in_loop == 0) {
+				maxpkt_in_loop = RXTHREAD_MAX_PROCESS;
+				schedule();
+			}
+		}
+	}
+	return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+/*
+ *	This is invoked by the /proc filesystem handler to display a device
+ *	in detail.
+ */
+void *krxthread_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	int *queue;
+
+	if (*pos > CONFIG_NETRXTHREAD_RX_QUEUE)
+		return NULL;
+
+	queue = kmalloc(sizeof(*queue), GFP_KERNEL);
+	if (!queue)
+		return NULL;
+	*queue = ((int)*pos - 1);
+
+	return queue;
+}
+
+void *krxthread_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	int *queue = v;
+
+	if (*pos == CONFIG_NETRXTHREAD_RX_QUEUE)
+		return NULL;
+
+	++*queue;
+	*pos = *queue + 1;
+	return queue;
+}
+
+void krxthread_seq_stop(struct seq_file *seq, void *v)
+{
+	kfree(v);
+}
+
+static void krxthread_seq_printf_stats(struct seq_file *seq, int queue)
+{
+	seq_printf(seq, "%8u %12u %12u\n",
+		   queue,
+		   krxd_stats_pkts[queue],
+		   krxd_stats_dropped[queue]);
+}
+
+static int krxthread_seq_show(struct seq_file *seq, void *v)
+{
+	int *queue = v;
+
+	if (*queue == -1)
+		seq_printf(seq, "%8s %12s %12s\n",
+			   "queue", "packets", "drops");
+	else
+		krxthread_seq_printf_stats(seq, *queue);
+	return 0;
+}
+
+static const struct seq_operations krxthread_seq_ops = {
+	.start = krxthread_seq_start,
+	.next  = krxthread_seq_next,
+	.stop  = krxthread_seq_stop,
+	.show  = krxthread_seq_show,
+};
+
+static int krxthread_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &krxthread_seq_ops);
+}
+
+static const struct file_operations krxthread_seq_fops = {
+	.owner	 = THIS_MODULE,
+	.open    = krxthread_seq_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release,
+};
+#endif /* PROCFS */
+#endif /* RXTHREAD */
+
+static int __netif_receive_skb(struct sk_buff *skb)
+{
+#ifdef CONFIG_NETRXTHREAD
+	unsigned int len, queue;
+#endif
+
+	if (!netdev_tstamp_prequeue)
+		net_timestamp_check(skb);
+
+	trace_netif_receive_skb(skb);
+
+	/* if we've gotten here through NAPI, check netpoll */
+	if (netpoll_receive_skb(skb))
+		return NET_RX_DROP;
+
+	if (!skb->skb_iif)
+		skb->skb_iif = skb->dev->ifindex;
+
+	skb_reset_network_header(skb);
+	skb_reset_transport_header(skb);
+	skb->mac_len = skb->network_header - skb->mac_header;
+
+#if defined(CONFIG_FREEBOX_DIVERTER) || defined(CONFIG_FREEBOX_DIVERTER_MODULE)
+	if (handle_fbxdiverter(skb))
+		return NET_RX_SUCCESS;
+#endif
+
+#ifndef CONFIG_NETRXTHREAD
+	return __netif_receive_skb_end(skb);
+#else
+	queue = skb->rx_class;
+	if (queue >= CONFIG_NETRXTHREAD_RX_QUEUE)
+		queue = CONFIG_NETRXTHREAD_RX_QUEUE - 1;
+
+	/* queue the packet to the rx thread */
+	local_bh_disable();
+	len = skb_queue_len(&krxd_pkt_queue[queue]);
+	if (len < RXTHREAD_MAX_PKTS) {
+		__skb_queue_tail(&krxd_pkt_queue[queue], skb);
+		krxd_pkts_count++;
+		krxd_stats_pkts[queue]++;
+		if (!len)
+			wake_up(&krxd_wq);
+	} else {
+		krxd_stats_dropped[queue]++;
+		dev_kfree_skb(skb);
+	}
+	local_bh_enable();
+	return NET_RX_SUCCESS;
+#endif
+}
+
 /**
  *	netif_receive_skb - process receive buffer from network
  *	@skb: buffer to process
@@ -4246,7 +4479,11 @@
 		goto out_dev;
 	if (!proc_net_fops_create(net, "ptype", S_IRUGO, &ptype_seq_fops))
 		goto out_softnet;
-
+#ifdef CONFIG_NETRXTHREAD
+	if (!proc_net_fops_create(net, "krxthread", S_IRUGO,
+				  &krxthread_seq_fops))
+		goto out;
+#endif
 	if (wext_proc_init(net))
 		goto out_ptype;
 	rc = 0;
@@ -5601,7 +5838,7 @@
 			rebroadcast_time = jiffies;
 		}
 
-		msleep(250);
+		msleep(1);
 
 		refcnt = netdev_refcnt_read(dev);
 
@@ -6455,6 +6692,19 @@
 	open_softirq(NET_TX_SOFTIRQ, net_tx_action);
 	open_softirq(NET_RX_SOFTIRQ, net_rx_action);
 
+#ifdef CONFIG_NETRXTHREAD
+	for (i = 0; i < CONFIG_NETRXTHREAD_RX_QUEUE; i++)
+		skb_queue_head_init(&krxd_pkt_queue[i]);
+	krxd_pkts_count = 0;
+	init_waitqueue_head(&krxd_wq);
+	krxd = kthread_create(krxd_action, NULL, "krxthread");
+	if (IS_ERR(krxd)) {
+		printk(KERN_ERR "unable to create krxd\n");
+		return -ENOMEM;
+	}
+	wake_up_process(krxd);
+#endif
+
 	hotcpu_notifier(dev_cpu_callback, 0);
 	dst_init();
 	dev_mcast_init();
@@ -6473,3 +6723,6 @@
 
 late_initcall_sync(initialize_hashrnd);
 
+#if defined(CONFIG_FREEBOX_BRIDGE_MODULE)
+EXPORT_SYMBOL(fbxbridge_handle_frame_hook);
+#endif
diff -ruw linux-2.6.39.4/net/core/skbuff.c linux-2.6.39.4-fbx/net/core/skbuff.c
--- linux-2.6.39.4/net/core/skbuff.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/core/skbuff.c	2011-06-15 18:56:45.965463227 +0200
@@ -526,7 +526,11 @@
 #if defined(CONFIG_IP_VS) || defined(CONFIG_IP_VS_MODULE)
 	new->ipvs_property	= old->ipvs_property;
 #endif
+#ifdef CONFIG_IP_FFN
+	new->ffn_state		= FFN_STATE_INIT;
+#endif
 	new->protocol		= old->protocol;
+	new->rx_class		= old->rx_class;
 	new->mark		= old->mark;
 	new->skb_iif		= old->skb_iif;
 	__nf_copy(new, old);
diff -ruw linux-2.6.39.4/net/ipv4/ipconfig.c linux-2.6.39.4-fbx/net/ipv4/ipconfig.c
--- linux-2.6.39.4/net/ipv4/ipconfig.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/ipv4/ipconfig.c	2011-06-15 18:56:45.985463283 +0200
@@ -188,16 +188,59 @@
 static struct ic_device *ic_first_dev __initdata = NULL;/* List of open device */
 static struct net_device *ic_dev __initdata = NULL;	/* Selected device */
 
-static bool __init ic_device_match(struct net_device *dev)
+static bool __init ic_device_match(struct net_device *dev, bool partial)
 {
+	char *p = NULL;
+	bool ret;
+
+	if (partial) {
+		p = strchr(user_dev_name, '.');
+		if (p)
+			*p = 0;
+	}
+
+	ret = false;
 	if (user_dev_name[0] ? !strcmp(dev->name, user_dev_name) :
 	    (!(dev->flags & IFF_LOOPBACK) &&
 	     (dev->flags & (IFF_POINTOPOINT|IFF_BROADCAST)) &&
 	     strncmp(dev->name, "dummy", 5)))
-		return true;
-	return false;
+		ret = true;
+	if (p)
+		*p = '.';
+	return ret;
 }
 
+#ifdef CONFIG_VLAN_8021Q
+int register_vlan_device(struct net_device *real_dev, u16 vlan_id);
+
+static void __init prepare_vlan(void)
+{
+	unsigned short oflags;
+	struct net_device *dev;
+	char *p;
+	u16 vid;
+
+	if (!strchr(user_dev_name, '.'))
+		return;
+
+	p = strchr(user_dev_name, '.');
+	*p = 0;
+	vid = simple_strtoul(p + 1, NULL, 10);
+	dev = __dev_get_by_name(&init_net, user_dev_name);
+	if (!dev)
+		goto fail;
+
+	oflags = dev->flags;
+	if (dev_change_flags(dev, oflags | IFF_UP) < 0)
+		goto fail;
+
+	register_vlan_device(dev, vid);
+
+fail:
+	*p = '.';
+}
+#endif
+
 static int __init ic_open_devs(void)
 {
 	struct ic_device *d, **last;
@@ -215,10 +258,15 @@
 			printk(KERN_ERR "IP-Config: Failed to open %s\n", dev->name);
 	}
 
+#ifdef CONFIG_VLAN_8021Q
+	/* register vlan device if needed */
+	prepare_vlan();
+#endif
+
 	for_each_netdev(&init_net, dev) {
 		if (dev->flags & IFF_LOOPBACK)
 			continue;
-		if (ic_device_match(dev)) {
+		if (ic_device_match(dev, false)) {
 			int able = 0;
 			if (dev->mtu >= 364)
 				able |= IC_BOOTP;
@@ -673,8 +721,10 @@
 			e += len;
 		}
 		if (*vendor_class_identifier) {
+#ifdef IPCONFIG_DEBUG
 			printk(KERN_INFO "DHCP: sending class identifier \"%s\"\n",
 			       vendor_class_identifier);
+#endif
 			*e++ = 60;	/* Class-identifier */
 			len = strlen(vendor_class_identifier);
 			*e++ = len;
@@ -1331,7 +1381,7 @@
 
 		rtnl_lock();
 		for_each_netdev(&init_net, dev) {
-			if (ic_device_match(dev)) {
+			if (ic_device_match(dev, true)) {
 				found = 1;
 				break;
 			}
diff -ruw linux-2.6.39.4/net/ipv4/ip_input.c linux-2.6.39.4-fbx/net/ipv4/ip_input.c
--- linux-2.6.39.4/net/ipv4/ip_input.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/ipv4/ip_input.c	2011-06-15 18:56:45.985463283 +0200
@@ -434,6 +434,11 @@
 		goto drop;
 	}
 
+#ifdef CONFIG_IP_FFN
+	if (!ip_ffn_process(skb))
+		return NET_RX_SUCCESS;
+#endif
+
 	/* Remove any debris in the socket control block */
 	memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
 
diff -ruw linux-2.6.39.4/net/ipv4/ip_output.c linux-2.6.39.4-fbx/net/ipv4/ip_output.c
--- linux-2.6.39.4/net/ipv4/ip_output.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/ipv4/ip_output.c	2011-06-15 18:56:45.985463283 +0200
@@ -203,6 +203,11 @@
 		skb = skb2;
 	}
 
+#ifdef CONFIG_IP_FFN
+	if (skb->ffn_state == FFN_STATE_FORWARDABLE)
+		ip_ffn_add(skb);
+#endif
+
 	if (dst->hh)
 		return neigh_hh_output(dst->hh, skb);
 	else if (dst->neighbour)
@@ -307,6 +312,11 @@
 	skb->dev = dev;
 	skb->protocol = htons(ETH_P_IP);
 
+#ifdef CONFIG_IP_FFN
+	if (skb->ffn_state == FFN_STATE_FAST_FORWARDED)
+		return ip_finish_output(skb);
+#endif
+
 	return NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING, skb, NULL, dev,
 			    ip_finish_output,
 			    !(IPCB(skb)->flags & IPSKB_REROUTED));
@@ -1525,4 +1535,7 @@
 #if defined(CONFIG_IP_MULTICAST) && defined(CONFIG_PROC_FS)
 	igmp_mc_proc_init();
 #endif
+#ifdef CONFIG_IP_FFN
+	ip_ffn_init();
+#endif
 }
diff -ruw linux-2.6.39.4/net/ipv4/Kconfig linux-2.6.39.4-fbx/net/ipv4/Kconfig
--- linux-2.6.39.4/net/ipv4/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/ipv4/Kconfig	2011-06-15 18:56:45.975463255 +0200
@@ -312,6 +312,11 @@
 
 	  If unsure, say N.
 
+config INET_XFRM_GC_THRESH
+	int "IP: xfrm garbage collect threshold"
+	depends on XFRM
+	default 1024
+
 config INET_AH
 	tristate "IP: AH transformation"
 	select XFRM
diff -ruw linux-2.6.39.4/net/ipv4/Makefile linux-2.6.39.4-fbx/net/ipv4/Makefile
--- linux-2.6.39.4/net/ipv4/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/ipv4/Makefile	2011-06-15 18:56:45.975463255 +0200
@@ -14,6 +14,8 @@
 	     inet_fragment.o
 
 obj-$(CONFIG_SYSCTL) += sysctl_net_ipv4.o
+
+obj-$(CONFIG_IP_FFN) += ip_ffn.o
 obj-$(CONFIG_PROC_FS) += proc.o
 obj-$(CONFIG_IP_MULTIPLE_TABLES) += fib_rules.o
 obj-$(CONFIG_IP_MROUTE) += ipmr.o
diff -ruw linux-2.6.39.4/net/ipv4/netfilter/ip_tables.c linux-2.6.39.4-fbx/net/ipv4/netfilter/ip_tables.c
--- linux-2.6.39.4/net/ipv4/netfilter/ip_tables.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/ipv4/netfilter/ip_tables.c	2011-06-15 18:56:45.985463283 +0200
@@ -1286,6 +1286,10 @@
 			   tmp.num_counters, tmp.counters);
 	if (ret)
 		goto free_newinfo_untrans;
+
+#ifdef CONFIG_IP_FFN
+	ip_ffn_flush_all();
+#endif
 	return 0;
 
  free_newinfo_untrans:
diff -ruw linux-2.6.39.4/net/ipv4/netfilter/Kconfig linux-2.6.39.4-fbx/net/ipv4/netfilter/Kconfig
--- linux-2.6.39.4/net/ipv4/netfilter/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/ipv4/netfilter/Kconfig	2011-06-15 18:56:45.985463283 +0200
@@ -5,6 +5,9 @@
 menu "IP: Netfilter Configuration"
 	depends on INET && NETFILTER
 
+config IP_FFN
+	bool "IP: Fast forwarding and NAT"
+
 config NF_DEFRAG_IPV4
 	tristate
 	default n
diff -ruw linux-2.6.39.4/net/ipv4/xfrm4_policy.c linux-2.6.39.4-fbx/net/ipv4/xfrm4_policy.c
--- linux-2.6.39.4/net/ipv4/xfrm4_policy.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/ipv4/xfrm4_policy.c	2011-06-15 18:56:46.005463339 +0200
@@ -228,7 +228,7 @@
 	.destroy =		xfrm4_dst_destroy,
 	.ifdown =		xfrm4_dst_ifdown,
 	.local_out =		__ip_local_out,
-	.gc_thresh =		1024,
+	.gc_thresh =		CONFIG_INET_XFRM_GC_THRESH,
 };
 
 static struct xfrm_policy_afinfo xfrm4_policy_afinfo = {
diff -ruw linux-2.6.39.4/net/ipv6/Kconfig linux-2.6.39.4-fbx/net/ipv6/Kconfig
--- linux-2.6.39.4/net/ipv6/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/ipv6/Kconfig	2011-05-24 18:15:57.345713113 +0200
@@ -192,6 +192,11 @@
 config IPV6_NDISC_NODETYPE
 	bool
 
+config IPV6_SIT_FBX6TO4
+	bool "sit support Freebox 6to4 scheme"
+	depends on IPV6_SIT
+	default n
+
 config IPV6_TUNNEL
 	tristate "IPv6: IP-in-IPv6 tunnel (RFC2473)"
 	select INET6_TUNNEL
diff -ruw linux-2.6.39.4/net/ipv6/sit.c linux-2.6.39.4-fbx/net/ipv6/sit.c
--- linux-2.6.39.4/net/ipv6/sit.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/ipv6/sit.c	2011-06-15 18:56:46.015463367 +0200
@@ -230,11 +230,20 @@
 		if (local == t->parms.iph.saddr &&
 		    remote == t->parms.iph.daddr &&
 		    parms->link == t->parms.link) {
+#ifdef CONFIG_IPV6_SIT_FBX6TO4
+			if (!memcmp(&parms->fbx6to4_zone,&t->parms.fbx6to4_zone,
+				    sizeof (parms->fbx6to4_zone)) &&
+			    parms->fbx6to4_prefix == t->parms.fbx6to4_prefix) {
+#endif
 			if (create)
 				return NULL;
 			else
 				return t;
+#ifdef CONFIG_IPV6_SIT_FBX6TO4
 		}
+#endif
+		}
+
 	}
 	if (!create)
 		goto failed;
@@ -654,6 +663,31 @@
 	return dst;
 }
 
+#ifdef CONFIG_IPV6_SIT_FBX6TO4
+/* Returns the embedded IPv4 address if the IPv6 address comes from
+   Freebox 6to4 rule */
+static inline __be32 try_fbx6to4(struct in6_addr *fbx6to4_zone,
+				 u8 fbx6to4_prefix, struct in6_addr *v6dst)
+{
+	__be32 dst = 0;
+
+	/* isolate zone according to mask */
+	if (ipv6_prefix_equal(v6dst, fbx6to4_zone, fbx6to4_prefix)) {
+		unsigned int d32_off, bits;
+
+		d32_off = fbx6to4_prefix >> 5;
+		bits = (fbx6to4_prefix & 0x1f);
+
+		dst = (ntohl(v6dst->s6_addr32[d32_off]) << bits);
+		if (bits)
+			dst |= ntohl(v6dst->s6_addr32[d32_off + 1]) >>
+				(32 - bits);
+		dst = htonl(dst);
+	}
+	return dst;
+}
+#endif
+
 /*
  *	This function assumes it is being called from dev_queue_xmit()
  *	and that skb is filled properly by that function.
@@ -703,6 +737,13 @@
 			goto tx_error;
 	}
 
+#ifdef CONFIG_IPV6_SIT_FBX6TO4
+	if (!dst && tunnel->parms.fbx6to4_prefix)
+		dst = try_fbx6to4(&tunnel->parms.fbx6to4_zone,
+				  tunnel->parms.fbx6to4_prefix,
+				  &iph6->daddr);
+	else
+#endif
 	if (!dst)
 		dst = try_6rd(&iph6->daddr, tunnel);
 
@@ -947,6 +988,13 @@
 		if (p.iph.ttl)
 			p.iph.frag_off |= htons(IP_DF);
 
+#ifdef CONFIG_IPV6_SIT_FBX6TO4
+		/* prefix must be smaller than 95 bits since we fetch
+		 * an ip address after them */
+		if (p.fbx6to4_prefix >= 95)
+			goto done;
+#endif
+
 		t = ipip6_tunnel_locate(net, &p, cmd == SIOCADDTUNNEL);
 
 		if (dev != sitn->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {
@@ -966,6 +1014,10 @@
 				synchronize_net();
 				t->parms.iph.saddr = p.iph.saddr;
 				t->parms.iph.daddr = p.iph.daddr;
+#ifdef CONFIG_IPV6_SIT_FBX6TO4
+				t->parms.fbx6to4_zone = p.fbx6to4_zone;
+				t->parms.fbx6to4_prefix = p.fbx6to4_prefix;
+#endif
 				memcpy(dev->dev_addr, &p.iph.saddr, 4);
 				memcpy(dev->broadcast, &p.iph.daddr, 4);
 				ipip6_tunnel_link(sitn, t);
diff -ruw linux-2.6.39.4/net/Kconfig linux-2.6.39.4-fbx/net/Kconfig
--- linux-2.6.39.4/net/Kconfig	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/Kconfig	2011-06-15 18:56:45.925463115 +0200
@@ -45,6 +45,23 @@
 
 menu "Networking options"
 
+config NETSKBPAD
+	int "Size reserved by dev_alloc_skb"
+	default 16
+
+config NETRXTHREAD
+	bool "Do rx network processing in kernel thread"
+
+config NETRXTHREAD_RX_QUEUE
+	int "Number of rx queues"
+	default 1
+	depends on NETRXTHREAD
+
+config NETRXTHREAD_MAX_PROCESS
+	int "Maximum number of packet to process before schedule"
+	default 4
+	depends on NETRXTHREAD
+
 source "net/packet/Kconfig"
 source "net/unix/Kconfig"
 source "net/xfrm/Kconfig"
@@ -197,6 +214,7 @@
 source "net/tipc/Kconfig"
 source "net/atm/Kconfig"
 source "net/l2tp/Kconfig"
+source "net/fbxatm/Kconfig"
 source "net/802/Kconfig"
 source "net/bridge/Kconfig"
 source "net/dsa/Kconfig"
diff -ruw linux-2.6.39.4/net/mac80211/ieee80211_i.h linux-2.6.39.4-fbx/net/mac80211/ieee80211_i.h
--- linux-2.6.39.4/net/mac80211/ieee80211_i.h	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/mac80211/ieee80211_i.h	2011-06-15 18:56:46.035463423 +0200
@@ -765,6 +765,9 @@
 
 	int tx_headroom; /* required headroom for hardware/radiotap */
 
+	/* count for keys needing tailroom space allocation */
+	int crypto_tx_tailroom_needed_cnt;
+
 	/* Tasklet and skb queue to process calls from IRQ mode. All frames
 	 * added to skb_queue will be processed, but frames in
 	 * skb_queue_unreliable may be dropped if the total length of these
diff -ruw linux-2.6.39.4/net/mac80211/key.c linux-2.6.39.4-fbx/net/mac80211/key.c
--- linux-2.6.39.4/net/mac80211/key.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/mac80211/key.c	2011-06-15 18:56:46.045463451 +0200
@@ -101,6 +101,11 @@
 
 	if (!ret) {
 		key->flags |= KEY_FLAG_UPLOADED_TO_HARDWARE;
+
+		if (!((key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_MMIC) ||
+		      (key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV)))
+			key->local->crypto_tx_tailroom_needed_cnt--;
+
 		return 0;
 	}
 
@@ -156,6 +161,10 @@
 			  key->conf.keyidx, sta ? sta->addr : bcast_addr, ret);
 
 	key->flags &= ~KEY_FLAG_UPLOADED_TO_HARDWARE;
+
+	if (!((key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_MMIC) ||
+	      (key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV)))
+		key->local->crypto_tx_tailroom_needed_cnt++;
 }
 
 void ieee80211_key_removed(struct ieee80211_key_conf *key_conf)
@@ -388,8 +397,10 @@
 		ieee80211_aes_key_free(key->u.ccmp.tfm);
 	if (key->conf.cipher == WLAN_CIPHER_SUITE_AES_CMAC)
 		ieee80211_aes_cmac_key_free(key->u.aes_cmac.tfm);
-	if (key->local)
+	if (key->local) {
 		ieee80211_debugfs_key_remove(key);
+		key->local->crypto_tx_tailroom_needed_cnt--;
+	}
 
 	kfree(key);
 }
@@ -451,6 +462,8 @@
 
 	ieee80211_debugfs_key_add(key);
 
+	key->local->crypto_tx_tailroom_needed_cnt++;
+
 	ret = ieee80211_key_enable_hw_accel(key);
 
 	mutex_unlock(&sdata->local->key_mtx);
@@ -492,8 +505,12 @@
 
 	mutex_lock(&sdata->local->key_mtx);
 
-	list_for_each_entry(key, &sdata->key_list, list)
+	sdata->local->crypto_tx_tailroom_needed_cnt = 0;
+
+	list_for_each_entry(key, &sdata->key_list, list) {
+		sdata->local->crypto_tx_tailroom_needed_cnt++;
 		ieee80211_key_enable_hw_accel(key);
+	}
 
 	mutex_unlock(&sdata->local->key_mtx);
 }
diff -ruw linux-2.6.39.4/net/mac80211/main.c linux-2.6.39.4-fbx/net/mac80211/main.c
--- linux-2.6.39.4/net/mac80211/main.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/mac80211/main.c	2011-06-15 18:56:46.045463451 +0200
@@ -838,6 +838,8 @@
 	if (!local->ops->remain_on_channel)
 		local->hw.wiphy->max_remain_on_channel_duration = 5000;
 
+	rtnl_lock();
+
 	result = wiphy_register(local->hw.wiphy);
 	if (result < 0)
 		goto fail_wiphy_register;
@@ -888,8 +890,6 @@
 		wiphy_debug(local->hw.wiphy, "Failed to initialize wep: %d\n",
 			    result);
 
-	rtnl_lock();
-
 	result = ieee80211_init_rate_ctrl_alg(local,
 					      hw->rate_control_algorithm);
 	if (result < 0) {
@@ -942,7 +942,6 @@
 	ieee80211_led_exit(local);
 	ieee80211_remove_interfaces(local);
  fail_rate:
-	rtnl_unlock();
 	ieee80211_wep_free(local);
 	sta_info_stop(local);
  fail_sta_info:
@@ -950,6 +949,7 @@
  fail_workqueue:
 	wiphy_unregister(local->hw.wiphy);
  fail_wiphy_register:
+	rtnl_unlock();
 	if (local->wiphy_ciphers_allocated)
 		kfree(local->hw.wiphy->cipher_suites);
 	kfree(local->int_scan_req);
diff -ruw linux-2.6.39.4/net/mac80211/tx.c linux-2.6.39.4-fbx/net/mac80211/tx.c
--- linux-2.6.39.4/net/mac80211/tx.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/mac80211/tx.c	2011-06-15 18:56:46.045463451 +0200
@@ -1486,12 +1486,7 @@
 {
 	int tail_need = 0;
 
-	/*
-	 * This could be optimised, devices that do full hardware
-	 * crypto (including TKIP MMIC) need no tailroom... But we
-	 * have no drivers for such devices currently.
-	 */
-	if (may_encrypt) {
+	if (may_encrypt && local->crypto_tx_tailroom_needed_cnt) {
 		tail_need = IEEE80211_ENCRYPT_TAILROOM;
 		tail_need -= skb_tailroom(skb);
 		tail_need = max_t(int, tail_need, 0);
diff -ruw linux-2.6.39.4/net/Makefile linux-2.6.39.4-fbx/net/Makefile
--- linux-2.6.39.4/net/Makefile	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/Makefile	2011-06-15 18:56:45.925463115 +0200
@@ -39,6 +39,9 @@
 obj-$(CONFIG_AF_RXRPC)		+= rxrpc/
 obj-$(CONFIG_ATM)		+= atm/
 obj-$(CONFIG_L2TP)		+= l2tp/
+ifneq ($(CONFIG_FBXATM),)
+obj-y				+= fbxatm/
+endif
 obj-$(CONFIG_DECNET)		+= decnet/
 obj-$(CONFIG_ECONET)		+= econet/
 obj-$(CONFIG_PHONET)		+= phonet/
diff -ruw linux-2.6.39.4/net/netfilter/core.c linux-2.6.39.4-fbx/net/netfilter/core.c
--- linux-2.6.39.4/net/netfilter/core.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/netfilter/core.c	2011-07-19 15:41:05.604933495 +0200
@@ -151,7 +151,7 @@
 	}
 	return NF_ACCEPT;
 }
-
+EXPORT_SYMBOL(nf_iterate);
 
 /* Returns 1 if okfn() needs to be executed by the caller,
  * -EPERM for NF_DROP, 0 otherwise. */
diff -ruw linux-2.6.39.4/net/netfilter/nf_conntrack_core.c linux-2.6.39.4-fbx/net/netfilter/nf_conntrack_core.c
--- linux-2.6.39.4/net/netfilter/nf_conntrack_core.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/netfilter/nf_conntrack_core.c	2011-06-15 18:56:46.065463507 +0200
@@ -185,6 +185,10 @@
 	nf_ct_remove_expectations(ct);
 }
 
+#ifdef CONFIG_IP_FFN
+extern void ip_ffn_ct_destroy(struct nf_conn *ct);
+#endif
+
 static void
 destroy_conntrack(struct nf_conntrack *nfct)
 {
@@ -196,6 +200,10 @@
 	NF_CT_ASSERT(atomic_read(&nfct->use) == 0);
 	NF_CT_ASSERT(!timer_pending(&ct->timeout));
 
+#ifdef CONFIG_IP_FFN
+	ip_ffn_ct_destroy(ct);
+#endif
+
 	/* To make sure we don't get any weird locking issues here:
 	 * destroy_conntrack() MUST NOT be called with a write lock
 	 * to nf_conntrack_lock!!! -HW */
diff -ruw linux-2.6.39.4/net/netfilter/nf_conntrack_ftp.c linux-2.6.39.4-fbx/net/netfilter/nf_conntrack_ftp.c
--- linux-2.6.39.4/net/netfilter/nf_conntrack_ftp.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/netfilter/nf_conntrack_ftp.c	2011-06-15 18:56:46.065463507 +0200
@@ -26,6 +26,11 @@
 #include <net/netfilter/nf_conntrack_helper.h>
 #include <linux/netfilter/nf_conntrack_ftp.h>
 
+#if defined(CONFIG_FREEBOX_BRIDGE) || defined(CONFIG_FREEBOX_BRIDGE_MODULE)
+#include <net/netfilter/nf_nat_helper.h>
+#include <fbxbridge.h>
+#endif
+
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Rusty Russell <rusty@rustcorp.com.au>");
 MODULE_DESCRIPTION("ftp connection tracking helper");
@@ -373,6 +378,17 @@
 		return NF_ACCEPT;
 	}
 
+#if defined(CONFIG_FREEBOX_BRIDGE) || defined(CONFIG_FREEBOX_BRIDGE_MODULE)
+	if (!ct_ftp_info->is_fbxbridge && skb->dev->fbx_bridge) {
+		struct fbxbridge *fbxbr;
+
+		fbxbr = skb->dev->fbx_bridge;
+		ct_ftp_info->is_fbxbridge = 1;
+		ct_ftp_info->fbxbridge_remote = ntohl(fbxbr->br_remote_ipaddr);
+		ct_ftp_info->fbxbridge_wan = fbxbr->wan_ipaddr;
+	}
+#endif
+
 	th = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);
 	if (th == NULL)
 		return NF_ACCEPT;
@@ -451,6 +467,50 @@
 	 * Doesn't matter unless NAT is happening.  */
 	daddr = &ct->tuplehash[!dir].tuple.dst.u3;
 
+#if defined(CONFIG_FREEBOX_BRIDGE) || defined(CONFIG_FREEBOX_BRIDGE_MODULE)
+	if (ct_ftp_info->is_fbxbridge &&
+	    search[dir][i].ftptype == NF_CT_FTP_PORT) {
+		unsigned long orig_ip_addr;
+		unsigned short orig_port;
+		char buffer[sizeof("nnn,nnn,nnn,nnn,nnn,nnn")];
+		unsigned int len;
+		__be32 addr;
+
+		/* kludge: if  we are here,  then this is a  local pkt
+		 * that has  gone through internal  fbxbridge snat.
+		 *
+		 * If we see a port  command, then we mangle packet to
+		 * change  ip  address  given  to  the  remote  bridge
+		 * address */
+
+		/* check  address  is  packet  is  the  one  fbxbridge
+		 * changed */
+		orig_ip_addr = cmd.u3.ip;
+		if (orig_ip_addr != ct_ftp_info->fbxbridge_wan)
+			goto donttouch;
+
+		/* now mangle the remote address */
+		orig_port = cmd.u.tcp.port;
+		addr = ct_ftp_info->fbxbridge_remote;
+		len = sprintf(buffer, "%u,%u,%u,%u,%u,%u",
+			      ((unsigned char *)&addr)[0],
+			      ((unsigned char *)&addr)[1],
+			      ((unsigned char *)&addr)[2],
+			      ((unsigned char *)&addr)[3],
+			      orig_port >> 8 , orig_port & 0xFF);
+
+		nf_nat_mangle_tcp_packet(skb, ct, ctinfo, matchoff,
+					 matchlen, buffer, len);
+
+		/* then adjust as if nothing happened */
+		matchlen = len;
+		cmd.u3.ip = ct_ftp_info->fbxbridge_remote;
+	}
+donttouch:
+
+#endif
+
+
 	/* Update the ftp info */
 	if ((cmd.l3num == nf_ct_l3num(ct)) &&
 	    memcmp(&cmd.u3.all, &ct->tuplehash[dir].tuple.src.u3.all,
diff -ruw linux-2.6.39.4/net/netfilter/nf_conntrack_proto_tcp.c linux-2.6.39.4-fbx/net/netfilter/nf_conntrack_proto_tcp.c
--- linux-2.6.39.4/net/netfilter/nf_conntrack_proto_tcp.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/netfilter/nf_conntrack_proto_tcp.c	2011-06-15 18:56:46.065463507 +0200
@@ -1052,6 +1052,17 @@
 	return NF_ACCEPT;
 }
 
+#ifdef CONFIG_IP_FFN
+int external_tcpv4_packet(struct nf_conn *ct,
+			  const struct sk_buff *skb,
+			  unsigned int dataoff,
+			  enum ip_conntrack_info ctinfo)
+{
+	return tcp_packet(ct, skb, dataoff, ctinfo, AF_INET, 0);
+}
+#endif
+
+
 /* Called when a new connection for this protocol found. */
 static bool tcp_new(struct nf_conn *ct, const struct sk_buff *skb,
 		    unsigned int dataoff)
diff -ruw linux-2.6.39.4/net/netfilter/nf_conntrack_proto_udp.c linux-2.6.39.4-fbx/net/netfilter/nf_conntrack_proto_udp.c
--- linux-2.6.39.4/net/netfilter/nf_conntrack_proto_udp.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/netfilter/nf_conntrack_proto_udp.c	2011-05-24 18:15:57.395712906 +0200
@@ -84,6 +84,16 @@
 	return NF_ACCEPT;
 }
 
+#ifdef CONFIG_IP_FFN
+int external_udpv4_packet(struct nf_conn *ct,
+			  const struct sk_buff *skb,
+			  unsigned int dataoff,
+			  enum ip_conntrack_info ctinfo)
+{
+	return udp_packet(ct, skb, dataoff, ctinfo, AF_INET, 0);
+}
+#endif
+
 /* Called when a new connection for this protocol found. */
 static bool udp_new(struct nf_conn *ct, const struct sk_buff *skb,
 		    unsigned int dataoff)
diff -ruw linux-2.6.39.4/net/netfilter/xt_owner.c linux-2.6.39.4-fbx/net/netfilter/xt_owner.c
--- linux-2.6.39.4/net/netfilter/xt_owner.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/netfilter/xt_owner.c	2011-05-24 18:15:57.405712865 +0200
@@ -17,6 +17,62 @@
 #include <linux/netfilter/x_tables.h>
 #include <linux/netfilter/xt_owner.h>
 
+static int __owner_match_simple_gid(gid_t gid,
+				    const struct xt_owner_match_info *info)
+{
+	if (gid >= info->gid_min && gid <= info->gid_max)
+		return 1;
+	return 0;
+}
+
+/*
+ * see kernel/groups.c:groups_to_user() function, which inspired the
+ * content of this function.
+ */
+static int __owner_match_gid_groupinfo(const struct group_info *group_info,
+				       const struct xt_owner_match_info *info)
+{
+	unsigned int count = group_info->ngroups;
+	unsigned int block;
+
+	for (block = 0; block < group_info->nblocks; ++block) {
+		unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);
+		unsigned int i;
+
+		for (i = 0; i < cp_count; ++i) {
+			if (__owner_match_simple_gid(
+					     group_info->blocks[block][i],
+					     info)) {
+				return 1;
+			}
+			count -= cp_count;
+		}
+	}
+	return 0;
+}
+
+static int owner_match_gid(const struct file *filp,
+			   const struct xt_owner_match_info *info)
+{
+	struct task_struct *p;
+
+	/*
+	 * direct match, this is the simple and only case handled by
+	 * the old code, file fsgid matches info gid range.
+	 */
+	if (__owner_match_simple_gid(filp->f_cred->fsgid, info))
+		return 1;
+
+	/*
+	 * otherwise we need to have a look to the group list available
+	 * in f_cred->group_info.
+	 */
+	if (__owner_match_gid_groupinfo(filp->f_cred->group_info, info))
+		return 1;
+
+	return 0;
+}
+
 static bool
 owner_mt(const struct sk_buff *skb, struct xt_action_param *par)
 {
@@ -44,8 +100,7 @@
 			return false;
 
 	if (info->match & XT_OWNER_GID)
-		if ((filp->f_cred->fsgid >= info->gid_min &&
-		    filp->f_cred->fsgid <= info->gid_max) ^
+		if (owner_match_gid(filp, info) ^
 		    !(info->invert & XT_OWNER_GID))
 			return false;
 
diff -ruw linux-2.6.39.4/net/socket.c linux-2.6.39.4-fbx/net/socket.c
--- linux-2.6.39.4/net/socket.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/socket.c	2011-06-15 18:56:46.125463675 +0200
@@ -954,6 +954,31 @@
 	return err;
 }
 
+static DEFINE_MUTEX(fbxdiverter_ioctl_mutex);
+static int (*fbxdiverter_ioctl_hook) (struct net *, unsigned int cmd, void __user *arg) = NULL;
+
+void fbxdiverter_ioctl_set(int (*hook) (struct net *, unsigned int,
+					void __user *))
+{
+	mutex_lock(&fbxdiverter_ioctl_mutex);
+	fbxdiverter_ioctl_hook = hook;
+	mutex_unlock(&fbxdiverter_ioctl_mutex);
+}
+
+EXPORT_SYMBOL(fbxdiverter_ioctl_set);
+
+static DEFINE_MUTEX(fbxbridge_ioctl_mutex);
+static int (*fbxbridge_ioctl_hook)(struct net *, unsigned int cmd, void __user *arg) = NULL;
+
+void fbxbridge_set(int (*hook)(struct net *, unsigned int, void __user *))
+{
+	mutex_lock(&fbxbridge_ioctl_mutex);
+	fbxbridge_ioctl_hook = hook;
+	mutex_unlock(&fbxbridge_ioctl_mutex);
+}
+
+EXPORT_SYMBOL(fbxbridge_set);
+
 /*
  *	With an ioctl, arg may well be a user mode pointer, but we don't know
  *	what to do with it - that's up to the protocol still.
@@ -1026,6 +1051,28 @@
 				err = dlci_ioctl_hook(cmd, argp);
 			mutex_unlock(&dlci_ioctl_mutex);
 			break;
+		case SIOCGFBXDIVERT:
+		case SIOCSFBXDIVERT:
+			err = -ENOPKG;
+			if (!fbxdiverter_ioctl_hook)
+				request_module("fbxdiverter");
+
+			mutex_lock(&fbxdiverter_ioctl_mutex);
+			if (fbxdiverter_ioctl_hook)
+				err = fbxdiverter_ioctl_hook(net, cmd, argp);
+			mutex_unlock(&fbxdiverter_ioctl_mutex);
+			break;
+		case SIOCGFBXBRIDGE:
+		case SIOCSFBXBRIDGE:
+			err = -ENOPKG;
+			if (!fbxbridge_ioctl_hook)
+				request_module("fbxbridge");
+
+			mutex_lock(&fbxbridge_ioctl_mutex);
+			if (fbxbridge_ioctl_hook)
+				err = fbxbridge_ioctl_hook(net, cmd, argp);
+			mutex_unlock(&fbxbridge_ioctl_mutex);
+			break;
 		default:
 			err = sock_do_ioctl(net, sock, cmd, arg);
 			break;
diff -ruw linux-2.6.39.4/net/sysctl_net.c linux-2.6.39.4-fbx/net/sysctl_net.c
--- linux-2.6.39.4/net/sysctl_net.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/sysctl_net.c	2011-09-09 16:11:25.410446429 +0200
@@ -50,7 +50,9 @@
 		int mode = (table->mode >> 6) & 7;
 		return (mode << 6) | (mode << 3) | mode;
 	}
-	return table->mode;
+
+	/* read-only otherwise */
+	return table->mode & ~0222;
 }
 
 static struct ctl_table_root net_sysctl_root = {
diff -ruw linux-2.6.39.4/net/wireless/db.txt linux-2.6.39.4-fbx/net/wireless/db.txt
--- linux-2.6.39.4/net/wireless/db.txt	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/net/wireless/db.txt	2011-05-24 18:15:57.475712576 +0200
@@ -1,17 +1,655 @@
-#
-# This file is a placeholder to prevent accidental build breakage if someone
-# enables CONFIG_CFG80211_INTERNAL_REGDB.  Almost no one actually needs to
-# enable that build option.
-#
-# You should be using CRDA instead.  It is even better if you use the CRDA
-# package provided by your distribution, since they will probably keep it
-# up-to-date on your behalf.
-#
-# If you _really_ intend to use CONFIG_CFG80211_INTERNAL_REGDB then you will
-# need to replace this file with one containing appropriately formatted
-# regulatory rules that cover the regulatory domains you will be using.  Your
-# best option is to extract the db.txt file from the wireless-regdb git
-# repository:
-#
-#   git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-regdb.git
-#
+# This is the world regulatory domain
+country 00:
+	(2402 - 2472 @ 40), (3, 20)
+        # Channel 12 - 13. No HT40 channel fits here
+        (2457 - 2482 @ 20), (3, 20), PASSIVE-SCAN, NO-IBSS
+        # Channel 14. Only JP enables this and for 802.11b only
+        (2474 - 2494 @ 20), (3, 20), PASSIVE-SCAN, NO-IBSS, NO-OFDM
+        # Channel 36 - 48
+        (5170 - 5250 @ 40), (3, 20), PASSIVE-SCAN, NO-IBSS
+        # NB: 5260 MHz - 5700 MHz requies DFS
+        # Channel 149 - 165
+        (5735 - 5835 @ 40), (3, 20), PASSIVE-SCAN, NO-IBSS
+
+
+country AE:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country AL:
+	(2402 - 2482 @ 20), (N/A, 20)
+
+country AM:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 18)
+	(5250 - 5330 @ 20), (N/A, 18), DFS
+
+country AN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country AR:
+	(2402 - 2482 @ 20), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country AT:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country AU:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 23)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country AW:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country AZ:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+	(5250 - 5330 @ 40), (N/A, 18), DFS
+
+country BA:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country BB:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 23)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country BE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country BG:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 23)
+	(5250 - 5290 @ 40), (N/A, 23), DFS
+	(5490 - 5710 @ 40), (N/A, 30), DFS
+
+country BH:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+	(5735 - 5835 @ 20), (N/A, 20)
+
+country BL:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+	(5250 - 5330 @ 40), (N/A, 18), DFS
+
+country BN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country BO:
+	(2402 - 2482 @ 40), (N/A, 30)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country BR:
+	(2402 - 2482 @ 20), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 20), DFS
+	(5490 - 5710 @ 20), (3, 20), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country BY:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country BZ:
+	(2402 - 2482 @ 40), (N/A, 30)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country CA:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country CH:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country CL:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5735 - 5835 @ 40), (N/A, 20)
+
+country CN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country CO:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country CR:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country CS:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country CY:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+# Data from http://www.ctu.eu/164/download/VOR/VOR-12-08-2005-34.pdf
+# and http://www.ctu.eu/164/download/VOR/VOR-12-05-2007-6-AN.pdf
+country CZ:
+	(2400 - 2483.5 @ 40), (N/A, 100 mW)
+	(5150 - 5250 @ 40), (N/A, 200 mW), NO-OUTDOOR
+	(5250 - 5350 @ 40), (N/A, 200 mW), NO-OUTDOOR, DFS
+	(5470 - 5725 @ 40), (N/A, 1000 mW), DFS
+
+# Data from "Frequenznutzungsplan" (as published in April 2008),
+# downloaded from http://www.bundesnetzagentur.de/media/archive/13358.pdf
+# Also applicable is http://www.bundesnetzagentur.de/media/archive/5009.pdf
+# On the 5 GHz ranges TX power can be doubled if TPC is implemented.
+country DE:
+	# entries 279004 and 280006
+	(2400 - 2483.5 @ 40), (N/A, 100 mW)
+	# entries 303005, 304002 and 305002
+	(5150 - 5350 @ 40), (N/A, 100 mW), NO-OUTDOOR, DFS
+	# entries 308002, 309001 and 310003
+	(5470 - 5725 @ 40), (N/A, 500 mW), NO-OUTDOOR, DFS
+
+country DK:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country DO:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country DZ:
+	(2402 - 2482 @ 20), (N/A, 20)
+
+country EC:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country EE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country EG:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+
+country ES:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country FI:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country FR:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country GE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+	(5250 - 5330 @ 40), (N/A, 18), DFS
+
+country GB:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country GD:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country GR:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country GL:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+	(5490 - 5710 @ 20), (N/A, 27), DFS
+
+country GT:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country GU:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country HN:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country HK:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country HR:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country HT:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country HU:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country ID:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country IE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country IL:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country IN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+	(5735 - 5835 @ 20), (N/A, 20)
+
+country IS:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country IR:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country IT:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country JM:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country JP:
+	(2402 - 2472 @ 40), (N/A, 20)
+	(2457 - 2482 @ 20), (N/A, 20)
+	(2474 - 2494 @ 20), (N/A, 20), NO-OFDM
+	(4910 - 4930 @ 10), (N/A, 23)
+	(4910 - 4990 @ 40), (N/A, 23)
+	(4930 - 4950 @ 10), (N/A, 23)
+	(5030 - 5045 @ 10), (N/A, 23)
+	(5030 - 5090 @ 40), (N/A, 23)
+	(5050 - 5060 @ 10), (N/A, 23)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 23), DFS
+
+country JO:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+
+country KH:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country KP:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5330 @ 40), (3, 20)
+	(5160 - 5250 @ 40), (3, 20), DFS
+	(5490 - 5630 @ 40), (3, 30), DFS
+	(5735 - 5815 @ 40), (3, 30)
+
+country KR:
+	(2402 - 2482 @ 20), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 20)
+	(5250 - 5330 @ 20), (3, 20), DFS
+	(5490 - 5630 @ 20), (3, 30), DFS
+	(5735 - 5815 @ 20), (3, 30)
+
+country KW:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+
+country KZ:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country LB:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country LI:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country LK:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 20), DFS
+	(5490 - 5710 @ 20), (3, 20), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country LT:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country LU:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country LV:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country MC:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+	(5250 - 5330 @ 40), (N/A, 18), DFS
+
+country MA:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country MO:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 23)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country MK:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country MT:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country MY:
+	(2402 - 2482 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 30), DFS
+	(5735 - 5835 @ 20), (N/A, 30)
+
+country MX:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country NL:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country NO:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country NP:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country NZ:
+	(2402 - 2482 @ 40), (N/A, 30)
+	(5170 - 5250 @ 20), (3, 23)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country OM:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country PA:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country PE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 20), (N/A, 30)
+
+country PG:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country PH:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country PK:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country PL:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country PT:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country PR:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country QA:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country RO:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country RU:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country SA:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country SE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country SG:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5735 - 5835 @ 40), (N/A, 20)
+
+country SI:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country SK:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country SV:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country SY:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country TW:
+	(2402 - 2472 @ 40), (3, 27)
+	(5270 - 5330 @ 40), (3, 17), DFS
+	(5735 - 5815 @ 40), (3, 30)
+
+country TH:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country TT:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country TN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+
+country TR:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+
+country UA:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country US:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5600 @ 40), (3, 20), DFS
+	(5650 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country UY:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country UZ:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country VE:
+	(2402 - 2482 @ 40), (N/A, 30)
+	(5735 - 5815 @ 20), (N/A, 23)
+
+country VN:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country YE:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country ZA:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 20), DFS
+	(5490 - 5710 @ 20), (3, 20), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country ZW:
+	(2402 - 2482 @ 40), (N/A, 20)
+
diff -ruw linux-2.6.39.4/sound/core/pcm_native.c linux-2.6.39.4-fbx/sound/core/pcm_native.c
--- linux-2.6.39.4/sound/core/pcm_native.c	2011-08-03 21:43:28.000000000 +0200
+++ linux-2.6.39.4-fbx/sound/core/pcm_native.c	2011-08-30 20:03:49.016615669 +0200
@@ -3155,7 +3155,7 @@
 /*
  * mmap the DMA buffer on RAM
  */
-static int snd_pcm_default_mmap(struct snd_pcm_substream *substream,
+int snd_pcm_default_mmap(struct snd_pcm_substream *substream,
 				struct vm_area_struct *area)
 {
 	area->vm_flags |= VM_RESERVED;
@@ -3176,6 +3176,7 @@
 	area->vm_ops = &snd_pcm_vm_ops_data_fault;
 	return 0;
 }
+EXPORT_SYMBOL(snd_pcm_default_mmap);
 
 /*
  * mmap the DMA buffer on I/O memory area
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/arch/arm/mach-kirkwood/fbxgw1r-setup.c	2011-07-19 15:41:05.444933574 +0200
@@ -0,0 +1,1098 @@
+/*
+ * Freebox GW01r
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/mtd/physmap.h>
+#include <linux/memblock.h>
+#include <linux/crash_zone.h>
+#include <linux/mtd/nand.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/ssd1327.h>
+#include <linux/i2c/at24.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/pci.h>
+#include <mach/kirkwood.h>
+#include <mach/bridge-regs.h>
+#include <mach/board_fbxgw1r.h>
+#include <plat/pcie.h>
+#include <linux/fbxgpio_core.h>
+#include <linux/fbxatm_remote.h>
+#include <linux/smsc_cap1066.h>
+#include <linux/ethtool.h>
+#include <linux/input.h>
+#include <plat/orion_nand.h>
+#include <plat/orion_wdt.h>
+#include "common.h"
+#include "mpp.h"
+
+#define PFX	"fbxgw1r: "
+
+struct fbx_serial serial;
+
+char loader_version_str[128];
+int loader_erase_nvram = 0;
+int loader_bank0_forced = 0;
+EXPORT_SYMBOL(loader_version_str);
+EXPORT_SYMBOL(loader_erase_nvram);
+EXPORT_SYMBOL(loader_bank0_forced);
+
+/*
+ * set shift registers output to given value
+ */
+static void set_shift_register(u8 val)
+{
+	int i;
+
+	gpio_set_value(GPIO_SR_CLK, 0);
+	gpio_set_value(GPIO_SR_LOAD, 0);
+
+	udelay(1);
+
+	for (i = 7; i >= 0; i--) {
+		gpio_set_value(GPIO_SR_DIN, (val & (1 << i)) ? 1 : 0);
+		udelay(1);
+		gpio_set_value(GPIO_SR_CLK, 1);
+		udelay(1);
+		gpio_set_value(GPIO_SR_CLK, 0);
+	}
+
+	udelay(1);
+	gpio_set_value(GPIO_SR_LOAD, 1);
+	udelay(1);
+}
+
+/*
+ * reset values can not be read back from shift registers, we have to
+ * keep them
+ */
+static DEFINE_SPINLOCK(sr_lock);
+static unsigned long sr_value;
+
+/*
+ * clear or set sr bit
+ */
+static void sr_set_bit(int bit, int value)
+{
+	unsigned long flags;
+
+	value = !!value;
+	spin_lock_irqsave(&sr_lock, flags);
+	sr_value &= ~(1 << bit);
+	sr_value |= (value << bit);
+	set_shift_register((u8)sr_value);
+	spin_unlock_irqrestore(&sr_lock, flags);
+}
+
+/*
+ * return cached bit value
+ */
+static int sr_get_bit(int bit)
+{
+	return test_bit(bit, &sr_value);
+}
+
+/*
+ * control PCIe bus reset
+ */
+static void fbxgw1r_pcie_reset(int value)
+{
+	sr_set_bit(SROUT_PCIE_RST, value);
+}
+
+#ifdef CONFIG_MACH_FBXGW1R_ETHSW_CONFIG
+/*
+ * control marvell swith reset
+ */
+static void fbxgw1r_marvell_switch_reset(int value)
+{
+	gpio_set_value(GPIO_SW_RESET, value);
+}
+
+static int fbxgw1r_do_vlan(void)
+{
+#ifdef CONFIG_MACH_FBXGW1R_ETHSW_CONFIG_VLAN
+	return 1;
+#else
+	return 0;
+#endif
+}
+
+
+#define NFS_VLAN_ID			41
+
+#define MARVELL_PHYPORT0		0x00
+#define MARVELL_PHYPORT1		0x01
+
+#define MARVELL_SWPORT0			0x10
+#define MARVELL_SWPORT1			0x11
+#define MARVELL_SWPORT2			0x12
+#define MARVELL_SWPORT3			0x13
+#define MARVELL_SWPORT4			0x14
+#define MARVELL_SWPORT5			0x15
+
+#define PORTREG_PCS			0x1
+
+#define PCS_FORCELINK_UP		(1 << 5)
+#define PCS_FORCELINK			(1 << 4)
+#define PCS_FORCEDUPLEX_FULL		(1 << 3)
+#define PCS_FORCEDUPLEX			(1 << 2)
+#define PCS_FORCESPEED_10		0x0
+#define PCS_FORCESPEED_100		0x1
+#define PCS_FORCESPEED_1000		0x2
+#define PCS_FORCESPEED_AUTO		0x3
+
+#define PORTREG_SWITCH_IDENTIFIER	0x3
+#define PRODUCT_NUM(x)			(((x) >> 4) & 0xfff)
+
+#define PORTREG_PCR			0x4
+#define PCR_PORTSTATE_DISABLED		0x0
+#define PCR_PORTSTATE_FORWARDING	0x3
+
+#define PORTREG_VLANID			0x7
+
+#define PORTREG_PCR2			0x8
+#define PCR2_MODE_SHIFT			10
+#define PCR2_MODE_SECURE		3
+
+#define MARVEL_GLOBAL1			0x1b
+#define MARVEL_GLOBAL2			0x1c
+
+#define GLOBREG_VTUFID			0x2
+#define GLOBREG_VTUSID			0x3
+
+#define GLOBREG_GCR			0x4
+#define GCR_PPUEN			(1 << 14)
+
+#define GLOBREG_VTUOP			0x5
+#define VTUOP_BUSY			(1 << 15)
+#define VTUOP_OP_SHIFT			12
+#define VTUOP_OP_LOAD			0x3
+
+#define GLOBREG_VTUVID			0x6
+#define VTUVID_VALID			(1 << 12)
+
+#define GLOBREG_VTU_P03_DATA		0x7
+#define GLOBREG_VTU_P45_DATA		0x8
+
+#define PDATA_MEMBER_UNMODIFIED		0
+#define PDATA_MEMBER_UNTAGGED		1
+#define PDATA_MEMBER_TAGGED		2
+#define PDATA_NOT_MEMBER		3
+
+#define GLOBREG_VTU_DATA		0x9
+
+/*
+ * voodo register content. P4_RGMII_FORCE is effective on revision A2
+ * of mv6161 chip. see revision A2 release notes for details.
+ */
+#define P4_RGMII_DELAY			0x03
+#define P5_RGMII_DELAY			0x18
+#define P4_RGMII_FORCE			0x40
+
+
+static int marvell_6161_config(struct net_device *dev, int probe,
+			       int (*mii_read)(struct net_device *dev,
+					       int phy_id, int reg),
+			       void (*mii_write)(struct net_device *dev,
+						 int phy_id, int reg, int val))
+{
+	u16 val;
+
+	if (!probe)
+		return 0;
+
+	/* switch needs more than 1 second (!) to go out of reset */
+	fbxgw1r_marvell_switch_reset(0);
+	mdelay(1);
+	fbxgw1r_marvell_switch_reset(1);
+	msleep(2000);
+
+	/* probe */
+	val = mii_read(dev, MARVELL_SWPORT0, PORTREG_SWITCH_IDENTIFIER);
+	if (PRODUCT_NUM(val) != 0x161) {
+		printk(KERN_ERR PFX "unknown switch id: 0x%08x\n",
+		       PRODUCT_NUM(val));
+		return 1;
+	}
+
+	/*
+	 * set rgmii delay for cpu port (5) and ftth port (4), also
+	 * force ftth port in RGMII mode
+	 */
+	mii_write(dev, MARVELL_SWPORT4, 0x1a, 0x81e7);
+	(void)mii_read(dev, MARVELL_SWPORT5, 0x1a);
+	mii_write(dev, MARVELL_SWPORT5, 0x1a,
+		  P4_RGMII_FORCE | P4_RGMII_DELAY | P5_RGMII_DELAY);
+	mii_write(dev, MARVELL_SWPORT4, 0x1a, 0xc1e7);
+
+	/* force link up and 1000-FD on CPU port */
+	mii_write(dev, MARVELL_SWPORT5, PORTREG_PCS,
+		    PCS_FORCEDUPLEX_FULL | PCS_FORCEDUPLEX |
+		    PCS_FORCESPEED_1000 |
+		    PCS_FORCELINK | PCS_FORCELINK_UP);
+
+	/* disable ppu */
+	val = mii_read(dev, MARVEL_GLOBAL1, GLOBREG_GCR);
+	val &= ~GCR_PPUEN;
+	mii_write(dev, MARVEL_GLOBAL1, GLOBREG_GCR, val);
+
+	/* power up phy for eth port 0 */
+	val = mii_read(dev, MARVELL_PHYPORT1, 0x00);
+	val &= ~0x0800;
+	mii_write(dev, MARVELL_PHYPORT1, 0x00, val);
+
+	/* restart autoneg */
+	val = mii_read(dev, MARVELL_PHYPORT1, 0x00);
+	val |= 0x0200;
+	mii_write(dev, MARVELL_PHYPORT1, 0x00, val);
+
+	/* enable ppu */
+	val = mii_read(dev, MARVEL_GLOBAL1, GLOBREG_GCR);
+	val |= GCR_PPUEN;
+	mii_write(dev, MARVEL_GLOBAL1, GLOBREG_GCR, val);
+
+	if (fbxgw1r_do_vlan()) {
+		/* prepare load vtu */
+		val = VTUOP_OP_LOAD << VTUOP_OP_SHIFT;
+		mii_write(dev, MARVEL_GLOBAL1, GLOBREG_VTUOP, val);
+
+		/* set fid & sid */
+		mii_write(dev, MARVEL_GLOBAL1, GLOBREG_VTUFID, 1);
+		mii_write(dev, MARVEL_GLOBAL1, GLOBREG_VTUSID, 0);
+
+		/* set vlan id */
+		val = VTUVID_VALID | NFS_VLAN_ID;
+		mii_write(dev, MARVEL_GLOBAL1, GLOBREG_VTUVID, val);
+
+
+		/* port 1 in vlan */
+		val = (PDATA_NOT_MEMBER << 0) |
+			(PDATA_MEMBER_UNTAGGED << 4) |
+			(PDATA_NOT_MEMBER << 8) |
+			(PDATA_NOT_MEMBER << 12);
+		mii_write(dev, MARVEL_GLOBAL1, GLOBREG_VTU_P03_DATA, val);
+
+		/* port 5 in vlan (tagged) */
+		val = (PDATA_NOT_MEMBER << 0) |
+			(PDATA_MEMBER_TAGGED << 4);
+		mii_write(dev, MARVEL_GLOBAL1, GLOBREG_VTU_P45_DATA, val);
+
+		mii_write(dev, MARVEL_GLOBAL1, GLOBREG_VTU_DATA, 0);
+
+		/* do vtu operation */
+		val = VTUOP_BUSY | (VTUOP_OP_LOAD << VTUOP_OP_SHIFT);
+		mii_write(dev, MARVEL_GLOBAL1, GLOBREG_VTUOP, val);
+		mdelay(10);
+
+		/* set default vid to 41 on port 1 */
+		val = mii_read(dev, MARVELL_SWPORT1, PORTREG_VLANID);
+		val &= ~0xfff;
+		val |= NFS_VLAN_ID;
+		mii_write(dev, MARVELL_SWPORT1, PORTREG_VLANID, val);
+
+		/* switch port 1 & 5 to secure mode */
+		val = mii_read(dev, MARVELL_SWPORT1, PORTREG_PCR2);
+		val &= ~(3 << PCR2_MODE_SHIFT);
+		val |= (PCR2_MODE_SECURE << PCR2_MODE_SHIFT);
+		mii_write(dev, MARVELL_SWPORT1, PORTREG_PCR2, val);
+
+		val = mii_read(dev, MARVELL_SWPORT5, PORTREG_PCR2);
+		val &= ~(3 << PCR2_MODE_SHIFT);
+		val |= (PCR2_MODE_SECURE << PCR2_MODE_SHIFT);
+		mii_write(dev, MARVELL_SWPORT5, PORTREG_PCR2, val);
+	}
+
+	/* enable forwarding */
+	val = mii_read(dev, MARVELL_SWPORT1, PORTREG_PCR);
+	val |= PCR_PORTSTATE_FORWARDING;
+	mii_write(dev, MARVELL_SWPORT1, PORTREG_PCR, val);
+
+	val = mii_read(dev, MARVELL_SWPORT5, PORTREG_PCR);
+	val |= PCR_PORTSTATE_FORWARDING;
+	mii_write(dev, MARVELL_SWPORT5, PORTREG_PCR, val);
+
+	printk(KERN_INFO PFX "marvell 6161 initialized\n");
+	return 0;
+}
+#endif
+
+static struct mv643xx_eth_platform_data fbxgw1r_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_NONE,
+	.speed		= SPEED_1000,
+	.duplex		= DUPLEX_FULL,
+#ifdef CONFIG_MACH_FBXGW1R_ETHSW_CONFIG
+	.mii_config	= marvell_6161_config,
+#endif
+};
+
+static struct mv643xx_eth_platform_data fbxgw1r_ge01_data = {
+	.phy_addr	= MV643XX_ETH_PHY_NONE,
+	.speed		= SPEED_1000,
+	.duplex		= DUPLEX_FULL,
+};
+
+static struct mv_sata_platform_data fbxgw1r_sata_data = {
+	.n_ports	= 2,
+};
+
+static const struct flash_platform_data	flash_info = {
+	.name		= "bcmflash",
+};
+
+static const struct ssd1327_platform_data ssd1327_pd = {
+	.data_select_gpio	= GPIO_OLED_DATA_SELECT,
+	.width			= 128,
+	.height			= 128,
+	.rotate			= 270,
+	.watchdog		= 300,
+};
+
+static struct spi_board_info spi_board_info[] __initdata = {
+
+	{
+		.modalias       = "ssd1327",
+		.platform_data	= &ssd1327_pd,
+		.mode		= SPI_MODE_0,
+		.max_speed_hz	= 10 * 1000 * 1000,
+		.bus_num	= 0,
+		.chip_select    = 0,
+	},
+
+	{
+		.modalias       = "m25p80",
+		.platform_data	= &flash_info,
+		.mode		= SPI_MODE_0,
+		.max_speed_hz	= 4 * 1000 * 1000,
+		.bus_num	= 0,
+		.chip_select    = 1,
+	},
+};
+
+/*
+ * fbxwatchdog
+ */
+static struct orion_wdt_platform_data orion_fbxwdt_data;
+
+static struct platform_device orion_fbxwdt_device = {
+	.name		= "orion_fbxwdt",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &orion_fbxwdt_data,
+	},
+	.num_resources	= 0,
+};
+
+/*
+ * fbxgpio
+ */
+static struct fbxgpio_operations fbxgw1r_gpio_ops = {
+	/* cast only for signed/unsigned */
+	.get_datain = (int (*)(int))gpio_get_value,
+	.get_dataout = (int (*)(int))gpio_get_value,
+	.set_dataout = (void (*)(int, int))gpio_set_value,
+};
+
+static struct fbxgpio_operations fbxgw1r_sr_ops = {
+	.get_dataout = sr_get_bit,
+	.set_dataout = sr_set_bit,
+};
+
+static struct fbxgpio_pin fbxgw1r_gpio_pins[] = {
+	/* marvell gpios */
+	{
+		.pin_name	 = "oled-data-select",
+		.direction	= GPIO_DIR_OUT,
+		.pin_num	= GPIO_OLED_DATA_SELECT,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "test-mode",
+		.direction	= GPIO_DIR_IN,
+		.pin_num	= GPIO_TEST_MODE,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "sfp-txdis",
+		.direction	= GPIO_DIR_OUT,
+		.pin_num	= GPIO_SFP_TXDIS,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "sw-reset",
+		.direction	= GPIO_DIR_OUT,
+		.pin_num	= GPIO_SW_RESET,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "sw-int",
+		.direction	= GPIO_DIR_IN,
+		.pin_num	= GPIO_SW_INT,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "sfp-pwrgood",
+		.direction	= GPIO_DIR_IN,
+		.pin_num	= GPIO_SFP_PWRGOOD,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "sfp-txfault",
+		.direction	= GPIO_DIR_IN,
+		.pin_num	= GPIO_SFP_TXFAULT,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "sfp-presence",
+		.direction	= GPIO_DIR_IN,
+		.pin_num	= GPIO_SFP_PRESENCE,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "sfp-rxloss",
+		.direction	= GPIO_DIR_IN,
+		.pin_num	= GPIO_SFP_RXLOSS,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "exp-rst",
+		.direction	= GPIO_DIR_OUT,
+		.pin_num	= GPIO_EXP_RST,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "pos-sense",
+		.direction	= GPIO_DIR_IN,
+		.pin_num	= GPIO_POS_SENSE,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "exp-pwrgood",
+		.direction	= GPIO_DIR_IN,
+		.pin_num	= GPIO_EXP_PWRGOOD,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "exp-presence",
+		.direction	= GPIO_DIR_IN,
+		.pin_num	= GPIO_EXP_PRESENCE,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "kp-int",
+		.direction	= GPIO_DIR_IN,
+		.pin_num	= GPIO_KP_INT,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "board-id-0",
+		.direction	= GPIO_DIR_IN,
+		.pin_num	= GPIO_BOARD_ID_0,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+	{
+		.pin_name	= "board-id-1",
+		.direction	= GPIO_DIR_IN,
+		.pin_num	= GPIO_BOARD_ID_1,
+		.ops		= &fbxgw1r_gpio_ops,
+	},
+
+	/* shift registers resets */
+	{
+		.pin_name       = "sfp-pwren",
+		.direction      = GPIO_DIR_OUT,
+		.pin_num	= SROUT_SFP_PWREN,
+		.ops		= &fbxgw1r_sr_ops,
+	},
+	{
+		.pin_name       = "usb-rst",
+		.direction      = GPIO_DIR_OUT,
+		.pin_num	= SROUT_USB_RST,
+		.ops		= &fbxgw1r_sr_ops,
+	},
+	{
+		.pin_name       = "audio-rst",
+		.direction      = GPIO_DIR_OUT,
+		.pin_num	= SROUT_AUDIO_RST,
+		.ops		= &fbxgw1r_sr_ops,
+	},
+	{
+		.pin_name       = "exp-pwren",
+		.direction      = GPIO_DIR_OUT,
+		.pin_num	= SROUT_EXP_PWREN,
+		.ops		= &fbxgw1r_sr_ops,
+	},
+	{
+		.pin_name       = "bcm-rst",
+		.direction      = GPIO_DIR_OUT,
+		.pin_num	= SROUT_BCM_RST,
+		.ops		= &fbxgw1r_sr_ops,
+	},
+	{
+		.pin_name       = "pcie-rst",
+		.direction      = GPIO_DIR_OUT,
+		.pin_num	= SROUT_PCIE_RST,
+		.ops		= &fbxgw1r_sr_ops,
+	},
+	{
+		.pin_name       = "keypad-oled-rst",
+		.direction      = GPIO_DIR_OUT,
+		.pin_num	= SROUT_KEYPAD_OLED_RST,
+		.ops		= &fbxgw1r_sr_ops,
+	},
+	{
+		.pin_name       = "keypad-pwren",
+		.direction      = GPIO_DIR_OUT,
+		.pin_num	= SROUT_OLED_PWREN,
+		.ops		= &fbxgw1r_sr_ops,
+	},
+
+
+	{  },
+};
+
+static struct platform_device fbxgw1r_gpio_device = {
+	.name   = "fbxgpio",
+	.id     = -1,
+	.dev    = {
+		.platform_data = &fbxgw1r_gpio_pins,
+	},
+};
+
+/*
+ * NAND flash
+ */
+static struct mtd_partition fbxgw1r_nand_parts[] = {
+	{
+		.name = "all",
+		.offset = 0,
+		.size = MTDPART_SIZ_FULL,
+		.mask_flags = MTD_WRITEABLE,
+	}, {
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M,
+		.mask_flags = MTD_WRITEABLE,
+	}, {
+		.name = "serial",
+		.offset = SZ_1M,
+		.size = SZ_1M,
+		.mask_flags = MTD_WRITEABLE,
+	}, {
+		.name = "calibration",
+		.offset = SZ_1M * 2,
+		.size = SZ_1M,
+		.mask_flags = MTD_WRITEABLE,
+	}, {
+		.name = "bank0",
+		.offset = SZ_1M * 3,
+		.size = SZ_1M * 18,
+		.mask_flags = MTD_WRITEABLE,
+	}, {
+		.name = "nvram",
+		.offset = SZ_1M * 21,
+		.size = SZ_1M * 3,
+	}, {
+		.name = "bank1",
+		.offset = SZ_1M * 24,
+		.size = SZ_1M * 96,
+	}, {
+		.name = "config",
+		.offset = SZ_1M * 120,
+		.size = SZ_1M * 8,
+	}, {
+		.name = "new_bank0",
+		.offset = SZ_1M * 102,
+		.size = SZ_1M * 18,
+	},
+};
+
+/*
+ * broadcom 6358 remote atm device
+ */
+static struct fbxatm_remote_pdata bcm6358_remote_pdata = {
+	.remote_mac	= "\x00\x07\xcb\x00\x00\xfe",
+	.netdev_name	= "eth0.43",
+	.remote_name	= "bcm63xx_fbxxtm0",
+};
+
+static struct platform_device fbxatm_remote_device = {
+	.name	= "fbxatm_remote",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &bcm6358_remote_pdata,
+	},
+};
+
+#define PCIE_BASE	((void __iomem *)PCIE_VIRT_BASE)
+
+static void __init fbxgw1r_pci_preinit(void)
+{
+	u32 val;
+
+	/* we will reset PCIe bus, make sure it's correctly disabled
+	 * first */
+	val = readl(CPU_CONTROL);
+	if (!(val & PCIE0_ENABLE)) {
+		val |= PCIE0_ENABLE;
+		writel(val, CPU_CONTROL);
+		return;
+	}
+
+	if (!orion_pcie_link_up(PCIE_BASE))
+		return;
+
+	orion_pcie_set_link_disable(PCIE_BASE, 1);
+	mdelay(100);
+	orion_pcie_set_link_disable(PCIE_BASE, 0);
+}
+
+/*
+ * Hardcoded timings for two known NAND parts:
+ * - NUMONYX NAND01GW3B2CZA6F
+ * - TOSHIBA TC58NVG0S3EBAI4
+ *
+ * Kirkwood to ONFI mapping (from Marvell)
+ * =======================================
+ * TurnOff => tRHW
+ * Acc2First => tCEA
+ * Acc2Next => tRC
+ * NFOEnW => tREH
+ * CEn2WEn => tCS  tWP
+ * WrLow => tWP
+ * WrHigh => tWH
+ *
+ * = Numonyx
+ * tRHW = 100ns | 20 Turnoff cycles (regvalue = 16)
+ * tCEA = 25ns | 5 Acc2first cycles (regvalue = 9)
+ * tRC = 25ns | 5 Acc2next cycles (regvalue = 5)
+ * tREH = 10ns | 2 NOFEnW cycles (regvalue = 1)
+ * tCS - tWP = 20ns - 12ns = 8ns | 2 CEn2WEn cycles (regvalue = 6)
+ * tWp = 12ns | 3 WrLow cycles (regvalue = 3)
+ * tWh = 10ns | 2 WrHigh cycles (regvalue = 2)
+ * command delay: 25ns
+ *
+ * = Toshiba
+ * tRHW = 30ns | 6 Turnoff cycles (regvalue 2)
+ * tCEA = 25ns | 5 Acc2first cycles (regvalue 9)
+ * tRC = 25ns | 5 Acc2next cycles (regvalue 5)
+ * tREH = 10ns | 5 NOFEnW cycles (regvalue 2)
+ * tCS - tWP = 20ns - 12ns = 8ns | 2 CEn2WEn cycles (regvalue = 6)
+ * tWp = 12ns | 3 WrLow cycles (regvalue = 3)
+ * tWh = 10ns | 2 WrHigh cycles (regvalue = 2)
+ * command delay: 30ns
+ *
+ * all values are the same besides Turnoff
+ * add one cycle for all values
+ *
+ * BEWARE: Acc2next & NFOEnW ARE LINKED ! Any additional cycles given
+ * to NOFEnW must be accounted for in Acc2next
+ */
+#define NAND_COMMAND_DELAY	35
+
+static void __init set_nand_timings(void)
+{
+	u32 val;
+	u32 turnoff, acc2first, acc2next, nofenw, cen2wen, wrlow, wrhigh;
+
+#ifdef CONFIG_MACH_FBXGW1R_NAND_SAFE_READ_TIMINGS
+	turnoff = 0x1f;
+	acc2first = 0x1f;
+	acc2next = 0x1f;
+	nofenw = 0xc;
+#else
+	turnoff = 0x11;
+	acc2first = 0xa;
+	acc2next = 0x7;
+	nofenw = 0x2;
+#endif
+
+#ifdef CONFIG_MACH_FBXGW1R_NAND_SAFE_WRITE_TIMINGS
+	cen2wen = 0xf;
+	wrlow = 0xf;
+	wrhigh = 0xf;
+#else
+	cen2wen = 0x7;
+	wrlow = 0x4;
+	wrhigh = 0x3;
+#endif
+
+
+	val = readl(NAND_VIRT_BASE + NAND_RD_PARAM_OFF);
+	/* turnoff */
+	val &= ~(0x1f << 0);
+	val |= (turnoff << 0);
+	/* acc2first */
+	val &= ~(0x1f << 6);
+	val |= (acc2first << 6);
+	/* acc2next */
+	val &= ~(0x1f << 17);
+	val |= (acc2next << 17);
+	writel(val, NAND_VIRT_BASE + NAND_RD_PARAM_OFF);
+
+	val = readl(NAND_VIRT_BASE + NAND_FLASH_CTL_OFF);
+	/* nfoenw */
+	val &= ~(0x1f << 9);
+	val |= (nofenw << 9);
+	writel(val, NAND_VIRT_BASE + NAND_FLASH_CTL_OFF);
+
+	val = readl(NAND_VIRT_BASE + NAND_WR_PARAM_OFF);
+	/* CEn2WEn */
+	val &= ~(0xf << 0);
+	val |= (cen2wen << 0);
+	/* WrLow */
+	val &= ~(0xf << 8);
+	val |= (wrlow << 8);
+	/* WrHigh */
+	val &= ~(0xf << 16);
+	val |= (wrhigh << 16);
+	writel(val, NAND_VIRT_BASE + NAND_WR_PARAM_OFF);
+}
+
+#ifdef CONFIG_MACH_FBXGW1R_PARTS_WRITE_ALL
+static void __init set_parts_writeable(struct mtd_partition *parts, int count)
+{
+	int i;
+
+	for (i = 0; i < count; ++i) {
+		parts[i].mask_flags &= ~MTD_WRITEABLE;
+	}
+}
+#endif
+
+static int got_serial;
+
+static unsigned int fbxgw1r_mpp_config[] __initdata = {
+	MPP0_NF_IO2,
+	MPP1_NF_IO3,
+	MPP2_NF_IO4,
+	MPP3_NF_IO5,
+	MPP4_NF_IO6,
+	MPP5_NF_IO7,
+	MPP6_SYSRST_OUTn,
+	MPP7_GPO,
+	MPP8_TW0_SDA,
+	MPP9_TW0_SCK,
+	MPP10_GPO,
+	MPP11_UART0_RXD,
+	MPP12_GPO,
+	MPP13_GPIO,
+	MPP14_GPIO,
+	MPP15_UART1_TXD,
+	MPP16_UART1_RXD,
+	MPP17_GPIO,
+	MPP18_NF_IO0,
+	MPP19_NF_IO1,
+	MPP20_GE1_TXD0,
+	MPP21_GE1_TXD1,
+	MPP22_GE1_TXD2,
+	MPP23_GE1_TXD3,
+	MPP24_GE1_RXD0,
+	MPP25_GE1_RXD1,
+	MPP26_GE1_RXD2,
+	MPP27_GE1_RXD3,
+	MPP28_GPIO,
+	MPP29_GPIO,
+	MPP30_GE1_RXCTL,
+	MPP31_GE1_RXCLK,
+	MPP32_GE1_TCLKOUT,
+	MPP33_GE1_TXCTL,
+	MPP34_GPIO,
+	MPP35_GPIO,
+	MPP36_GPIO,
+	MPP37_GPIO,
+	MPP38_GPIO,
+	MPP39_TDM_SPI_CS0,
+	MPP40_TDM_SPI_SCK,
+	MPP41_TDM_SPI_MISO,
+	MPP42_TDM_SPI_MOSI,
+	MPP43_GPIO,
+	MPP44_GPIO,
+	MPP45_GPIO,
+	MPP46_GPIO,
+	MPP47_GPIO,
+	MPP48_GPIO,
+	MPP49_GPIO,
+	0,
+};
+
+/*
+ * i2c midplane eeprom.
+ */
+static struct at24_platform_data midplane_eeprom_data = {
+	.byte_len	= 4096,
+	.page_size	= 8,
+	.flags		= AT24_FLAG_ADDR16,
+};
+
+
+/*
+ * i2c smsc
+ */
+static struct smsc_cap1066_pdata cap1066_pdata = {
+	.key_map = {
+		KEY_DOWN,
+		KEY_LEFT,
+		KEY_UP,
+		0,
+		KEY_ENTER,
+		KEY_RIGHT,
+	},
+
+	.has_irq_gpio = true,
+	.irq_gpio = GPIO_KP_INT,
+};
+
+static struct i2c_board_info fbxgw1r_i2c_devs[] = {
+	{
+		.type		= "cap1066",
+		.addr		= 0x28,
+		.platform_data	= &cap1066_pdata,
+	},
+	{
+		.type		= "24c32",
+		.addr		= 0x57,
+		.platform_data	= &midplane_eeprom_data,
+	},
+};
+
+#ifdef CONFIG_CRASHZONE
+/*
+ * top of RAM - 32k, just below bootloader page table
+ */
+#define CRASH_ZONE_ADDR       0x1fff8000
+
+static void __init fbxgw1r_reserve_crash_zone(void)
+{
+	memblock_remove(0x20000000 - SZ_1M, SZ_1M);
+}
+
+/*
+ * cannot setup crash_zone earlier than an init call since we need a
+ * working ioremap, not provided earlier.
+ */
+static int __init fbxgw1r_setup_crash_zone(void)
+{
+	void __iomem *zone;
+
+	zone = ioremap_nocache(CRASH_ZONE_ADDR, SZ_16K);
+	if (!zone) {
+		printk(KERN_ERR PFX "unable to ioremap crash zone mem.\n");
+		return -ENOMEM;
+	}
+	crash_zone_set_param(zone, SZ_16K);
+	return 0;
+}
+arch_initcall(fbxgw1r_setup_crash_zone);
+#endif
+
+void __init fbxgw1r_init(void)
+{
+	int tdm_cs_gpio[2];
+	extern int panic_timeout;
+
+	panic_timeout = 10;
+	panic_on_oops = 1;
+
+	/* setup gpio */
+	kirkwood_mpp_conf(fbxgw1r_mpp_config);
+
+	gpio_request(GPIO_OLED_DATA_SELECT, "oled-data-select");
+	gpio_request(GPIO_SR_CLK, "sr-clk");
+	gpio_request(GPIO_SR_DIN, "sr-din");
+	gpio_request(GPIO_TEST_MODE, "test-mode");
+	gpio_request(GPIO_SFP_TXDIS, "sfp-txdis");
+	gpio_request(GPIO_SR_LOAD, "sr-load");
+	gpio_request(GPIO_SW_RESET, "sw-reset");
+	gpio_request(GPIO_SW_INT, "sw-int");
+	gpio_request(GPIO_SFP_PWRGOOD, "sfp-pwrgood");
+	gpio_request(GPIO_SFP_TXFAULT, "sfp-txfault");
+	gpio_request(GPIO_SPI_CS_BCM, "spi-cs-bcm");
+	gpio_request(GPIO_SFP_PRESENCE, "sfp-presence");
+	gpio_request(GPIO_SFP_RXLOSS, "sfp-rxloss");
+	gpio_request(GPIO_EXP_RST, "exp-rst");
+	gpio_request(GPIO_POS_SENSE, "pos-sense");
+	gpio_request(GPIO_EXP_PWRGOOD, "exp-pwrgood");
+	gpio_request(GPIO_EXP_PRESENCE, "exp-presence");
+	gpio_request(GPIO_KP_INT, "kp-int");
+	gpio_request(GPIO_BOARD_ID_0, "board-id-0");
+	gpio_request(GPIO_BOARD_ID_1, "board-id-1");
+
+	gpio_direction_output(GPIO_OLED_DATA_SELECT, 0);
+	gpio_direction_output(GPIO_SR_CLK, 0);
+	gpio_direction_output(GPIO_SR_DIN, 0);
+	gpio_direction_input(GPIO_TEST_MODE);
+	gpio_direction_output(GPIO_SFP_TXDIS, 1);
+	gpio_direction_output(GPIO_SR_LOAD, 0);
+	gpio_direction_output(GPIO_SW_RESET, 1);
+	gpio_direction_input(GPIO_SW_INT);
+	gpio_direction_input(GPIO_SFP_PWRGOOD);
+	gpio_direction_input(GPIO_SFP_TXFAULT);
+	gpio_direction_output(GPIO_SPI_CS_BCM, 1);
+	gpio_direction_input(GPIO_SFP_PRESENCE);
+	gpio_direction_input(GPIO_SFP_RXLOSS);
+	gpio_direction_output(GPIO_EXP_RST, 0);
+	gpio_direction_input(GPIO_POS_SENSE);
+	gpio_direction_input(GPIO_EXP_PWRGOOD);
+	gpio_direction_input(GPIO_EXP_PRESENCE);
+	gpio_direction_input(GPIO_KP_INT);
+	gpio_direction_input(GPIO_BOARD_ID_0);
+	gpio_direction_input(GPIO_BOARD_ID_1);
+
+	/* set shift register default value */
+	sr_value = (0 << SROUT_PCIE_RST) |
+		(0 << SROUT_BCM_RST) |
+		(1 << SROUT_KEYPAD_OLED_RST) |
+		(0 << SROUT_SFP_PWREN) |
+		(1 << SROUT_USB_RST) |
+		(1 << SROUT_AUDIO_RST) |
+		(0 << SROUT_EXP_PWREN) |
+		(1 << SROUT_OLED_PWREN);
+	set_shift_register((u8)sr_value);
+
+	fbxgw1r_pci_preinit();
+
+	kirkwood_init();
+
+	/* make a good pci reset */
+	fbxgw1r_pcie_reset(0);
+	mdelay(100);
+	fbxgw1r_pcie_reset(1);
+	mdelay(100);
+	orion_pcie_set_retrain_link(PCIE_BASE, 1);
+	mdelay(1);
+
+	/* check link, should be up */
+	if (!orion_pcie_link_up(PCIE_BASE))
+		printk(KERN_ERR PFX "PCIe link is down\n");
+
+	/* 25khz I2C */
+	kirkwood_i2c_init(12, 5);
+	i2c_register_board_info(0, fbxgw1r_i2c_devs,
+				ARRAY_SIZE(fbxgw1r_i2c_devs));
+
+	/* tdm spi gpio, only for CS1 */
+	tdm_cs_gpio[0] = -1;
+	tdm_cs_gpio[1] = GPIO_SPI_CS_BCM;
+	kirkwood_tdm_spi_init(tdm_cs_gpio);
+	spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
+
+	if (got_serial) {
+		/*
+		 * use mac provided in serialinfo.
+		 */
+		memcpy(fbxgw1r_ge00_data.mac_addr, serial.mac_addr_base,
+		       ETH_ALEN);
+		memcpy(fbxgw1r_ge01_data.mac_addr, serial.mac_addr_base,
+		       ETH_ALEN);
+	}
+
+
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&fbxgw1r_ge00_data);
+	kirkwood_ge01_init(&fbxgw1r_ge01_data);
+	kirkwood_sata_init(&fbxgw1r_sata_data);
+	kirkwood_uart0_init();
+	kirkwood_uart1_init();
+
+	set_nand_timings();
+#ifdef CONFIG_MACH_FBXGW1R_PARTS_WRITE_ALL
+	set_parts_writeable(fbxgw1r_nand_parts, ARRAY_SIZE(fbxgw1r_nand_parts));
+#endif
+	kirkwood_nand_init(ARRAY_AND_SIZE(fbxgw1r_nand_parts),
+			   NAND_COMMAND_DELAY);
+
+	platform_device_register(&fbxgw1r_gpio_device);
+	platform_device_register(&fbxatm_remote_device);
+
+	orion_fbxwdt_data.tclk = kirkwood_tclk;
+	platform_device_register(&orion_fbxwdt_device);
+}
+
+static int __init fbxgw1r_pci_init(void)
+{
+	kirkwood_pcie_init(KW_PCIE0);
+	return 0;
+}
+subsys_initcall(fbxgw1r_pci_init);
+
+/*
+ * fbxserialinfo stuff.
+ */
+const struct fbx_serial *arch_get_fbxserial(void)
+{
+	if (got_serial)
+		return &serial;
+	return NULL;
+}
+EXPORT_SYMBOL(arch_get_fbxserial);
+
+static int __init fbxgw1r_parse_fbxserial_tag(const struct tag *tag)
+{
+	memcpy(&serial, &tag->u.fbxserial, sizeof (serial));
+	got_serial = 1;
+	return 0;
+}
+__tagtable(ATAG_FBXSERIAL, fbxgw1r_parse_fbxserial_tag);
+
+static int __init fbxgw1r_parse_loader_version(const struct tag *tag)
+{
+	const char *version;
+
+	version = tag->u.loader_version.version;
+
+	if (strncmp(version, "u-boot-", 7) ||
+	    strlen(version) > sizeof (loader_version_str) - 1) {
+		printk(KERN_ERR PFX "invalid loader version.\n");
+		return 0;
+	}
+
+	strcpy(loader_version_str, version);
+	printk(KERN_INFO PFX "loader version is '%s'\n", loader_version_str);
+	return 0;
+}
+__tagtable(ATAG_LOADER_VERSION, fbxgw1r_parse_loader_version);
+
+static int __init fbxgw1r_parse_boot_info(const struct tag *tag)
+{
+	if (tag->u.boot_info.erase_nvram) {
+		printk(KERN_INFO PFX "loader asked for nvram erase.\n");
+		loader_erase_nvram = 1;
+	}
+	if (tag->u.boot_info.bank0_forced) {
+		printk(KERN_INFO PFX "loader user forced a bank0 boot.\n");
+		loader_bank0_forced = 1;
+	}
+	return 0;
+}
+__tagtable(ATAG_BOOT_INFO, fbxgw1r_parse_boot_info);
+
+MACHINE_START(FBXGW1R, "Freebox Gateway version 1")
+	.boot_params	= 0x00000100,
+	.init_machine	= fbxgw1r_init,
+#ifdef CONFIG_CRASHZONE
+	.reserve	= fbxgw1r_reserve_crash_zone,
+#endif
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/arch/arm/mach-kirkwood/include/mach/board_fbxgw1r.h	2011-07-19 15:41:05.454933568 +0200
@@ -0,0 +1,41 @@
+#ifndef BOARD_FBXGW1R_H_
+#define BOARD_FBXGW1R_H_
+
+/*
+ * board gpios
+ */
+#define GPIO_OLED_DATA_SELECT	7
+#define GPIO_SR_CLK		10
+#define GPIO_BCM_DOWN		11
+#define GPIO_SR_DIN		12
+#define GPIO_TEST_MODE		13
+#define GPIO_SFP_TXDIS		14
+#define GPIO_SR_LOAD		17
+#define GPIO_SW_RESET		28
+#define GPIO_SW_INT		29
+#define GPIO_SFP_PWRGOOD	34
+#define GPIO_SFP_TXFAULT	35
+#define GPIO_SPI_CS_BCM		36
+#define GPIO_SFP_PRESENCE	37
+#define GPIO_SFP_RXLOSS		38
+#define GPIO_BOARD_ID_0		43
+#define GPIO_EXP_RST		44
+#define GPIO_POS_SENSE		45
+#define GPIO_EXP_PWRGOOD	46
+#define GPIO_EXP_PRESENCE	47
+#define GPIO_KP_INT		48
+#define GPIO_BOARD_ID_1		49
+
+/*
+ * shift register outputs
+ */
+#define SROUT_SFP_PWREN		0
+#define SROUT_USB_RST		1
+#define SROUT_AUDIO_RST		2
+#define SROUT_EXP_PWREN		3
+#define SROUT_BCM_RST		4
+#define SROUT_PCIE_RST		5
+#define SROUT_KEYPAD_OLED_RST	6
+#define SROUT_OLED_PWREN	7
+
+#endif /* !BOARD_FBXGW1R_H_ */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/config	2011-09-09 18:27:33.211554930 +0200
@@ -0,0 +1,2580 @@
+#
+# Automatically generated make config: don't edit
+# Linux/arm 2.6.39.4 Kernel Configuration
+# Fri Sep  9 18:26:10 2011
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_SCHED_CLOCK=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE="/opt/toolchains/armeabi-uclibc-std-0.9.30.2-gcc-4.6.0-binutils-2.20.1/bin/arm-linux-"
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DMCRYPTATBOOT is not set
+# CONFIG_FBX_DECRYPT_INITRD is not set
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CGROUP_NS is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_RESOURCE_COUNTERS is not set
+# CONFIG_CGROUP_SCHED is not set
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_RD_GZIP is not set
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_PCI_QUIRKS is not set
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+CONFIG_ARCH_KIRKWOOD=y
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5P6442 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS4 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_GPIO_PCA953X is not set
+
+#
+# Marvell Kirkwood Implementations
+#
+# CONFIG_MACH_DB88F6281_BP is not set
+# CONFIG_MACH_RD88F6192_NAS is not set
+# CONFIG_MACH_RD88F6281 is not set
+# CONFIG_MACH_MV88F6281GTW_GE is not set
+# CONFIG_MACH_SHEEVAPLUG is not set
+# CONFIG_MACH_ESATA_SHEEVAPLUG is not set
+# CONFIG_MACH_GURUPLUG is not set
+# CONFIG_MACH_TS219 is not set
+# CONFIG_MACH_TS41X is not set
+# CONFIG_MACH_DOCKSTAR is not set
+# CONFIG_MACH_OPENRD_BASE is not set
+# CONFIG_MACH_OPENRD_CLIENT is not set
+# CONFIG_MACH_OPENRD_ULTIMATE is not set
+# CONFIG_MACH_NETSPACE_V2 is not set
+# CONFIG_MACH_INETSPACE_V2 is not set
+# CONFIG_MACH_NETSPACE_MAX_V2 is not set
+# CONFIG_MACH_D2NET_V2 is not set
+# CONFIG_MACH_NET2BIG_V2 is not set
+# CONFIG_MACH_NET5BIG_V2 is not set
+# CONFIG_MACH_T5325 is not set
+CONFIG_MACH_FBXGW1R=y
+CONFIG_MACH_FBXGW1R_ETHSW_CONFIG=y
+CONFIG_MACH_FBXGW1R_ETHSW_CONFIG_VLAN=y
+CONFIG_MACH_FBXGW1R_PARTS_WRITE_ALL=y
+# CONFIG_MACH_FBXGW1R_NAND_SAFE_READ_TIMINGS is not set
+# CONFIG_MACH_FBXGW1R_NAND_SAFE_WRITE_TIMINGS is not set
+
+#
+# System MMU
+#
+CONFIG_PLAT_ORION=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_FEROCEON=y
+# CONFIG_CPU_FEROCEON_OLD_ID is not set
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5T=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_FEROCEON=y
+CONFIG_CPU_TLB_FEROCEON=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_CACHE_FEROCEON_L2=y
+# CONFIG_CACHE_FEROCEON_L2_WRITETHROUGH is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+
+#
+# Bus support
+#
+CONFIG_PCI=y
+CONFIG_PCI_SYSCALL=y
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_IOV is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+# CONFIG_PCIEASPM is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/nfs ro ip=:::::eth0.41:dhcp console=ttyS1,115200 user_debug=29"
+CONFIG_CMDLINE_FORCE=y
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM_RUNTIME is not set
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_NETSKBPAD=40
+CONFIG_NETRXTHREAD=y
+CONFIG_NETRXTHREAD_RX_QUEUE=2
+CONFIG_NETRXTHREAD_MAX_PROCESS=8
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_INET_XFRM_GC_THRESH=1024
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_SIT_FBX6TO4=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+# CONFIG_BRIDGE_NETFILTER is not set
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+# CONFIG_NF_CONNTRACK_MARK is not set
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+CONFIG_NF_CT_PROTO_GRE=m
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=m
+# CONFIG_NF_CONNTRACK_SANE is not set
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=y
+# CONFIG_NF_CT_NETLINK is not set
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+# CONFIG_NETFILTER_XT_CONNMARK is not set
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+CONFIG_NETFILTER_XT_TARGET_DSCP=y
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+# CONFIG_NETFILTER_XT_MATCH_HL is not set
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_FFN=y
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+# CONFIG_IP_NF_TARGET_LOG is not set
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NF_NAT_PROTO_GRE=m
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=m
+CONFIG_NF_NAT_TFTP=y
+# CONFIG_NF_NAT_AMANDA is not set
+CONFIG_NF_NAT_PPTP=m
+CONFIG_NF_NAT_H323=m
+CONFIG_NF_NAT_SIP=m
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=y
+# CONFIG_NF_CONNTRACK_IPV6 is not set
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+# CONFIG_IP6_NF_TARGET_LOG is not set
+CONFIG_IP6_NF_FILTER=y
+# CONFIG_IP6_NF_TARGET_REJECT is not set
+CONFIG_IP6_NF_MANGLE=y
+# CONFIG_IP6_NF_RAW is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_FBXATM=y
+CONFIG_FBXATM_REMOTE=y
+CONFIG_FBXATM_STACK=y
+# CONFIG_FBXATM_REMOTE_STUB is not set
+CONFIG_FBXATM_REMOTE_DRIVER=y
+CONFIG_STP=y
+CONFIG_BRIDGE=y
+# CONFIG_BRIDGE_IGMP_SNOOPING is not set
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+CONFIG_NET_SCH_PRIO=y
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+CONFIG_NET_SCH_SFQ=y
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+CONFIG_NET_SCH_INGRESS=y
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+CONFIG_NET_CLS_U32=y
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CLS_U32_MARK is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+# CONFIG_NET_EMATCH is not set
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+CONFIG_CFG80211_INTERNAL_REGDB=y
+# CONFIG_CFG80211_WEXT is not set
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+CONFIG_MAC80211_HAS_RC=y
+# CONFIG_MAC80211_RC_PID is not set
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_FREEBOX_PROCFS=y
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+CONFIG_MTD_ERASE_PRINTK=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+# CONFIG_MTD_FBX6HD_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_DATAFLASH is not set
+CONFIG_MTD_M25P80=y
+# CONFIG_M25PXX_USE_FAST_READ is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_VERIFY_WRITE=y
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_FORCE_BAD_BLOCK_ERASE is not set
+# CONFIG_MTD_NAND_DENALI is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_RICOH is not set
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_CAFE is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_ORION=y
+# CONFIG_MTD_NAND_DENALI_FBX is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_FREEBOX_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_INTELCE_PIC16PMU is not set
+# CONFIG_BMP085 is not set
+# CONFIG_PCH_PHUB is not set
+CONFIG_CRASHZONE=y
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=m
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# RemoTI support
+#
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+# CONFIG_SATA_AHCI is not set
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_SX4 is not set
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+# CONFIG_ATA_PIIX is not set
+CONFIG_SATA_MV=m
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARASAN_CF is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_SC1200 is not set
+# CONFIG_PATA_SCH is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_PATA_RZ1000 is not set
+
+#
+# Generic fallback / legacy drivers
+#
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_LEGACY is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+CONFIG_NETDEVICES=y
+# CONFIG_IFB is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+CONFIG_MII=y
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+CONFIG_BROADCOM_PHY=y
+# CONFIG_BCM63XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+# CONFIG_AX88796 is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_KSZ884X_PCI is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_R6040 is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SMSC9420 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_SC92031 is not set
+# CONFIG_ATL2 is not set
+# CONFIG_FTMAC100 is not set
+CONFIG_NETDEV_1000=y
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IP1000 is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+# CONFIG_CNIC is not set
+CONFIG_MV643XX_ETH=y
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_JME is not set
+# CONFIG_STMMAC_ETH is not set
+# CONFIG_PCH_GBE is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
+CONFIG_WLAN=y
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_ATMEL is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_RTL8180 is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_ADM8211 is not set
+# CONFIG_MAC80211_HWSIM is not set
+CONFIG_MWL8K=m
+# CONFIG_ATH_COMMON is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_IPW2100 is not set
+# CONFIG_IWLAGN is not set
+# CONFIG_IWL4965 is not set
+# CONFIG_IWL3945 is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_P54_COMMON is not set
+# CONFIG_RT2X00 is not set
+# CONFIG_RTL8192CE is not set
+# CONFIG_RTL8192CU is not set
+# CONFIG_WL1251 is not set
+# CONFIG_WL12XX_MENU is not set
+# CONFIG_ZD1211RW is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+# CONFIG_PPP_ASYNC is not set
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPP_DEFLATE is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
+CONFIG_PPPOE=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NET_FC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+CONFIG_INPUT_SMSC_CAP1066=m
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_DEVKMEM is not set
+# CONFIG_DEVPHYSMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+# CONFIG_SERIAL_MFD_HSU is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_INTEL_MID is not set
+CONFIG_I2C_MV64XXX=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+# CONFIG_I2C_EG20T is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+CONFIG_SPI_DEBUG=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+CONFIG_SPI_ORION=y
+CONFIG_SPI_TDM_ORION=y
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_TOPCLIFF_PCH is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+# CONFIG_GPIO_BASIC_MMIO is not set
+# CONFIG_GPIO_IT8761E is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_ML_IOH is not set
+# CONFIG_GPIO_RDC321X is not set
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+CONFIG_FREEBOX_GPIO=y
+# CONFIG_FREEBOX_JTAG is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+CONFIG_HWMON_VID=y
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+CONFIG_SENSORS_ADT7475=y
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+CONFIG_SENSORS_LM85=y
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_THERMAL is not set
+CONFIG_FREEBOX_WATCHDOG=y
+CONFIG_FREEBOX_WATCHDOG_CHAR=y
+CONFIG_FREEBOX_WATCHDOG_ORION=y
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+# CONFIG_MFD_SUPPORT is not set
+# CONFIG_REGULATOR is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+# CONFIG_MEDIA_CONTROLLER is not set
+# CONFIG_VIDEO_DEV is not set
+CONFIG_DVB_CORE=y
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+CONFIG_RC_CORE=y
+CONFIG_LIRC=y
+# CONFIG_RC_MAP is not set
+# CONFIG_IR_NEC_DECODER is not set
+# CONFIG_IR_RC5_DECODER is not set
+# CONFIG_IR_RC6_DECODER is not set
+# CONFIG_IR_JVC_DECODER is not set
+# CONFIG_IR_SONY_DECODER is not set
+# CONFIG_IR_RC5_SZ_DECODER is not set
+# CONFIG_IR_LIRC_CODEC is not set
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_RC_LOOPBACK is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+
+#
+# Customize TV tuners
+#
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+CONFIG_DVB_MAX_ADAPTERS=8
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+CONFIG_DVB_CAPTURE_DRIVERS=y
+
+#
+# Supported SAA7146 based PCI Adapters
+#
+# CONFIG_TTPCI_EEPROM is not set
+# CONFIG_DVB_BUDGET_CORE is not set
+
+#
+# Supported USB Adapters
+#
+CONFIG_DVB_USB=y
+# CONFIG_DVB_USB_DEBUG is not set
+# CONFIG_DVB_USB_A800 is not set
+# CONFIG_DVB_USB_DIBUSB_MB is not set
+# CONFIG_DVB_USB_DIBUSB_MC is not set
+CONFIG_DVB_USB_DIB0700=m
+# CONFIG_DVB_USB_UMT_010 is not set
+# CONFIG_DVB_USB_CXUSB is not set
+# CONFIG_DVB_USB_M920X is not set
+# CONFIG_DVB_USB_GL861 is not set
+# CONFIG_DVB_USB_AU6610 is not set
+# CONFIG_DVB_USB_DIGITV is not set
+# CONFIG_DVB_USB_VP7045 is not set
+# CONFIG_DVB_USB_VP702X is not set
+# CONFIG_DVB_USB_GP8PSK is not set
+# CONFIG_DVB_USB_NOVA_T_USB2 is not set
+# CONFIG_DVB_USB_TTUSB2 is not set
+# CONFIG_DVB_USB_DTT200U is not set
+# CONFIG_DVB_USB_OPERA1 is not set
+# CONFIG_DVB_USB_AF9005 is not set
+# CONFIG_DVB_USB_DW2102 is not set
+# CONFIG_DVB_USB_CINERGY_T2 is not set
+# CONFIG_DVB_USB_ANYSEE is not set
+# CONFIG_DVB_USB_DTV5100 is not set
+# CONFIG_DVB_USB_AF9015 is not set
+# CONFIG_DVB_USB_CE6230 is not set
+# CONFIG_DVB_USB_FRIIO is not set
+# CONFIG_DVB_USB_EC168 is not set
+# CONFIG_DVB_USB_AZ6027 is not set
+# CONFIG_DVB_USB_LME2510 is not set
+# CONFIG_DVB_USB_TECHNISAT_USB2 is not set
+# CONFIG_DVB_TTUSB_BUDGET is not set
+# CONFIG_DVB_TTUSB_DEC is not set
+# CONFIG_SMS_SIANO_MDTV is not set
+
+#
+# Supported FlexCopII (B2C2) Adapters
+#
+# CONFIG_DVB_B2C2_FLEXCOP is not set
+
+#
+# Supported BT878 Adapters
+#
+
+#
+# Supported Pluto2 Adapters
+#
+# CONFIG_DVB_PLUTO2 is not set
+
+#
+# Supported SDMC DM1105 Adapters
+#
+# CONFIG_DVB_DM1105 is not set
+
+#
+# Supported Earthsoft PT1 Adapters
+#
+# CONFIG_DVB_PT1 is not set
+
+#
+# Supported Mantis Adapters
+#
+# CONFIG_MANTIS_CORE is not set
+
+#
+# Supported nGene Adapters
+#
+# CONFIG_DVB_NGENE is not set
+
+#
+# Supported DVB Frontends
+#
+CONFIG_DVB_FE_CUSTOMISE=y
+
+#
+# Customise DVB Frontends
+#
+
+#
+# Multistandard (satellite) frontends
+#
+# CONFIG_DVB_STB0899 is not set
+# CONFIG_DVB_STB6100 is not set
+# CONFIG_DVB_STV090x is not set
+# CONFIG_DVB_STV6110x is not set
+
+#
+# DVB-S (satellite) frontends
+#
+# CONFIG_DVB_CX24110 is not set
+# CONFIG_DVB_CX24123 is not set
+# CONFIG_DVB_MT312 is not set
+# CONFIG_DVB_ZL10036 is not set
+# CONFIG_DVB_ZL10039 is not set
+# CONFIG_DVB_S5H1420 is not set
+# CONFIG_DVB_STV0288 is not set
+# CONFIG_DVB_STB6000 is not set
+# CONFIG_DVB_STV0299 is not set
+# CONFIG_DVB_STV6110 is not set
+# CONFIG_DVB_STV0900 is not set
+# CONFIG_DVB_TDA8083 is not set
+# CONFIG_DVB_TDA10086 is not set
+# CONFIG_DVB_TDA8261 is not set
+# CONFIG_DVB_VES1X93 is not set
+# CONFIG_DVB_TUNER_ITD1000 is not set
+# CONFIG_DVB_TUNER_CX24113 is not set
+# CONFIG_DVB_TDA826X is not set
+# CONFIG_DVB_TUA6100 is not set
+# CONFIG_DVB_CX24116 is not set
+# CONFIG_DVB_SI21XX is not set
+# CONFIG_DVB_DS3000 is not set
+# CONFIG_DVB_MB86A16 is not set
+
+#
+# DVB-T (terrestrial) frontends
+#
+# CONFIG_DVB_SP8870 is not set
+# CONFIG_DVB_SP887X is not set
+# CONFIG_DVB_CX22700 is not set
+# CONFIG_DVB_CX22702 is not set
+# CONFIG_DVB_S5H1432 is not set
+# CONFIG_DVB_DRX397XD is not set
+# CONFIG_DVB_L64781 is not set
+# CONFIG_DVB_TDA1004X is not set
+# CONFIG_DVB_NXT6000 is not set
+# CONFIG_DVB_MT352 is not set
+# CONFIG_DVB_ZL10353 is not set
+# CONFIG_DVB_DIB3000MB is not set
+# CONFIG_DVB_DIB3000MC is not set
+# CONFIG_DVB_DIB7000M is not set
+CONFIG_DVB_DIB7000P=y
+# CONFIG_DVB_DIB9000 is not set
+# CONFIG_DVB_TDA10048 is not set
+# CONFIG_DVB_AF9013 is not set
+# CONFIG_DVB_EC100 is not set
+# CONFIG_DVB_STV0367 is not set
+
+#
+# DVB-C (cable) frontends
+#
+# CONFIG_DVB_VES1820 is not set
+# CONFIG_DVB_TDA10021 is not set
+# CONFIG_DVB_TDA10023 is not set
+# CONFIG_DVB_STV0297 is not set
+
+#
+# ATSC (North American/Korean Terrestrial/Cable DTV) frontends
+#
+# CONFIG_DVB_NXT200X is not set
+# CONFIG_DVB_OR51211 is not set
+# CONFIG_DVB_OR51132 is not set
+# CONFIG_DVB_BCM3510 is not set
+# CONFIG_DVB_LGDT330X is not set
+# CONFIG_DVB_LGDT3305 is not set
+# CONFIG_DVB_S5H1409 is not set
+# CONFIG_DVB_S5H1411 is not set
+
+#
+# ISDB-T (terrestrial) frontends
+#
+# CONFIG_DVB_S921 is not set
+# CONFIG_DVB_DIB8000 is not set
+# CONFIG_DVB_MB86A20S is not set
+
+#
+# Digital terrestrial only tuners/PLL
+#
+# CONFIG_DVB_PLL is not set
+CONFIG_DVB_TUNER_DIB0070=y
+# CONFIG_DVB_TUNER_DIB0090 is not set
+
+#
+# SEC control devices for DVB-S
+#
+# CONFIG_DVB_LNBP21 is not set
+# CONFIG_DVB_ISL6405 is not set
+# CONFIG_DVB_ISL6421 is not set
+# CONFIG_DVB_ISL6423 is not set
+# CONFIG_DVB_LGS8GL5 is not set
+# CONFIG_DVB_LGS8GXX is not set
+# CONFIG_DVB_ATBM8830 is not set
+# CONFIG_DVB_TDA665x is not set
+# CONFIG_DVB_IX2505V is not set
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGA_ARB is not set
+# CONFIG_DRM is not set
+# CONFIG_STUB_POULSBO is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_BACKLIGHT=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+CONFIG_FB_SSD1327=y
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_RAWMIDI=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+CONFIG_SND_VERBOSE_PROCFS=y
+CONFIG_SND_VERBOSE_PRINTK=y
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_PCI is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=y
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_WHCI_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=y
+CONFIG_USB_PRINTER=y
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_EZUSB is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+CONFIG_USB_SERIAL_CP210X=y
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SAMBA is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_NFC_DEVICES is not set
+# CONFIG_FREEBOX_PANEL is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4_FS_XATTR is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_XFS_FS=y
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=850
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+# CONFIG_NTFS_RW is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_RAMFS_XATTR is not set
+# CONFIG_RAMFS_XATTR_USER is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+CONFIG_HFS_FS=y
+CONFIG_HFSPLUS_FS=y
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=y
+CONFIG_SQUASHFS=y
+# CONFIG_SQUASHFS_XATTR is not set
+# CONFIG_SQUASHFS_LZO is not set
+# CONFIG_SQUASHFS_XZ is not set
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+CONFIG_NFSD=y
+CONFIG_NFSD_DEPRECATED=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+CONFIG_NFSD_V4=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC=y
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=1
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_DEBUG_LIST=y
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+# CONFIG_CRYPTO_BUILTIN_TEST is not set
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+# CONFIG_CRYPTO_GCM is not set
+CONFIG_CRYPTO_SEQIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_AVERAGE=y
+CONFIG_FBXSERIAL=y
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxgpio./fbxgpio_core.c linux-2.6.39.4-fbx/drivers/fbxgpio/fbxgpio_core.c
--- linux-2.6.39.4-fbx/drivers/fbxgpio./fbxgpio_core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxgpio/fbxgpio_core.c	2011-05-24 18:15:33.725810957 +0200
@@ -0,0 +1,312 @@
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/fbxgpio_core.h>
+
+#define PFX	"fbxgpio_core: "
+
+/* #define DEBUG */
+#ifdef DEBUG
+#define dprint(Fmt, Arg...)	printk(PFX Fmt, Arg)
+#else
+#define dprint(Fmt, Arg...)	do { } while (0)
+#endif
+
+static struct class *fbxgpio_class;
+
+/*
+ * show direction in for gpio associated with class_device dev.
+ */
+static ssize_t show_direction(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct fbxgpio_pin *p;
+	int dir, ret = 0;
+
+	p = dev_get_drvdata(dev);
+
+	if (p->ops->get_direction)
+		dir = p->ops->get_direction(p->pin_num);
+	else
+		dir = p->direction;
+
+	switch (dir) {
+	case GPIO_DIR_IN:
+		ret += sprintf(buf, "input\n");
+		break;
+	case GPIO_DIR_OUT:
+		ret += sprintf(buf, "output\n");
+		break;
+	default:
+		ret += sprintf(buf, "unknown\n");
+		break;
+	}
+	return ret;
+}
+
+/*
+ * store direction. return -EINVAL if direction string is bad. return
+ * -EPERM if flag FBXGPIO_PIN_DIR_RW is set in flags.
+ */
+static ssize_t store_direction(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int dir;
+	struct fbxgpio_pin *p;
+	int match_len = 0;
+	int i;
+	static const char *word_match[] = {
+		[GPIO_DIR_IN] = "input",
+		[GPIO_DIR_OUT] = "output",
+	};
+
+	if (*buf == ' ' || *buf == '\t' || *buf == '\r' || *buf == '\n')
+		/* silently eat any spaces/tab/linefeed/carriagereturn */
+		return 1;
+
+	p = dev_get_drvdata(dev);
+	if (!(p->flags & FBXGPIO_PIN_DIR_RW)) {
+		dprint("pin %s direction is read only.\n", p->pin_name);
+		return -EPERM;
+	}
+	dir = 0;
+	for (i = 0; i < 2; ++i) {
+		if (size >= strlen(word_match[i]) &&
+		    !strncmp(buf, word_match[i], strlen(word_match[i]))) {
+			dir = i;
+			match_len = strlen(word_match[i]);
+			break ;
+		}
+	}
+	if (i == 2)
+		return -EINVAL;
+
+	p->ops->set_direction(p->pin_num, dir);
+	return match_len;
+}
+
+/*
+ * show input data for input gpio pins.
+ */
+static ssize_t show_datain(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct fbxgpio_pin *p;
+
+	p = dev_get_drvdata(dev);
+	if (p->direction == GPIO_DIR_OUT)
+		return -EINVAL;
+	val = p->ops->get_datain(p->pin_num);
+
+	if (p->flags & FBXGPIO_PIN_REVERSE_POL)
+		val = 1 - val;
+	return sprintf(buf, "%i\n", val);
+}
+
+/*
+ * show output data for output gpio pins.
+ */
+static ssize_t show_dataout(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct fbxgpio_pin *p;
+
+	p = dev_get_drvdata(dev);
+	if (p->direction == GPIO_DIR_IN)
+		return -EINVAL;
+	if (p->ops->get_dataout)
+		val = p->ops->get_dataout(p->pin_num);
+	else
+		val = p->cur_dataout;
+
+	if (p->flags & FBXGPIO_PIN_REVERSE_POL)
+		val = 1 - val;
+	return sprintf(buf, "%i\n", val);
+}
+
+/*
+ * store new dataout value for output gpio pins.
+ */
+static ssize_t store_dataout(struct device *dev,
+	    struct device_attribute *attr, const char *buf, size_t size)
+{
+	int val;
+	struct fbxgpio_pin *p;
+
+	if (*buf == ' ' || *buf == '\t' || *buf == '\r' || *buf == '\n')
+		/* silently eat any spaces/tab/linefeed/carriagereturn */
+		return 1;
+
+	p = dev_get_drvdata(dev);
+
+	if (p->direction != GPIO_DIR_OUT)
+		return -EINVAL;
+
+	switch (*buf) {
+	case '0':
+		val = 0;
+		break ;
+	case '1':
+		val = 1;
+		break ;
+	default:
+		return -EINVAL;
+	}
+
+	p->cur_dataout = val;
+
+	if (p->flags & FBXGPIO_PIN_REVERSE_POL)
+		val = 1 - val;
+	p->ops->set_dataout(p->pin_num, val);
+	return 1;
+}
+
+/*
+ * show pin number associated with gpio pin.
+ */
+static ssize_t show_pinnum(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct fbxgpio_pin *p;
+
+	p = dev_get_drvdata(dev);
+	return sprintf(buf, "%i\n", p->pin_num);
+}
+
+/*
+ * attribute list associated with each class device.
+ */
+static struct device_attribute gpio_attributes[] = {
+	__ATTR(direction, 0600, show_direction, store_direction),
+	__ATTR(data_in,   0400, show_datain, NULL),
+	__ATTR(data_out,  0600, show_dataout, store_dataout),
+	__ATTR(pin_num,   0400, show_pinnum, NULL),
+};
+
+static int fbxgpio_register_pin(struct platform_device *ppdev,
+				struct fbxgpio_pin *pin)
+{
+	struct device *dev;
+	int i, ret;
+
+	dprint("registering pin %s\n", pin->pin_name);
+
+	/* ensure ops is valid */
+	if (!pin->ops) {
+		printk(KERN_ERR PFX "no operation set for pin %s\n",
+		       pin->pin_name);
+		return -EINVAL;
+	}
+
+	dev = device_create(fbxgpio_class, &ppdev->dev, 0, pin,
+			    "%s", pin->pin_name);
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+
+	for (i = 0; i < ARRAY_SIZE(gpio_attributes); i++) {
+		ret = device_create_file(dev, &gpio_attributes[i]);
+		if (ret)
+			goto err_out;
+	}
+
+	/* ensure pin direction matches hardware state */
+	if (pin->ops->get_direction &&
+	    pin->direction != pin->ops->get_direction(pin->pin_num)) {
+		printk(KERN_WARNING PFX "pin %s default direction does not "
+		       "match current hardware state, fixing.\n",
+		       pin->pin_name);
+		pin->ops->set_direction(pin->pin_num, pin->direction);
+	}
+	pin->dev = dev;
+	return 0;
+
+err_out:
+	for (; i >= 0; i--)
+		device_remove_file(dev, &gpio_attributes[i]);
+	device_unregister(dev);
+	return ret;
+}
+
+static void fbxgpio_unregister_pin(struct fbxgpio_pin *pin)
+{
+	struct device *dev;
+	int i;
+
+	dprint("unregistering pin %s\n", pin->pin_name);
+	dev = pin->dev;
+	pin->dev = NULL;
+
+	for (i = 0; i < ARRAY_SIZE(gpio_attributes); i++)
+		device_remove_file(dev, &gpio_attributes[i]);
+	device_unregister(dev);
+}
+
+static int fbxgpio_platform_probe(struct platform_device *pdev)
+{
+	struct fbxgpio_pin *p;
+	int err = 0;
+
+	p = pdev->dev.platform_data;
+	while (p->pin_name) {
+		err = fbxgpio_register_pin(pdev, p);
+		if (err)
+			return err;
+		++p;
+	}
+	return 0;
+}
+
+static int fbxgpio_platform_remove(struct platform_device *pdev)
+{
+	struct fbxgpio_pin *p;
+
+	p = pdev->dev.platform_data;
+	while (p->pin_name) {
+		fbxgpio_unregister_pin(p);
+		++p;
+	}
+	return 0;
+}
+
+static struct platform_driver fbxgpio_platform_driver =
+{
+	.probe	= fbxgpio_platform_probe,
+	.remove	= fbxgpio_platform_remove,
+	.driver	= {
+		.name	= "fbxgpio",
+	}
+};
+
+static int __init fbxgpio_init(void)
+{
+	int ret;
+
+	fbxgpio_class = class_create(THIS_MODULE, "fbxgpio");
+	if (IS_ERR(fbxgpio_class))
+		return PTR_ERR(fbxgpio_class);
+
+	ret = platform_driver_register(&fbxgpio_platform_driver);
+	if (ret) {
+		printk(KERN_ERR PFX "unable to register fbxgpio driver.\n");
+		class_destroy(fbxgpio_class);
+		return ret;
+	}
+	return 0;
+}
+
+static void __exit fbxgpio_exit(void)
+{
+	platform_driver_unregister(&fbxgpio_platform_driver);
+	class_destroy(fbxgpio_class);
+}
+
+subsys_initcall(fbxgpio_init);
+module_exit(fbxgpio_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Nicolas Schichan <nicolas.schichan@freebox.fr>");
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxgpio./Kconfig linux-2.6.39.4-fbx/drivers/fbxgpio/Kconfig
--- linux-2.6.39.4-fbx/drivers/fbxgpio./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxgpio/Kconfig	2011-05-24 18:15:33.725810957 +0200
@@ -0,0 +1,3 @@
+config FREEBOX_GPIO
+	tristate "Freebox GPIO control interface"
+	default n
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxgpio./Makefile linux-2.6.39.4-fbx/drivers/fbxgpio/Makefile
--- linux-2.6.39.4-fbx/drivers/fbxgpio./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxgpio/Makefile	2011-05-24 18:15:33.725810957 +0200
@@ -0,0 +1 @@
+obj-$(CONFIG_FREEBOX_GPIO)	+= fbxgpio_core.o
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxjtag./Kconfig linux-2.6.39.4-fbx/drivers/fbxjtag/Kconfig
--- linux-2.6.39.4-fbx/drivers/fbxjtag./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxjtag/Kconfig	2011-05-24 18:15:33.725810957 +0200
@@ -0,0 +1,3 @@
+config FREEBOX_JTAG
+	tristate "Freebox JTAG control interface"
+	default n
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxjtag./Makefile linux-2.6.39.4-fbx/drivers/fbxjtag/Makefile
--- linux-2.6.39.4-fbx/drivers/fbxjtag./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxjtag/Makefile	2011-05-24 18:15:33.725810957 +0200
@@ -0,0 +1 @@
+obj-$(CONFIG_FREEBOX_JTAG)	+= fbxjtag.o
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxmtd./Kconfig linux-2.6.39.4-fbx/drivers/fbxmtd/Kconfig
--- linux-2.6.39.4-fbx/drivers/fbxmtd./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxmtd/Kconfig	2011-05-24 18:15:33.725810957 +0200
@@ -0,0 +1,41 @@
+menuconfig FREEBOX_MTD
+	tristate "Freebox Memory Technology Devices (FBXMTD) support"
+
+if FREEBOX_MTD
+
+config FREEBOX_MTD_BACKEND_AMD
+	bool "Support for AMD compatible flash"
+
+config FREEBOX_MTD_BACKEND_INTEL
+	bool "Support for Intel Strataflash"
+
+config FREEBOX_MTD_BLK
+	tristate "Block device access to fbxmtd"
+	depends on BLOCK
+
+config FREEBOX_MTD_CHAR
+	tristate "Character device access to fbxmtd"
+
+
+comment "Mapping drivers"
+
+#
+# Generic mapping driver.
+#
+config FREEBOX_MTD_MAP_DRV_FBX
+	tristate "Freebox mapping Driver."
+	select CRC32
+
+config FREEBOX_MTD_MAP_DRV_BCM963XX
+	tristate "Broadcom 963xx flash format"
+	select CRC32
+
+#
+# Freebox MTD Map Control interface
+#
+config FREEBOX_MTD_MAP_IOCTL
+	tristate "IOCTL control interface"
+	depends on FREEBOX_MTD_MAP_DRV_FBX
+
+endif
+
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxmtd./Makefile linux-2.6.39.4-fbx/drivers/fbxmtd/Makefile
--- linux-2.6.39.4-fbx/drivers/fbxmtd./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxmtd/Makefile	2011-05-24 18:15:33.725810957 +0200
@@ -0,0 +1,24 @@
+
+# core support
+obj-$(CONFIG_FREEBOX_MTD) += fbxmtd.o
+
+fbxmtd-objs += fbxmtd_core.o fbxmtd_core_io.o
+ifeq ($(CONFIG_FREEBOX_MTD_BACKEND_AMD),y)
+fbxmtd-objs += fbxmtd_core_amd.o
+endif
+
+ifeq ($(CONFIG_FREEBOX_MTD_BACKEND_INTEL),y)
+fbxmtd-objs += fbxmtd_core_intel.o
+endif
+
+# generic character device access support (r/w with read erase modify write)
+obj-$(CONFIG_FREEBOX_MTD_CHAR) += fbxmtd_char.o
+fbxmtd_char-objs += fbxmtd_char_dev.o
+
+# generic r/o block device access support
+obj-$(CONFIG_FREEBOX_MTD_BLK) += fbxmtd_blk.o
+fbxmtd_blk-objs += fbxmtd_blk_dev.o
+
+obj-$(CONFIG_FREEBOX_MTD_MAP_DRV_FBX) += fbxmtd_map_drv_fbx.o
+obj-$(CONFIG_FREEBOX_MTD_MAP_DRV_BCM963XX) += fbxmtd_map_drv_bcm963xx.o
+obj-$(CONFIG_FREEBOX_MTD_MAP_IOCTL) += fbxmtd_map_ioctl.o
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxpanel./Kconfig linux-2.6.39.4-fbx/drivers/fbxpanel/Kconfig
--- linux-2.6.39.4-fbx/drivers/fbxpanel./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxpanel/Kconfig	2011-05-24 18:15:33.725810957 +0200
@@ -0,0 +1,13 @@
+menuconfig FREEBOX_PANEL
+	tristate "Freebox Panel Management"
+	default n
+
+if FREEBOX_PANEL
+
+config FREEBOX_PANEL_HW_PIC_FBX
+	tristate "I2C PIC-based Panel driver."
+	default n
+	select I2C
+
+endif
+
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxpanel./Makefile linux-2.6.39.4-fbx/drivers/fbxpanel/Makefile
--- linux-2.6.39.4-fbx/drivers/fbxpanel./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxpanel/Makefile	2011-05-24 18:15:33.725810957 +0200
@@ -0,0 +1,5 @@
+obj-$(CONFIG_FREEBOX_PANEL)	+= fbxpanel.o
+
+fbxpanel-objs = fbxpanel_class.o fbxpanel_anim.o
+
+obj-$(CONFIG_FREEBOX_PANEL_HW_PIC_FBX)	+= fbxpanel_hw_pic_fbx.o
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxprocfs./fbxprocfs.c linux-2.6.39.4-fbx/drivers/fbxprocfs/fbxprocfs.c
--- linux-2.6.39.4-fbx/drivers/fbxprocfs./fbxprocfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxprocfs/fbxprocfs.c	2011-06-15 18:56:42.015452142 +0200
@@ -0,0 +1,205 @@
+/*
+ * Freebox ProcFs interface
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/list.h>
+
+#include <linux/fbxprocfs.h>
+
+#define PFX	"fbxprocfs: "
+
+
+static struct list_head clients;
+static struct mutex clients_mutex;
+
+static struct proc_dir_entry *root;
+
+/*
+ * register  a  fbxprocfs client  with  given  dirname, caller  should
+ * consider returned struct opaque
+ */
+struct fbxprocfs_client *fbxprocfs_add_client(const char *dirname,
+					      struct module *owner)
+{
+	struct fbxprocfs_client *ret, *p;
+
+	ret = NULL;
+	mutex_lock(&clients_mutex);
+
+	/* check for duplicate */
+	list_for_each_entry(p, &clients, list) {
+		if (!strcmp(dirname, p->dirname))
+			goto out;
+	}
+
+	if (!(ret = kmalloc(sizeof (*ret), GFP_KERNEL))) {
+		printk(KERN_ERR PFX "kmalloc failed\n");
+		goto out;
+	}
+
+	/* try to create client directory */
+	if (!(ret->dir = proc_mkdir(dirname, root))) {
+		printk(KERN_ERR PFX "can't create %s dir\n", dirname);
+		kfree(ret);
+		ret = NULL;
+		goto out;
+	}
+
+	atomic_set(&ret->refcount, 1);
+	ret->dirname = dirname;
+	list_add(&ret->list, &clients);
+
+out:
+	mutex_unlock(&clients_mutex);
+	return ret;
+}
+
+/*
+ * unregister  a  fbxprocfs client, make sure usage count is zero
+ */
+int fbxprocfs_remove_client(struct fbxprocfs_client *client)
+{
+	int ret;
+
+	mutex_lock(&clients_mutex);
+
+	ret = 0;
+	if (atomic_read(&client->refcount) > 1) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	remove_proc_entry(client->dirname, root);
+	list_del(&client->list);
+	kfree(client);
+
+out:
+	mutex_unlock(&clients_mutex);
+	return ret;
+}
+
+/*
+ * remove given entries from client directory
+ */
+static int
+__remove_entries(struct fbxprocfs_client *client,
+		 const struct fbxprocfs_ro_desc *ro_desc,
+		 const struct fbxprocfs_rw_desc *rw_desc)
+{
+	int i;
+
+	for (i = 0; ro_desc && ro_desc[i].name; i++) {
+		remove_proc_entry(ro_desc[i].name, client->dir);
+		atomic_dec(&client->refcount);
+	}
+
+	for (i = 0; rw_desc && rw_desc[i].name; i++) {
+		remove_proc_entry(rw_desc[i].name, client->dir);
+		atomic_dec(&client->refcount);
+	}
+
+	return 0;
+}
+
+/*
+ * create given entries in client directory
+ */
+static int
+__create_entries(struct fbxprocfs_client *client,
+		 const struct fbxprocfs_ro_desc *ro_desc,
+		 const struct fbxprocfs_rw_desc *rw_desc)
+{
+	struct proc_dir_entry	*proc;
+	int			i;
+
+	for (i = 0; ro_desc && ro_desc[i].name; i++) {
+		if (!(proc = create_proc_read_entry(ro_desc[i].name, 0,
+						    client->dir,
+						    ro_desc[i].rfunc,
+						    (void *) ro_desc[i].id))) {
+			printk(KERN_ERR PFX "can't create %s/%s entry\n",
+			       client->dirname, ro_desc[i].name);
+			goto err;
+		}
+		atomic_inc(&client->refcount);
+	}
+
+	for (i = 0; rw_desc && rw_desc[i].name; i++) {
+		if (!(proc = create_proc_entry(rw_desc[i].name, 0,
+					       client->dir))) {
+			printk(KERN_ERR PFX "can't create %s/%s entry\n",
+			       client->dirname, ro_desc[i].name);
+			goto err;
+		}
+
+		proc->read_proc  = rw_desc[i].rfunc;
+		proc->write_proc = rw_desc[i].wfunc;
+		proc->data = (void *)rw_desc[i].id;
+		atomic_inc(&client->refcount);
+	}
+
+	return 0;
+
+err:
+	__remove_entries(client, ro_desc, rw_desc);
+	return -1;
+}
+
+int
+fbxprocfs_create_entries(struct fbxprocfs_client *client,
+			 const struct fbxprocfs_ro_desc *ro_desc,
+			 const struct fbxprocfs_rw_desc *rw_desc)
+{
+	int	ret;
+
+	ret = __create_entries(client, ro_desc, rw_desc);
+	return ret;
+}
+
+int
+fbxprocfs_remove_entries(struct fbxprocfs_client *client,
+			 const struct fbxprocfs_ro_desc *ro_desc,
+			 const struct fbxprocfs_rw_desc *rw_desc)
+{
+	int	ret;
+
+	ret = __remove_entries(client, ro_desc, rw_desc);
+	return ret;
+}
+
+
+static int __init
+fbxprocfs_init(void)
+{
+	INIT_LIST_HEAD(&clients);
+	mutex_init(&clients_mutex);
+
+	/* create freebox directory */
+	if (!(root = proc_mkdir("freebox", NULL))) {
+		printk(KERN_ERR PFX "can't create freebox/ dir\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static void __exit
+fbxprocfs_exit(void)
+{
+	remove_proc_entry("freebox", NULL);
+}
+
+module_init(fbxprocfs_init);
+module_exit(fbxprocfs_exit);
+
+EXPORT_SYMBOL(fbxprocfs_create_entries);
+EXPORT_SYMBOL(fbxprocfs_remove_entries);
+EXPORT_SYMBOL(fbxprocfs_add_client);
+EXPORT_SYMBOL(fbxprocfs_remove_client);
+
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+MODULE_AUTHOR("Maxime Bizon <mbizon@freebox.fr>");
+
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxprocfs./Kconfig linux-2.6.39.4-fbx/drivers/fbxprocfs/Kconfig
--- linux-2.6.39.4-fbx/drivers/fbxprocfs./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxprocfs/Kconfig	2011-05-24 18:15:33.725810957 +0200
@@ -0,0 +1,2 @@
+config FREEBOX_PROCFS
+	tristate "Freebox procfs interface"
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxprocfs./Makefile linux-2.6.39.4-fbx/drivers/fbxprocfs/Makefile
--- linux-2.6.39.4-fbx/drivers/fbxprocfs./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxprocfs/Makefile	2011-05-24 18:15:33.725810957 +0200
@@ -0,0 +1 @@
+obj-$(CONFIG_FREEBOX_PROCFS) += fbxprocfs.o
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxwatchdog./fbxwatchdog_char.c linux-2.6.39.4-fbx/drivers/fbxwatchdog/fbxwatchdog_char.c
--- linux-2.6.39.4-fbx/drivers/fbxwatchdog./fbxwatchdog_char.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxwatchdog/fbxwatchdog_char.c	2011-06-15 18:56:42.015452142 +0200
@@ -0,0 +1,218 @@
+/*
+ * add standard char device interface for fbxwatchdog.
+ */
+
+/*
+ * XXX: results are undefined if attemps are made to access watchdog
+ * from char device interface and sysfs at the same time.
+ */
+
+#define PFX "fbxwatchdog_char: "
+
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include "fbxwatchdog.h"
+
+#include <asm/uaccess.h>
+
+static struct fbxwatchdog *chardev_wdt;
+static unsigned long chardev_users;
+static unsigned long default_countdown = 60 * 1000;
+static int expect_close;
+
+/*
+ * we support the WDIOF_MAGICCLOSE: is the user writes 'V' to the device,
+ * the release method will stop the watchdog.
+ */
+static int
+wdt_write(struct file *file, const char *__user buf, size_t len, loff_t *ppos)
+{
+	int i;
+
+	if (!len)
+		return 0;
+
+	for (i = 0; i < len; ++i) {
+		char c;
+
+		if (get_user(c, buf + i))
+			return -EFAULT;
+		if (c == 'V')
+			expect_close = 1;
+	}
+	if (len)
+		chardev_wdt->countdown = default_countdown;
+	return len;
+}
+
+static long
+wdt_ioctl(struct file *file,
+	  unsigned int cmd, unsigned long arg)
+{
+	static const struct watchdog_info winfo = {
+		.options		= WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE |
+					  WDIOF_KEEPALIVEPING,
+		.firmware_version	= 0x42,
+		.identity		= "fbxwatchdog",
+	};
+	int tmp;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		/*
+		 * return watchdog information structure to userland.
+		 */
+		return copy_to_user((struct watchdog_info __user *)arg,
+				    &winfo, sizeof (winfo)) ? -EFAULT: 0;
+
+	case WDIOC_SETTIMEOUT:
+		/*
+		 * set watchdog timeout: if current countdown is
+		 * higher than timeout, set countdown to timeout
+		 * value.
+		 */
+		if (copy_from_user(&tmp, (void __user *) arg,
+				   sizeof (tmp))) {
+			return -EFAULT;
+		}
+		if (1000 * tmp < 0)
+			return -EINVAL;
+		default_countdown = 1000 * tmp;
+		if (chardev_wdt->countdown > default_countdown)
+			chardev_wdt->countdown = default_countdown;
+		return 0;
+
+	case WDIOC_GETTIMEOUT:
+		/*
+		 * get current timeout value.
+		 */
+		tmp = default_countdown / 1000;
+		return copy_to_user((void __user *)arg, &tmp,
+				    sizeof (tmp)) ? -EFAULT : 0;
+
+	case WDIOC_KEEPALIVE:
+		/*
+		 * ping watchdog.
+		 */
+		chardev_wdt->countdown = default_countdown;
+		return 0;
+
+	case WDIOC_GETTIMELEFT:
+		/*
+		 * return current countdown value to userland.
+		 */
+		tmp = chardev_wdt->countdown / 1000;
+		return copy_to_user((void __user *)arg, &tmp, sizeof (tmp)) ?
+		  -EFAULT : 0;
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+}
+
+/*
+ * called when remote process calls close(2) on watchdog fd or
+ * exit(2).
+ */
+static int
+wdt_release(struct inode *inode, struct file *file)
+{
+	unsigned long flags;
+
+	if (expect_close && chardev_wdt->enabled) {
+		spin_lock_irqsave(&chardev_wdt->lock, flags);
+		chardev_wdt->enabled = 0;
+		chardev_wdt->wdt_stop(chardev_wdt);
+		spin_unlock_irqrestore(&chardev_wdt->lock, flags);
+	} else
+		printk(KERN_CRIT PFX "unexpected close: not stopping "
+		       "watchdog.\n");
+	chardev_users = 0;
+	return 0;
+}
+
+/*
+ * open watchdog device file: the test_and_set_bit enforces the fact
+ * that only one process opens the watchdog device file as long as it
+ * does not try to fork(2). dup(2)/dup2(2) might be problematic
+ * too. thus, we assume that watchdogd will do "The right thing" and
+ * won't try to do anything too fancy with the fd opened to
+ * /dev/watchdog.
+ */
+static int wdt_open(struct inode *inode, struct file *file)
+{
+	unsigned long flags;
+
+	if (test_and_set_bit(1, &chardev_users))
+		return -EBUSY;
+
+	expect_close = 0;
+
+	/*
+	 * watchdog is to be enabled when opened.
+	 */
+	if (!chardev_wdt->enabled) {
+		spin_lock_irqsave(&chardev_wdt->lock, flags);
+		chardev_wdt->enabled = 1;
+		chardev_wdt->countdown = default_countdown;
+		chardev_wdt->wdt_start(chardev_wdt);
+		chardev_wdt->countdown_min = INT_MAX;
+		spin_unlock_irqrestore(&chardev_wdt->lock, flags);
+	}
+	return 0;
+}
+
+static struct file_operations wdt_fops = {
+	.owner		= THIS_MODULE,
+	.open		= wdt_open,
+	.write		= wdt_write,
+	.unlocked_ioctl	= wdt_ioctl,
+	.release	= wdt_release,
+};
+
+static struct miscdevice wdt_miscdev = {
+	.minor		= WATCHDOG_MINOR,
+	.name		= "watchdog",
+	.fops		= &wdt_fops,
+};
+
+/*
+ * add watchdog to the char interface. if we are already bound to a
+ * watchdog, return 0, this is not a major no-no.
+ */
+int
+fbxwatchdog_char_add(struct fbxwatchdog *wdt)
+{
+	int err;
+
+	err = misc_register(&wdt_miscdev);
+	if (err) {
+		printk("unable to register misc device.\n");
+		if (err == -EEXIST)
+			return 0;
+		return err;
+	}
+	chardev_wdt = wdt;
+	return 0;
+}
+
+/*
+ * if the watchdog is bound to the char device interface, unregister
+ * the misc device and tell that we are no more bound to a
+ * watchdog. otherwise, do nothing.
+ */
+void
+fbxwatchdog_char_remove(struct fbxwatchdog *wdt)
+{
+	if (wdt != chardev_wdt)
+		return ;
+	misc_deregister(&wdt_miscdev);
+	chardev_wdt = NULL;
+}
+
+EXPORT_SYMBOL(fbxwatchdog_char_add);
+EXPORT_SYMBOL(fbxwatchdog_char_remove);
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxwatchdog./fbxwatchdog_core.c linux-2.6.39.4-fbx/drivers/fbxwatchdog/fbxwatchdog_core.c
--- linux-2.6.39.4-fbx/drivers/fbxwatchdog./fbxwatchdog_core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxwatchdog/fbxwatchdog_core.c	2011-05-24 18:15:54.725723925 +0200
@@ -0,0 +1,301 @@
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/reboot.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+
+#include "fbxwatchdog.h"
+
+#define SOFTTIMER_FREQ	(HZ / 10)
+
+#define PFX "fbxwatchdog: "
+
+static struct class *fbxwatchdog_class;
+
+static ssize_t
+show_enabled(struct device *dev,
+	     struct device_attribute *attr, char *buf)
+{
+	struct fbxwatchdog *wdt;
+
+	wdt = dev_get_drvdata(dev);
+	if (!wdt) {
+		printk(KERN_DEBUG "ignoring request to dead watchdog.\n");
+		return -ENODEV;
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%i\n", wdt->enabled);
+}
+
+/*
+ * start/stop watchdog depending on the value of the first character
+ * of buf. set countdown_min to a sane value.
+ */
+static ssize_t
+store_enabled(struct device *dev,
+	      struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct fbxwatchdog *wdt;
+	unsigned long flags;
+
+	wdt = dev_get_drvdata(dev);
+	if (!wdt) {
+		printk(KERN_DEBUG "ignoring request to dead watchdog.\n");
+		return -ENODEV;
+	}
+
+	if (size == 0)
+		return 0;
+
+
+	spin_lock_irqsave(&wdt->lock, flags);
+	switch (*buf) {
+	case '0':
+		if (wdt->enabled) {
+			wdt->enabled = 0;
+			wdt->wdt_stop(wdt);
+		}
+		break;
+
+	case '1':
+		if (!wdt->enabled) {
+			wdt->enabled = 1;
+			wdt->wdt_start(wdt);
+			wdt->countdown_min = INT_MAX;
+		}
+		break;
+
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&wdt->lock, flags);
+
+	return size;
+}
+
+static ssize_t
+show_countdown(struct device *dev,
+	       struct device_attribute *attr, char *buf)
+{
+	struct fbxwatchdog *wdt;
+
+	wdt = dev_get_drvdata(dev);
+	if (!wdt) {
+		printk(KERN_DEBUG "ignoring request to dead watchdog.\n");
+		return -ENODEV;
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%i\n", wdt->countdown);
+}
+
+/*
+ * update watchdog countdown with the userland value given in buf.
+ */
+static ssize_t
+store_countdown(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct fbxwatchdog *wdt;
+	int countdown;
+	char *ptr;
+
+	wdt = dev_get_drvdata(dev);
+	if (!wdt) {
+		printk(KERN_DEBUG "ignoring request to dead watchdog.\n");
+		return -ENODEV;
+	}
+
+	if (size == 0)
+		return 0;
+
+	ptr = kzalloc(size + 1, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+	strlcpy(ptr, buf, size + 1);
+
+	countdown = simple_strtoul(ptr, NULL, 10);
+	wdt->countdown = countdown;
+	kfree(ptr);
+
+	return size;
+}
+
+static ssize_t
+show_countdown_min(struct device *dev,
+		   struct device_attribute *attr, char *buf)
+{
+	struct fbxwatchdog *wdt;
+
+	wdt = dev_get_drvdata(dev);
+	if (!wdt) {
+		printk(KERN_DEBUG "ignoring request to dead watchdog.\n");
+		return -ENODEV;
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%i\n", wdt->countdown_min);
+}
+
+static struct device_attribute wdt_attributes[] = {
+	__ATTR(enabled, 0600, show_enabled, store_enabled),
+	__ATTR(countdown, 0600, show_countdown, store_countdown),
+	__ATTR(countdown_min, 0400, show_countdown_min, NULL),
+};
+
+/*
+ * software timer callback: decrement countdown and update
+ * countdown_min if needed. this is called 10 times per second.
+ */
+static void fbxwatchdog_timer_cb(unsigned long data)
+{
+	struct fbxwatchdog *wdt;
+
+	wdt = (struct fbxwatchdog *)data;
+
+	if (wdt->enabled) {
+		wdt->countdown -= jiffies_to_msecs(SOFTTIMER_FREQ);
+		if (wdt->countdown < wdt->countdown_min)
+			wdt->countdown_min = wdt->countdown;
+	}
+
+	wdt->timer.expires = jiffies + SOFTTIMER_FREQ;
+	add_timer(&wdt->timer);
+}
+
+/*
+ * called from half life interrupt handler, panic if countdown is too
+ * low (ie if userland has not reset countdown to before it reached
+ * 0).
+ */
+static void fbxwatchdog_halflife_cb(struct fbxwatchdog *wdt)
+{
+	if (wdt->countdown <= 0) {
+		wdt->wdt_stop(wdt);
+		panic("software fbxwatchdog triggered");
+	}
+}
+
+/*
+ * register a new watchdog device.
+ */
+int fbxwatchdog_register(struct fbxwatchdog *wdt)
+{
+	struct device *dev;
+	int i = 0, err = 0;
+
+	if (wdt == NULL)
+		return -EFAULT;
+
+	printk(KERN_INFO PFX "registering watchdog %s\n", wdt->name);
+
+	dev = device_create(fbxwatchdog_class, NULL, 0, wdt, "%s", wdt->name);
+	if (IS_ERR(dev)) {
+		printk(KERN_ERR PFX "unable to allocate device.\n");
+		err = PTR_ERR(dev);
+		goto out_error;
+	}
+	wdt->dev = dev;
+
+	for (i = 0; i < ARRAY_SIZE(wdt_attributes); i++) {
+		err = device_create_file(dev, &wdt_attributes[i]);
+		if (err)
+			goto out_error;
+	}
+
+	/* start countdown soft timer */
+	init_timer(&wdt->timer);
+	wdt->timer.function = fbxwatchdog_timer_cb;
+	wdt->timer.data = (unsigned long)wdt;
+	wdt->timer.expires = jiffies + SOFTTIMER_FREQ;
+	add_timer(&wdt->timer);
+
+	spin_lock_init(&wdt->lock);
+
+	wdt->cb = fbxwatchdog_halflife_cb;
+	err = wdt->wdt_init(wdt);
+	if (err) {
+		printk(KERN_ERR PFX "unable to do low level init of "
+		       "watchdog %s.\n", wdt->name);
+		goto out_del_timer;
+	}
+
+#ifdef CONFIG_FREEBOX_WATCHDOG_CHAR
+	err = fbxwatchdog_char_add(wdt);
+	if (err) {
+		printk(KERN_ERR PFX "unable to add %s to the fbxwatchdog char "
+		       "device interface.\n", wdt->name);
+		goto out_wdt_cleanup;
+	}
+#endif
+
+	return 0;
+
+#ifdef CONFIG_FREEBOX_WATCHDOG_CHAR
+out_wdt_cleanup:
+	wdt->wdt_cleanup(wdt);
+#endif
+
+out_del_timer:
+	del_timer_sync(&wdt->timer);
+out_error:
+	if (wdt->dev) {
+		for (; i >= 0; i--)
+			device_remove_file(dev, &wdt_attributes[i]);
+		device_unregister(dev);
+	}
+	return err;
+}
+
+int fbxwatchdog_unregister(struct fbxwatchdog *wdt)
+{
+	int i;
+
+	printk(KERN_INFO PFX "registering watchdog %s\n", wdt->name);
+
+	if (wdt->enabled) {
+		unsigned long flags;
+
+		printk(KERN_WARNING "removing enabled watchdog.\n");
+		spin_lock_irqsave(&wdt->lock, flags);
+		wdt->wdt_stop(wdt);
+		spin_unlock_irqrestore(&wdt->lock, flags);
+	}
+
+#ifdef CONFIG_FREEBOX_WATCHDOG_CHAR
+	fbxwatchdog_char_remove(wdt);
+#endif
+	wdt->wdt_cleanup(wdt);
+	del_timer_sync(&wdt->timer);
+	for (i = 0; i < ARRAY_SIZE(wdt_attributes); i++)
+		device_remove_file(wdt->dev, &wdt_attributes[i]);
+	device_unregister(wdt->dev);
+	wdt->dev = NULL;
+	return 0;
+}
+
+static int __init fbxwatchdog_init(void)
+{
+	printk(KERN_INFO PFX "2007, Freebox SA.\n");
+	fbxwatchdog_class = class_create(THIS_MODULE, "fbxwatchdog");
+	if (IS_ERR(fbxwatchdog_class))
+		return PTR_ERR(fbxwatchdog_class);
+	return 0;
+}
+
+static void __exit fbxwatchdog_exit(void)
+{
+	class_destroy(fbxwatchdog_class);
+}
+
+
+EXPORT_SYMBOL_GPL(fbxwatchdog_register);
+EXPORT_SYMBOL_GPL(fbxwatchdog_unregister);
+
+module_init(fbxwatchdog_init);
+module_exit(fbxwatchdog_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Nicolas Schichan <nschichan@freebox.fr>");
+MODULE_DESCRIPTION("Freebox Watchdog Core - www.freebox.fr");
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxwatchdog./fbxwatchdog.h linux-2.6.39.4-fbx/drivers/fbxwatchdog/fbxwatchdog.h
--- linux-2.6.39.4-fbx/drivers/fbxwatchdog./fbxwatchdog.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxwatchdog/fbxwatchdog.h	2011-05-24 18:15:33.725810957 +0200
@@ -0,0 +1,47 @@
+#ifndef FBXWATCHDOG_H
+# define FBXWATCHDOG_H
+
+struct fbxwatchdog {
+	const char *name;
+	void *priv;
+
+	int enabled;
+	int countdown;
+	int countdown_min;
+
+	int (*wdt_init)(struct fbxwatchdog *wdt);
+	int (*wdt_cleanup)(struct fbxwatchdog *wdt);
+
+	/*
+	 * wdt_start and wdt_stop are called with wdt->lock held and irq
+	 * disabled.
+	 */
+	int (*wdt_start)(struct fbxwatchdog *wdt);
+	int (*wdt_stop)(struct fbxwatchdog *wdt);
+
+	/*
+	 * cb is called from interrupt/softirq context (depends on the
+	 * underlying driver/hardware).
+	 */
+	void (*cb)(struct fbxwatchdog *wdt);
+
+	struct timer_list timer;
+
+	struct device *dev;
+
+	/*
+	 * protect interrupt handlers & start/stop methods running in
+	 * thead context.
+	 */
+	spinlock_t	lock;
+};
+
+int fbxwatchdog_register(struct fbxwatchdog *wdt);
+int fbxwatchdog_unregister(struct fbxwatchdog *wdt);
+
+#ifdef CONFIG_FREEBOX_WATCHDOG_CHAR
+int fbxwatchdog_char_add(struct fbxwatchdog *wdt);
+void fbxwatchdog_char_remove(struct fbxwatchdog *wdt);
+#endif
+
+#endif /* !FBXWATCHDOG_H */
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxwatchdog./fbxwatchdog_orion.c linux-2.6.39.4-fbx/drivers/fbxwatchdog/fbxwatchdog_orion.c
--- linux-2.6.39.4-fbx/drivers/fbxwatchdog./fbxwatchdog_orion.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxwatchdog/fbxwatchdog_orion.c	2011-05-24 18:15:54.725723925 +0200
@@ -0,0 +1,242 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <mach/bridge-regs.h>
+#include <plat/orion_wdt.h>
+
+#include "fbxwatchdog.h"
+
+#define PFX "fbxwatchdog_orion: "
+
+struct fbxwatchdog_orion_priv {
+	unsigned int		tclk;
+	void __iomem		*base;
+	struct timer_list	half_life_timer;
+};
+
+/*
+ * Watchdog timer block registers.
+ */
+#define TIMER_CTRL		(TIMER_VIRT_BASE + 0x0000)
+#define  WDT_EN			0x0010
+#define WDT_VAL			(TIMER_VIRT_BASE + 0x0024)
+
+#define WDT_MAX_CYCLE_COUNT	0xffffffff
+#define WDT_IN_USE		0
+#define WDT_OK_TO_CLOSE		1
+
+/*
+ * orion does not trigger interrupts each times the watchdog reaches
+ * the half of it's count down. we emulate this behaviour using a
+ * linux timer that fires every 500 msec.
+ */
+static void
+half_life_timer_cb(unsigned long data)
+{
+	struct fbxwatchdog *wdt;
+	struct fbxwatchdog_orion_priv *priv;
+	unsigned long flags;
+
+	wdt = (struct fbxwatchdog *)data;
+	priv = wdt->priv;
+
+	spin_lock_irqsave(&wdt->lock, flags);
+
+	/* reload counter */
+	writel(priv->tclk, WDT_VAL);
+
+	if (wdt->cb)
+		wdt->cb(wdt);
+
+	priv->half_life_timer.expires = jiffies + HZ / 2;
+	add_timer(&priv->half_life_timer);
+
+	spin_unlock_irqrestore(&wdt->lock, flags);
+}
+
+/*
+ * setup half life timer.
+ */
+static int orion_wdt_init(struct fbxwatchdog *wdt)
+{
+	struct fbxwatchdog_orion_priv *priv;
+
+	priv = wdt->priv;
+	init_timer(&priv->half_life_timer);
+	priv->half_life_timer.function = half_life_timer_cb;
+	priv->half_life_timer.data = (unsigned long)wdt;
+	return 0;
+}
+
+static int orion_wdt_cleanup(struct fbxwatchdog *wdt)
+{
+	return 0;
+}
+
+static int orion_wdt_start(struct fbxwatchdog *wdt)
+{
+	struct fbxwatchdog_orion_priv *priv;
+	uint32_t val;
+
+	printk(KERN_INFO PFX "starting watchdog ...\n");
+
+	priv = wdt->priv;
+	val = readl(TIMER_CTRL);
+	if (val & WDT_EN) {
+		printk(KERN_WARNING PFX "watchdog has been enabled by "
+		       "bootloader.!\n");
+		/* disable it */
+		val &= ~WDT_EN;
+		writel(val, TIMER_CTRL);
+	}
+
+	/* watchdog will blow up after 1 second if not refreshed */
+	writel(priv->tclk, WDT_VAL);
+
+	/* enable it */
+	val = readl(TIMER_CTRL);
+	val |= WDT_EN;
+	writel(val, TIMER_CTRL);
+
+	/* enable reset on watchdog */
+	val = readl(RSTOUTn_MASK);
+	val |= WDT_RESET_OUT_EN;
+	writel(val, RSTOUTn_MASK);
+
+	/* will fire every 500 ms */
+	priv->half_life_timer.expires = jiffies + HZ / 2;
+	add_timer(&priv->half_life_timer);
+
+	return 0;
+}
+
+int orion_wdt_stop(struct fbxwatchdog *wdt)
+{
+	struct fbxwatchdog_orion_priv *priv;
+	uint32_t val;
+
+	printk(KERN_INFO PFX "stopping watchdog ...\n");
+
+	priv = wdt->priv;
+	del_timer_sync(&priv->half_life_timer);
+
+	/* disable it */
+	val = readl(TIMER_CTRL);
+	val &= ~WDT_EN;
+	writel(val, TIMER_CTRL);
+
+	/* enable reset on watchdog */
+	val = readl(RSTOUTn_MASK);
+	val |= WDT_RESET_OUT_EN;
+	writel(val, RSTOUTn_MASK);
+
+	return 0;
+}
+
+static int fbxwatchdog_platform_probe(struct platform_device *pdev)
+{
+	struct orion_wdt_platform_data *pdata = pdev->dev.platform_data;
+	struct fbxwatchdog_orion_priv *priv = NULL;
+	struct fbxwatchdog *wdt;
+	int err = 0;
+
+	if (!pdata) {
+		printk(KERN_ERR "Orion Watchdog misses platform data\n");
+		return -ENODEV;
+	}
+
+	wdt = kzalloc(sizeof (*wdt), GFP_KERNEL);
+	if (!wdt) {
+		printk(KERN_ERR PFX "unable allocate memory for watchdog.\n");
+		err = -ENOMEM;
+		goto out_error;
+	}
+
+	priv = kzalloc(sizeof (*priv), GFP_KERNEL);
+	if (!priv) {
+		printk(KERN_ERR PFX "unable to allocate memory for private "
+		       "structure.\n");
+		err = -ENOMEM;
+		goto out_error;
+	}
+
+	wdt->priv = priv;
+	wdt->name = pdev->name;
+
+	wdt->wdt_init = orion_wdt_init;
+	wdt->wdt_cleanup = orion_wdt_cleanup;
+	wdt->wdt_start = orion_wdt_start;
+	wdt->wdt_stop = orion_wdt_stop;
+
+	priv->tclk = pdata->tclk;
+
+	err = fbxwatchdog_register(wdt);
+	if (err) {
+		printk(KERN_ERR PFX "unable to register watchdog %s\n",
+		       wdt->name);
+		goto out_error;
+	}
+
+	platform_set_drvdata(pdev, wdt);
+
+	return 0;
+
+ out_error:
+	if (wdt)
+		kfree(wdt);
+	if (priv)
+		kfree(priv);
+	return err;
+}
+
+/*
+ * unregister and free memory allocated by the probe function.
+ */
+static int
+fbxwatchdog_platform_remove(struct platform_device *pdev)
+{
+	struct fbxwatchdog *wdt;
+
+	wdt = platform_get_drvdata(pdev);
+	if (!wdt) {
+		BUG();
+		return -ENODEV;
+	}
+
+	fbxwatchdog_unregister(wdt);
+	kfree(wdt->priv);
+	kfree(wdt);
+
+	return 0;
+}
+
+struct platform_driver fbxwatchdog_platform_driver = {
+	.probe	= fbxwatchdog_platform_probe,
+	.remove	= fbxwatchdog_platform_remove,
+	.driver	= {
+		.name	= "orion_fbxwdt",
+	}
+};
+
+static int __init fbxwatchdog_orion_init(void)
+{
+	platform_driver_register(&fbxwatchdog_platform_driver);
+	return 0;
+}
+
+static void __exit fbxwatchdog_orion_exit(void)
+{
+	platform_driver_unregister(&fbxwatchdog_platform_driver);
+}
+
+module_init(fbxwatchdog_orion_init);
+module_exit(fbxwatchdog_orion_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Nicolas Schichan <nschichan@freebox.fr>");
+MODULE_DESCRIPTION("Freebox Watchdog, orion specific bits");
+
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxwatchdog./Kconfig linux-2.6.39.4-fbx/drivers/fbxwatchdog/Kconfig
--- linux-2.6.39.4-fbx/drivers/fbxwatchdog./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxwatchdog/Kconfig	2011-06-15 18:56:42.015452142 +0200
@@ -0,0 +1,20 @@
+menuconfig FREEBOX_WATCHDOG
+	tristate "Freebox Watchdog"
+	default n
+
+if FREEBOX_WATCHDOG
+
+config FREEBOX_WATCHDOG_CHAR
+	bool "Freebox Watchdog char device interface."
+	default n
+
+config FREEBOX_WATCHDOG_ORION
+	tristate "Marvell Orion support"
+	depends on PLAT_ORION
+
+config FREEBOX_WATCHDOG_BCM63XX
+	tristate "Broadcom 63xx Freebox Watchdog support"
+	depends on BCM63XX
+	default n
+
+endif
diff -Nruw linux-2.6.39.4-fbx/drivers/fbxwatchdog./Makefile linux-2.6.39.4-fbx/drivers/fbxwatchdog/Makefile
--- linux-2.6.39.4-fbx/drivers/fbxwatchdog./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/fbxwatchdog/Makefile	2011-06-15 18:56:42.015452142 +0200
@@ -0,0 +1,9 @@
+obj-$(CONFIG_FREEBOX_WATCHDOG) += fbxwatchdog.o
+
+fbxwatchdog-objs = fbxwatchdog_core.o
+ifeq ($(CONFIG_FREEBOX_WATCHDOG_CHAR),y)
+fbxwatchdog-objs += fbxwatchdog_char.o
+endif
+
+obj-$(CONFIG_FREEBOX_WATCHDOG_ORION)	+= fbxwatchdog_orion.o
+obj-$(CONFIG_FREEBOX_WATCHDOG_BCM63XX)	+= fbxwatchdog_bcm63xx.o
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/drivers/input/misc/smsc_cap1066.c	2011-09-06 15:55:33.956661793 +0200
@@ -0,0 +1,1031 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/input-polldev.h>
+#include <linux/smsc_cap1066.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+
+#define PFX		"cap1066: "
+
+/*
+ * list of registers
+ */
+#define SMSC_REG_MAIN_CTRL		0x00
+#define SMSC_REG_BTN_STATUS1		0x03
+#define SMSC_REG_DATA_SENSITIVITY	0x1f
+#define SMSC_REG_CFG			0x20
+#define SMSC_REG_SENS_CFG		0x22
+#define SMSC_REG_MTOUCH_CFG_REG		0x2a
+#define SMSC_REG_LED_OUT_TYPE		0x71
+#define SMSC_REG_LED_LINK		0x72
+#define SMSC_REG_LED_OUTPUT_CTL		0x74
+#define SMSC_REG_LED_BEHAVIOUR1		0x81
+#define SMSC_REG_LED_BEHAVIOUR2		0x82
+#define SMSC_REG_LED_DIRECT_DCYCLE	0x93
+#define SMSC_REG_LED_DIRECT_RAMP_RATE	0x94
+#define SMSC_REG_LED_OFF_DELAY		0x95
+#define SMSC_REG_DID			0xfd
+#define SMSC_REG_VID			0xfe
+
+/*
+ * used in cap1066_init_hw and during priv initialization.
+ */
+#define DEFAULT_DUTY_CYCLE_MIN		0x4
+#define DEFAULT_DUTY_CYCLE_MAX		0xf
+#define DEFAULT_RAMP_TIME_FALL		0x1
+#define DEFAULT_RAMP_TIME_RISE		0x2
+
+/*
+ * vendor id / device id
+ */
+#define SMSC_CAP1066_VID	0x5d
+#define SMSC_CAP1066_DID	0x41
+
+static const unsigned short normal_i2c[] = { 0x28, I2C_CLIENT_END };
+
+static const struct i2c_device_id cap1066_id[] = {
+	{ "cap1066", 0 },
+	{ }
+};
+
+/*
+ * private context
+ */
+static unsigned short default_map[CAP1066_MAX_BTNS] = {
+	BTN_0,
+	BTN_1,
+	BTN_2,
+	BTN_3,
+	BTN_4,
+	BTN_5,
+};
+
+struct led_btn_name
+{
+	int code;
+	const char *name;
+};
+
+/*
+ * whenever possible symlinks will be created from led_btn_X to
+ * led_key_y, depending on user provided keymap. add entries here as
+ * you see fit.
+ */
+static const struct led_btn_name led_btn_names[] = {
+	{ KEY_UP, "led_key_up", },
+	{ KEY_DOWN, "led_key_down", },
+	{ KEY_LEFT, "led_key_left", },
+	{ KEY_RIGHT, "led_key_right", },
+	{ KEY_ENTER, "led_key_enter", },
+};
+
+enum {
+	E_SMSC_CAP1066_LED_MODE_AUTO,
+	E_SMSC_CAP1066_LED_MODE_ON,
+	E_SMSC_CAP1066_LED_MODE_OFF,
+};
+
+struct cap1066_led_dev
+{
+	struct cap1066_priv	*parent_priv;
+	struct device		dev;
+	int			led_mode;
+	int			led_index;
+	const char		*btn_link;
+};
+
+struct cap1066_priv {
+	struct input_polled_dev *poll_dev;
+	struct i2c_client	*client;
+	unsigned short		keymap[CAP1066_MAX_BTNS];
+	struct cap1066_led_dev	*led_devices[CAP1066_MAX_BTNS];
+
+	u8			duty_cycle_min;
+	u8			duty_cycle_max;
+	u8			raw_ramp_time_fall;
+	u8			raw_ramp_time_rise;
+
+	bool			has_irq_gpio;
+	unsigned int		irq_gpio;
+};
+
+static const char *get_keycode_btn_name(int key_code)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(led_btn_names); ++i) {
+		if (key_code == led_btn_names[i].code)
+			return led_btn_names[i].name;
+	}
+	return NULL;
+}
+
+/*
+ * single register read
+ */
+static int cap1066_read_reg(struct i2c_client *client, u8 reg, u8 *val)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret < 0) {
+		printk(KERN_ERR PFX "read failed: %d\n", ret);
+		return ret;
+	}
+
+	*val = (u8)ret;
+	return 0;
+}
+
+/*
+ * single register write
+ */
+static int cap1066_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, reg, val);
+	if (ret < 0) {
+		printk(KERN_ERR PFX "write failed: %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+/*
+ * called when an smbus device is detected, make sure it's a cap1066
+ */
+static int cap1066_detect(struct i2c_client *client,
+			  struct i2c_board_info *info)
+
+{
+	int ret;
+	u8 vid, did;
+
+	ret = cap1066_read_reg(client, SMSC_REG_VID, &vid);
+	if (ret)
+		return ret;
+
+	ret = cap1066_read_reg(client, SMSC_REG_DID, &did);
+	if (ret)
+		return ret;
+
+	if (vid != SMSC_CAP1066_VID || did != SMSC_CAP1066_DID) {
+		printk(KERN_ERR PFX "bad vid/did: 0x%04x/0x%04x\n", vid, did);
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO PFX "detected SMSC cap1066 chip\n");
+	strlcpy(info->type, "cap1066", I2C_NAME_SIZE);
+	return 0;
+}
+
+/*
+ * reset registers value
+ */
+static int cap1066_init_hw(struct i2c_client *client)
+{
+	unsigned int i;
+
+	static const u8 init_regs[] = {
+		/* power on */
+		SMSC_REG_MAIN_CTRL, 0x0,
+
+		/* default sensitivity */
+		SMSC_REG_DATA_SENSITIVITY, 0x2f,
+
+		/* max duration */
+		SMSC_REG_SENS_CFG, 0xf4,
+
+		/* default configuration */
+		SMSC_REG_CFG, 0x28,
+
+
+		/* open drain output on all gpios */
+		SMSC_REG_LED_OUT_TYPE, 0x00,
+
+		/* link leds with sensors */
+		SMSC_REG_LED_LINK, 0x3f,
+
+		/* setup direct mode */
+		SMSC_REG_LED_BEHAVIOUR1, 0x00,
+		SMSC_REG_LED_BEHAVIOUR2, 0x00,
+
+		/* set led duty cycle min/max to 10% => 100% */
+		SMSC_REG_LED_DIRECT_DCYCLE,
+			(DEFAULT_DUTY_CYCLE_MAX << 4) |
+			(DEFAULT_DUTY_CYCLE_MIN),
+
+		/* set ramp rate time to 500ms/250ms */
+		SMSC_REG_LED_DIRECT_RAMP_RATE,
+			(DEFAULT_RAMP_TIME_RISE << 3) |
+			(DEFAULT_RAMP_TIME_FALL),
+	};
+
+	for (i = 0; i < ARRAY_SIZE(init_regs); i += 2) {
+		int ret;
+
+		ret = cap1066_write_reg(client,
+					init_regs[i], init_regs[i + 1]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/*
+ * input core poll callback
+ */
+static void cap1066_input_poll(struct input_polled_dev *dev)
+{
+	struct cap1066_priv *priv = dev->private;
+	struct input_dev *input = dev->input;
+	unsigned int i;
+	int ret;
+	u8 stat;
+
+	if (priv->has_irq_gpio) {
+		if (gpio_get_value(priv->irq_gpio))
+			return;
+	}
+
+	/* clear interrupt flag */
+	cap1066_write_reg(priv->client, SMSC_REG_MAIN_CTRL, 0);
+
+	ret = cap1066_read_reg(priv->client, SMSC_REG_BTN_STATUS1, &stat);
+	if (ret) {
+		printk(KERN_ERR PFX "unable to read status\n");
+		return;
+	}
+
+	for (i = 0; i < CAP1066_MAX_BTNS; i++)
+		input_report_key(input, priv->keymap[i],
+				 (stat & (1 << i)) ? 1 : 0);
+	input_sync(input);
+}
+
+#define to_cap1066_led_dev(Dev)	container_of(Dev, struct cap1066_led_dev, dev)
+
+/*
+ * called when all sysfs references to the cap1066_led_dev are gone.
+ */
+static void cap1066_led_dev_release(struct device *dev)
+{
+	struct cap1066_led_dev *led_dev;
+
+	led_dev = to_cap1066_led_dev(dev);
+	kfree(led_dev);
+}
+
+static int is_white(int c)
+{
+	return c == '\0' || c == ' ' || c == '\t' || c == '\n' || c == '\r';
+}
+
+/*
+ * store a new control value for a given cap1066_led_dev:
+ * - auto means that the led is linked to the capacitive keys
+ * - on means that the led is always on
+ * - off means that the led is always off
+ */
+static ssize_t store_control(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct cap1066_led_dev *led_dev;
+	int new_mode;
+	int read_len = 0;
+	const char *end;
+	int key;
+	u8 reg;
+	struct i2c_client *client;
+	static const char *valid_keys[] = {
+		[E_SMSC_CAP1066_LED_MODE_AUTO] = "auto",
+		[E_SMSC_CAP1066_LED_MODE_ON] = "on",
+		[E_SMSC_CAP1066_LED_MODE_OFF] = "off",
+	};
+
+
+	led_dev = to_cap1066_led_dev(dev);
+	client = led_dev->parent_priv->client;
+
+	if (is_white(*buf))
+		/*
+		 * eat white spaces silently, upper layer will call us
+		 * again.
+		 */
+		return 1;
+
+	for (key = 0; key < ARRAY_SIZE(valid_keys); ++key) {
+		if (count < strlen(valid_keys[key]))
+			continue ;
+		if (!strncmp(buf, valid_keys[key], strlen(valid_keys[key]))) {
+			break;
+		}
+	}
+
+	if (key == ARRAY_SIZE(valid_keys)) {
+		/*
+		 * end of valid_keys array reached and nothing valid
+		 * was recognized.
+		 */
+		printk(KERN_ERR PFX "invalid control value.\n");
+		return -EINVAL;
+	}
+	new_mode = key;
+	read_len = strlen(valid_keys[key]);
+
+	/*
+	 * check that no garbage is present at end of input.
+	 */
+	end = buf + read_len;
+	if (end < buf + count && !is_white(*end)) {
+		/*
+		 * garbage at end of input.
+		 */
+		printk(KERN_ERR PFX "garbage at end of value for led "
+		       "control.\n");
+		return -EINVAL;
+	}
+
+	if (new_mode == led_dev->led_mode)
+		return read_len;
+
+	if (new_mode == E_SMSC_CAP1066_LED_MODE_AUTO) {
+		cap1066_read_reg(client, SMSC_REG_LED_LINK, &reg);
+		reg |= (1 << led_dev->led_index);
+		cap1066_write_reg(client, SMSC_REG_LED_LINK, reg);
+	} else {
+		cap1066_read_reg(client, SMSC_REG_LED_LINK, &reg);
+		reg &= ~(1 << led_dev->led_index);
+		cap1066_write_reg(client, SMSC_REG_LED_LINK, reg);
+
+		cap1066_read_reg(client, SMSC_REG_LED_OUTPUT_CTL, &reg);
+		if (new_mode == E_SMSC_CAP1066_LED_MODE_ON)
+			reg |= (1 << led_dev->led_index);
+		else
+			reg &= ~(1 << led_dev->led_index);
+		cap1066_write_reg(client, SMSC_REG_LED_OUTPUT_CTL, reg);
+	}
+	led_dev->led_mode = new_mode;
+
+	return read_len;
+}
+
+static ssize_t show_control(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	struct cap1066_led_dev *led_dev;
+	const char *str;
+
+	led_dev = to_cap1066_led_dev(dev);
+	switch (led_dev->led_mode) {
+	case E_SMSC_CAP1066_LED_MODE_AUTO:
+		str = "auto";
+		break;
+
+	case E_SMSC_CAP1066_LED_MODE_ON:
+		str = "on";
+		break;
+
+	case E_SMSC_CAP1066_LED_MODE_OFF:
+		str = "off";
+		break;
+
+	default:
+		str = "invalid";
+		break;
+	}
+
+	return sprintf(buf, "%s\n", str);
+}
+
+static DEVICE_ATTR(control, S_IWUSR | S_IRUSR, show_control, store_control);
+
+static struct device_attribute *cap1066_led_dev_attrs[] = {
+	&dev_attr_control,
+};
+
+/*
+ * helper used to create all attributes given in the attr array.
+ *
+ * if something goes wrong during creation, remove attributes that
+ * have already been created.
+ */
+static int create_sysfs_files(struct device *dev,
+			      struct device_attribute **attrs,
+			      size_t count)
+{
+	int created;
+	int error = 0;
+
+	for (created = 0; created < count; ++created) {
+		error = device_create_file(dev, attrs[created]);
+		if (error)
+			break;
+	}
+
+	if (!error)
+		/*
+		 * no errors, can return.
+		 */
+		return 0;
+
+	/*
+	 * errors during creation, remove already created
+	 * files.
+	 */
+	while (--created >= 0)
+		device_remove_file(dev, attrs[created]);
+
+	return error;
+}
+
+/*
+ * create a led device. This will create a new directory in the sysfs
+ * base of the parent. a symlink will be created if a button name is
+ * found via get_keycode_btn_name().
+ */
+static struct cap1066_led_dev *cap1066_create_led_dev(struct device *parent,
+						      struct cap1066_priv *priv,
+						      int index, int key_code)
+{
+	struct cap1066_led_dev *dev;
+	int error = 0;
+
+	dev = kzalloc(sizeof (*dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->led_index = index;
+	dev->parent_priv = priv;
+	dev_set_name(&dev->dev, "led_btn_%i", index);
+	dev->dev.release = cap1066_led_dev_release;
+	dev->dev.parent = parent;
+	if (device_register(&dev->dev) < 0) {
+		kfree(dev);
+		return NULL;
+	}
+
+	/*
+	 * create sysfs attributes.
+	 */
+	error = create_sysfs_files(&dev->dev, cap1066_led_dev_attrs,
+				   ARRAY_SIZE(cap1066_led_dev_attrs));
+	if (error) {
+		device_unregister(&dev->dev);
+		return NULL;
+	}
+
+	/*
+	 * create sysfs symlinks to friendly names, wherever possible.
+	 */
+	dev->btn_link = get_keycode_btn_name(key_code);
+	if (dev->btn_link) {
+		error = sysfs_create_link(&parent->kobj, &dev->dev.kobj,
+					  dev->btn_link);
+		if (error)
+			dev->btn_link = NULL;
+	}
+	return dev;
+}
+
+static void cap1066_remove_led_dev(struct cap1066_led_dev *dev)
+{
+	int i;
+
+	if (dev->btn_link)
+		sysfs_remove_link(&dev->dev.parent->kobj, dev->btn_link);
+
+	for (i = 0; i < ARRAY_SIZE(cap1066_led_dev_attrs); ++i)
+		device_remove_file(&dev->dev, cap1066_led_dev_attrs[i]);
+	device_unregister(&dev->dev);
+
+	/*
+	 * dev->release() kfree the cap1066_led_dev struct
+	 */
+}
+
+/*
+ * helper to exctract an unsigned long from the buffer given in
+ * parameter.
+ *
+ * first store buf in a zero terminated string and strtoul() it.
+ */
+static int get_ulong(const char *buf, size_t count, unsigned long *ret)
+{
+	char local_buf[32];
+	unsigned long val;
+	const char *end;
+
+	strncpy(local_buf, buf, min(count , sizeof (local_buf)));
+	local_buf[min(count, sizeof (local_buf) - 1)] = 0;
+
+	val = simple_strtoul(local_buf, (char**)&end, 0);
+	if (!is_white(*end))
+		/*
+		 * garbage after end of input.
+		 */
+		return -EINVAL;
+
+	*ret = val;
+
+	return 0;
+}
+
+/*
+ * duty cycle sysfs callbacks: things may not work as expected if
+ * duty_cycle_min is >= duty_cycle_max.
+ *
+ * values that can be written in duty_cycle_max/duty_cycle_min
+ * attributes can be on the range [0, 16 [.
+ *
+ * 0 means the lowest possible pwm duty cycle.
+ * 1 means the highest possible pwm duty cycle.
+ */
+
+static ssize_t store_duty_cycle_min(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	unsigned long val;
+	struct i2c_client *client;
+	struct cap1066_priv *priv;
+	int error;
+	u8 reg;
+
+	client = to_i2c_client(dev);
+	priv = i2c_get_clientdata(client);
+
+	if (is_white(*buf))
+		return 1;
+
+	error = get_ulong(buf, count, &val);
+	if (error)
+		return error;
+
+	if (val > 0xf)
+		return -ERANGE;
+
+	cap1066_read_reg(client, SMSC_REG_LED_DIRECT_DCYCLE, &reg);
+	reg &= ~0xf;
+	reg |= val;
+	cap1066_write_reg(client, SMSC_REG_LED_DIRECT_DCYCLE, reg);
+
+	priv->duty_cycle_min = val;
+
+	pr_debug(PFX "store_duty_cycle_min: reg = 0x%02x\n", reg);
+	return count;
+}
+
+static ssize_t show_duty_cycle_min(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct i2c_client *client;
+	struct cap1066_priv *priv;
+
+	client = to_i2c_client(dev);
+	priv = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%u\n", priv->duty_cycle_min);
+}
+
+static ssize_t store_duty_cycle_max(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	unsigned long val;
+	struct i2c_client *client;
+	struct cap1066_priv *priv;
+	int error;
+	u8 reg;
+
+	client = to_i2c_client(dev);
+	priv = i2c_get_clientdata(client);
+
+	if (is_white(*buf))
+		return 1;
+
+	error = get_ulong(buf, count, &val);
+	if (error)
+		return error;
+
+	if (val > 0xf)
+		return -ERANGE;
+
+	cap1066_read_reg(client, SMSC_REG_LED_DIRECT_DCYCLE, &reg);
+	reg &= ~0xf0;
+	reg |= val << 4;
+	cap1066_write_reg(client, SMSC_REG_LED_DIRECT_DCYCLE, reg);
+
+	priv->duty_cycle_max = val;
+
+	pr_debug(PFX "store_duty_cycle_max: reg = 0x%02x\n", reg);
+	return count;
+}
+
+static ssize_t show_duty_cycle_max(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct i2c_client *client;
+	struct cap1066_priv *priv;
+
+	client = to_i2c_client(dev);
+	priv = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%u\n", priv->duty_cycle_max);
+}
+
+/*
+ * convert millisecond value to a "raw" value ready to be written to
+ * the register.
+ */
+static u8 msec_to_raw_ramp_time(unsigned long msec)
+{
+	u8 ret;
+
+	if (msec <= 1500)
+		/*
+		 * register handles 250 msec increments if below 1500
+		 * msec.
+		 */
+		ret = msec / 250;
+	else
+		/*
+		 * there is no 1750 msec step, and 2000 msec is
+		 * encoded as 0x7.
+		 */
+		ret = 0x7;
+
+	return ret;
+}
+
+/*
+ * convert raw register value to a millisecond value.
+ */
+static unsigned long raw_ramp_time_to_msec(u8 raw)
+{
+	unsigned long ret;
+
+	if (raw < 7)
+		ret = 250 * raw;
+	else
+		ret = 2000;
+
+	return ret;
+}
+
+/*
+ * ramp time sysfs callbacks. delays are not reliable if programmed
+ * want time is higher than 1000 msec.
+ *
+ * values that can be written are on the range [0, 2000] and are given
+ * in milliseconds. Values higher than 2000 are clamped to 2000. shown
+ * values are rounded up to the next value supported by the hardware.
+ */
+
+static ssize_t store_ramp_time_rise(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	unsigned long val;
+	u8 raw_val;
+	struct i2c_client *client;
+	struct cap1066_priv *priv;
+	int error;
+	u8 reg;
+
+	client = to_i2c_client(dev);
+	priv = i2c_get_clientdata(client);
+
+	if (is_white(*buf))
+		return 1;
+
+	error = get_ulong(buf, count, &val);
+	if (error)
+		return error;
+
+	raw_val = msec_to_raw_ramp_time(val);
+
+	cap1066_read_reg(client, SMSC_REG_LED_DIRECT_RAMP_RATE, &reg);
+	reg &= ~(0x7 << 3);
+	reg |= raw_val << 3;
+	cap1066_write_reg(client, SMSC_REG_LED_DIRECT_RAMP_RATE, reg);
+
+	priv->raw_ramp_time_rise = raw_val;
+
+	pr_debug(PFX "store_ramp_time_rise: reg = %02x\n", reg);
+	return count;
+}
+
+static ssize_t show_ramp_time_rise(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct i2c_client *client;
+	struct cap1066_priv *priv;
+	unsigned long msec;
+
+	client = to_i2c_client(dev);
+	priv = i2c_get_clientdata(client);
+
+	msec = raw_ramp_time_to_msec(priv->raw_ramp_time_rise);
+
+	return sprintf(buf, "%lu\n", msec);
+}
+
+static ssize_t store_ramp_time_fall(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	unsigned long val;
+	u8 raw_val;
+	struct i2c_client *client;
+	struct cap1066_priv *priv;
+	int error;
+	u8 reg;
+
+	client = to_i2c_client(dev);
+	priv = i2c_get_clientdata(client);
+
+	if (is_white(*buf))
+		return 1;
+
+	error = get_ulong(buf, count, &val);
+	if (error)
+		return error;
+
+	raw_val = msec_to_raw_ramp_time(val);
+
+	cap1066_read_reg(client, SMSC_REG_LED_DIRECT_RAMP_RATE, &reg);
+	reg &= ~0x7;
+	reg |= raw_val;
+	cap1066_write_reg(client, SMSC_REG_LED_DIRECT_RAMP_RATE, reg);
+
+	priv->raw_ramp_time_fall = raw_val;
+
+	pr_debug(PFX "store_ramp_time_rise: reg = %02x\n", reg);
+	return count;
+}
+
+static ssize_t show_ramp_time_fall(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct i2c_client *client;
+	struct cap1066_priv *priv;
+	unsigned long msec;
+
+	client = to_i2c_client(dev);
+	priv = i2c_get_clientdata(client);
+
+	msec = raw_ramp_time_to_msec(priv->raw_ramp_time_fall);
+
+	return sprintf(buf, "%lu\n", msec);
+}
+
+#define MTOUCH_ENABLE		(1 << 7)
+#define MTOUCH_COUNT_MASK	(3 << 2)
+#define MTOUCH_COUNT_SHIFT	(2)
+
+/*
+ * touch limit handling: the hardware can report at most 1 to 4 key
+ * press event or no limit at all.
+ *
+ * Accepted values in touch_limit attribte:
+ * 0 -> no limit
+ * [1, 4] -> limit to the indicated count
+ * [4, +inf [ -> invalid
+ */
+static ssize_t store_touch_limit(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct i2c_client *client;
+	unsigned long limit;
+	int err;
+	u8 mtouch_reg;
+
+	client = to_i2c_client(dev);
+
+	if (is_white(*buf))
+		return 1;
+
+	err = get_ulong(buf, count, &limit);
+	if (err)
+		return err;
+
+	if (limit > 4)
+		return -EINVAL;
+
+	if (limit == 0) {
+		mtouch_reg = 0;
+	} else {
+		mtouch_reg = MTOUCH_ENABLE |
+			((limit - 1) << MTOUCH_COUNT_SHIFT);
+	}
+	cap1066_write_reg(client, SMSC_REG_MTOUCH_CFG_REG, mtouch_reg);
+
+	return count;
+}
+
+static ssize_t show_touch_limit(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct i2c_client *client;
+	u8 mtouch_reg;
+
+	client = to_i2c_client(dev);
+
+	cap1066_read_reg(client, SMSC_REG_MTOUCH_CFG_REG, &mtouch_reg);
+
+	if (mtouch_reg & MTOUCH_ENABLE) {
+		u8 count = (mtouch_reg & MTOUCH_COUNT_MASK) >>
+			MTOUCH_COUNT_SHIFT;
+		return sprintf(buf, "%d\n", count + 1);
+	} else {
+		return sprintf(buf, "0\n");
+	}
+}
+
+static DEVICE_ATTR(duty_cycle_min, S_IRUSR | S_IWUSR, show_duty_cycle_min,
+		   store_duty_cycle_min);
+
+static DEVICE_ATTR(duty_cycle_max, S_IRUSR | S_IWUSR, show_duty_cycle_max,
+		   store_duty_cycle_max);
+
+static DEVICE_ATTR(ramp_time_rise, S_IRUSR | S_IWUSR, show_ramp_time_rise,
+		   store_ramp_time_rise);
+
+static DEVICE_ATTR(ramp_time_fall, S_IRUSR | S_IWUSR, show_ramp_time_fall,
+		   store_ramp_time_fall);
+
+static DEVICE_ATTR(touch_limit, S_IWUSR | S_IRUSR, show_touch_limit,
+		   store_touch_limit);
+
+static struct device_attribute *cap1066_base_attributes[] = {
+	&dev_attr_duty_cycle_min,
+	&dev_attr_duty_cycle_max,
+	&dev_attr_ramp_time_rise,
+	&dev_attr_ramp_time_fall,
+	&dev_attr_touch_limit,
+};
+
+
+/*
+ * i2c core probe callback, called after sucessful detect
+ */
+static int cap1066_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct input_polled_dev *poll_dev;
+	struct input_dev *input;
+	struct cap1066_priv *priv;
+	int ret, i;
+
+	/* initialize controller */
+	ret = cap1066_init_hw(client);
+	if (ret)
+		return ret;
+
+	/* allocate context */
+	priv = kzalloc(sizeof (*priv), GFP_KERNEL);
+	poll_dev = input_allocate_polled_device();
+	if (!priv || !poll_dev) {
+		ret = -ENOMEM;
+		goto out_fail;
+	}
+
+	/*
+	 * must match what has been setup in cap1066_init_hw().
+	 */
+	priv->duty_cycle_min = DEFAULT_DUTY_CYCLE_MIN;
+	priv->duty_cycle_max = DEFAULT_DUTY_CYCLE_MAX;
+	priv->raw_ramp_time_rise = DEFAULT_RAMP_TIME_RISE;
+	priv->raw_ramp_time_fall = DEFAULT_RAMP_TIME_FALL;
+
+	if (client->dev.platform_data) {
+		struct smsc_cap1066_pdata *pdata;
+
+		pdata = client->dev.platform_data;
+		memcpy(priv->keymap, pdata->key_map, sizeof (pdata->key_map));
+		priv->has_irq_gpio = pdata->has_irq_gpio;
+		priv->irq_gpio = pdata->irq_gpio;
+	} else
+		memcpy(priv->keymap, default_map, sizeof (default_map));
+
+	if (priv->has_irq_gpio)
+		gpio_direction_input(priv->irq_gpio);
+
+	priv->poll_dev = poll_dev;
+	priv->client = client;
+
+	poll_dev->private = priv;
+	poll_dev->poll = cap1066_input_poll;
+	poll_dev->poll_interval = 50 /* ms */;
+
+	input = poll_dev->input;
+	input->name = "smsc_cap1066";
+	input->phys = "smsc_cap1066/input0";
+	input->id.bustype = BUS_I2C;
+	input->dev.parent = &client->dev;
+
+	input->keycode = priv->keymap;
+	input->keycodemax = ARRAY_SIZE(priv->keymap);
+	input->keycodesize = sizeof (unsigned short);
+
+	set_bit(EV_REP, input->evbit);
+	set_bit(EV_KEY, input->evbit);
+	for (i = 0; i < ARRAY_SIZE(priv->keymap); i++)
+		set_bit(priv->keymap[i], input->keybit);
+
+	i2c_set_clientdata(client, priv);
+
+	ret = input_register_polled_device(poll_dev);
+	if (ret)
+		goto out_fail;
+
+	for (i = 0; i < ARRAY_SIZE(priv->keymap); ++i) {
+		if (!priv->keymap[i])
+			continue;
+		priv->led_devices[i] =
+			cap1066_create_led_dev(&client->dev,
+					       priv, i, priv->keymap[i]);
+	}
+
+	if (create_sysfs_files(&client->dev, cap1066_base_attributes,
+			       ARRAY_SIZE(cap1066_base_attributes)) < 0)
+		goto out_free_led_devs;
+
+	return 0;
+
+out_free_led_devs:
+	for (i = 0; i < ARRAY_SIZE(priv->keymap); ++i)
+		if (priv->led_devices[i])
+			cap1066_remove_led_dev(priv->led_devices[i]);
+out_fail:
+	input_free_polled_device(poll_dev);
+	kfree(priv);
+	i2c_set_clientdata(client, NULL);
+	return ret;
+}
+
+/*
+ * i2c core remove callback
+ */
+static int cap1066_remove(struct i2c_client *client)
+{
+	int i;
+	struct cap1066_priv *priv = i2c_get_clientdata(client);
+
+	for (i = 0; i < ARRAY_SIZE(cap1066_base_attributes); ++i)
+		device_remove_file(&client->dev, cap1066_base_attributes[i]);
+
+	for (i = 0; i < ARRAY_SIZE(priv->keymap); ++i) {
+		if (priv->led_devices[i])
+			cap1066_remove_led_dev(priv->led_devices[i]);
+	}
+
+	input_unregister_polled_device(priv->poll_dev);
+	input_free_polled_device(priv->poll_dev);
+	kfree(priv);
+
+	return 0;
+}
+
+static struct i2c_driver cap1066_driver = {
+	.driver = {
+		.name	= "cap1066",
+	},
+	.probe		= cap1066_probe,
+	.remove		= cap1066_remove,
+	.id_table	= cap1066_id,
+
+	.detect		= cap1066_detect,
+	.class		= I2C_CLASS_HWMON,
+	.address_list	= normal_i2c,
+};
+
+static int __init cap1066_init(void)
+{
+	return i2c_add_driver(&cap1066_driver);
+}
+
+static void __exit cap1066_exit(void)
+{
+	i2c_del_driver(&cap1066_driver);
+}
+
+
+MODULE_AUTHOR("Maxime Bizon <mbizon@freebox.fr>");
+MODULE_DESCRIPTION("SMSC CAP1066 driver");
+MODULE_LICENSE("GPL");
+
+module_init(cap1066_init);
+module_exit(cap1066_exit);
diff -Nruw linux-2.6.39.4-fbx/drivers/media/dvb/tango2./Kconfig linux-2.6.39.4-fbx/drivers/media/dvb/tango2/Kconfig
--- linux-2.6.39.4-fbx/drivers/media/dvb/tango2./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/media/dvb/tango2/Kconfig	2011-05-24 18:15:34.105809375 +0200
@@ -0,0 +1,11 @@
+config DVB_TANGO2
+	tristate "Tango2 DVB adapter"
+	depends on DVB_CORE && ARCH_FBX5_B
+	select I2C
+	select I2C_ALGOBIT
+	select DVB_TDA1004X
+	select DVB_PLL
+
+config DVB_TANGO2_TESTBED
+	bool "extended testing and useful error codes"
+	depends on DVB_TANGO2
diff -Nruw linux-2.6.39.4-fbx/drivers/media/dvb/tango2./Makefile linux-2.6.39.4-fbx/drivers/media/dvb/tango2/Makefile
--- linux-2.6.39.4-fbx/drivers/media/dvb/tango2./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/media/dvb/tango2/Makefile	2011-05-24 18:15:34.105809375 +0200
@@ -0,0 +1,5 @@
+obj-$(CONFIG_DVB_TANGO2) = tango2_dvb.o
+
+tango2_dvb-objs := tango2.o
+
+EXTRA_CFLAGS = -Idrivers/media/dvb/dvb-core/ -Idrivers/media/dvb/frontends/
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/drivers/misc/crash_zone.c	2011-05-24 18:15:34.265808711 +0200
@@ -0,0 +1,145 @@
+#include <linux/init.h>
+#include <linux/crash_zone.h>
+#include <linux/proc_fs.h>
+#include <asm/checksum.h>
+
+static unsigned char *dead_zone = NULL;
+static unsigned int dead_zone_size;
+
+#define CRASH_DATA_SIZE	(dead_zone_size - sizeof (struct crash_zone))
+
+static inline unsigned short int csum_data(const unsigned char *buff, int len)
+{
+	return csum_fold(csum_partial(buff, len, 0));
+}
+
+static int crash_zone_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	struct crash_header *crash_zone;
+	int datalen;
+
+	/* check crash zone */
+	if (!dead_zone) {
+		printk(KERN_DEBUG "dead zone unset\n");
+		goto empty;
+	}
+
+	crash_zone = (struct crash_header *)dead_zone;
+	if (crash_zone->magic != CRASH_MAGIC) {
+		printk(KERN_DEBUG "bad crash zone magic\n");
+		goto empty;
+	}
+
+	if (crash_zone->len > dead_zone_size) {
+		printk(KERN_DEBUG "bad crash zone len\n");
+		goto empty;
+	}
+
+	if (csum_data((unsigned char *)crash_zone, crash_zone->len)) {
+		printk(KERN_DEBUG "bad crash zone checksum\n");
+		goto empty;
+	}
+
+	/* copy crash data */
+	datalen = crash_zone->len - sizeof (struct crash_header);
+	if (off + count >= datalen) {
+		*eof = 1;
+		count = datalen - off;
+	}
+
+	*start = page;
+	if (count > 0) {
+		memcpy(page, &crash_zone->data + off, count);
+		return count;
+	}
+
+	return 0;
+
+empty:
+	*eof = 1;
+	return 0;
+}
+
+static int crash_zone_write_proc(struct file *file, const char *buffer,
+				 unsigned long count, void *data)
+{
+	struct crash_header *crash_zone;
+	int len;
+
+	if (!dead_zone)
+		return count;
+
+	/* empty the crash zone */
+	crash_zone = (struct crash_header *)dead_zone;
+	len = sizeof (struct crash_header);
+	crash_zone->magic = CRASH_MAGIC;
+	crash_zone->len = len;
+	crash_zone->checksum = 0;
+	crash_zone->checksum = csum_data((unsigned char *)crash_zone, len);
+
+	return count;
+}
+
+static int crash_zone_panic_event(struct notifier_block *self,
+				  unsigned long event, void *data)
+{
+	struct crash_header *crash_zone;
+	int data_len, len;
+
+	if (!dead_zone)
+		return NOTIFY_DONE;
+
+	crash_zone = (struct crash_header *)dead_zone;
+
+	/* copy current kernel log into crash zone */
+	data_len = dead_zone_size - sizeof (struct crash_header);
+	console_emergency_dump(&crash_zone->data, &data_len);
+
+	/* checksum area */
+	len = data_len + sizeof (struct crash_header);
+	crash_zone->magic = CRASH_MAGIC;
+	crash_zone->len = len;
+	crash_zone->checksum = 0;
+	crash_zone->checksum = csum_data((unsigned char *)crash_zone, len);
+	printk("Panic log saved in crash zone\n");
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block crash_panic_block = {
+	crash_zone_panic_event,
+	NULL,
+	INT_MAX /* try to do it first */
+};
+
+void __init crash_zone_set_param(unsigned char *zone, unsigned int size)
+{
+	dead_zone = zone;
+	dead_zone_size = size;
+}
+
+static int __init crash_zone_init(void)
+{
+	struct proc_dir_entry	*proc;
+
+	/* create crash proc entry */
+	proc = create_proc_entry("crash_zone", 0, NULL);
+	if (!proc)
+		return 1;
+	proc->read_proc  = crash_zone_read_proc;
+	proc->write_proc = crash_zone_write_proc;
+
+	/* register panic notifier */
+	atomic_notifier_chain_register(&panic_notifier_list,
+				       &crash_panic_block);
+	return 0;
+}
+
+static void __exit crash_zone_exit(void)
+{
+
+}
+
+module_init(crash_zone_init);
+module_exit(crash_zone_exit);
diff -Nruw linux-2.6.39.4-fbx/drivers/misc/remoti./Kconfig linux-2.6.39.4-fbx/drivers/misc/remoti/Kconfig
--- linux-2.6.39.4-fbx/drivers/misc/remoti./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/misc/remoti/Kconfig	2011-06-15 18:56:42.595453772 +0200
@@ -0,0 +1,57 @@
+menu "RemoTI support"
+
+config REMOTI
+	tristate "RemoTI support"
+	depends on FBX6HD
+	---help---
+	  Texas Instruments RemoTI stack.
+
+config REMOTI_UART
+	tristate "RemoTI UART transport"
+	depends on REMOTI
+	depends on SERIAL_CORE
+	---help---
+	  RemoTI UART transport.
+
+config REMOTI_INPUT
+	tristate "RemoTI input support"
+	depends on REMOTI
+	depends on INPUT
+	---help---
+	  RemoTI Linux input driver support.
+
+config REMOTI_LEDS
+	tristate "RemoTI LEDS support"
+	depends on REMOTI
+	depends on LEDS_CLASS
+	---help---
+	  RemoTI LEDS class driver support.
+
+config REMOTI_GPIO
+	tristate "RemoTI gpio support"
+	depends on REMOTI
+	---help---
+	  gpiochip driver for the RemoTI RNP
+
+menu "RemoTI vendor-specific commands support"
+	depends on REMOTI_INPUT
+
+	config REMOTI_OAD
+		tristate "Over-the-Air firmware updates"
+		---help---
+		  Over-the-Air download support (firmware updates for Remote Controls).
+
+	config REMOTI_TEST
+		tristate "RemoTI test interface"
+		---help---
+		  Support for sending and reading test reports on RemoTI devices.
+		  This feature can be disabled in the Remote Control firmware.
+
+	config REMOTI_FBX
+		tristate "RemoTI Freebox device"
+		---help---
+		  Freebox RemoTI device (temp sensor, voltage input, gyro support).
+
+endmenu
+
+endmenu
diff -Nruw linux-2.6.39.4-fbx/drivers/misc/remoti./Makefile linux-2.6.39.4-fbx/drivers/misc/remoti/Makefile
--- linux-2.6.39.4-fbx/drivers/misc/remoti./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/misc/remoti/Makefile	2011-08-30 20:03:22.266572136 +0200
@@ -0,0 +1,20 @@
+obj-$(CONFIG_REMOTI)		+= remoti.o
+obj-$(CONFIG_REMOTI_UART)	+= remoti-uart.o
+obj-$(CONFIG_REMOTI_INPUT)	+= remoti-input.o
+obj-$(CONFIG_REMOTI_GPIO)	+= remoti-gpio.o
+obj-$(CONFIG_REMOTI_LEDS)	+= remoti-leds.o
+
+remoti-objs			:= core.o netlink.o
+remoti-uart-objs		:= uart.o
+remoti-input-objs		:= input.o
+remoti-gpio-objs		:= gpio.o
+remoti-leds-objs		:= leds.o
+
+# Vendor-specific command support
+obj-$(CONFIG_REMOTI_OAD)	+= remoti-input-oad.o
+obj-$(CONFIG_REMOTI_TEST)	+= remoti-input-test.o
+obj-$(CONFIG_REMOTI_FBX)	+= remoti-input-fbx.o
+
+remoti-input-oad-objs		:= oad.o
+remoti-input-fbx-objs		:= fbx.o
+remoti-input-test-objs		:= test.o
diff -Nruw linux-2.6.39.4-fbx/drivers/platform/intelce./Kconfig linux-2.6.39.4-fbx/drivers/platform/intelce/Kconfig
--- linux-2.6.39.4-fbx/drivers/platform/intelce./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/platform/intelce/Kconfig	2011-06-15 18:56:43.185455429 +0200
@@ -0,0 +1,18 @@
+#
+# IntelCE devices configuration
+#
+
+menu "IntelCE devices"
+
+config INTELCE_GPIO
+	tristate "GPIO support"
+	select ARCH_REQUIRE_GPIOLIB
+	---help---
+	  IntelCE 3100/4100 GPIO support.
+
+config INTELCE_DFX
+	tristate "DFX reporting support"
+	---help---
+	  IntelCE 3100/4100 DFX fuse reporting support.
+
+endmenu
diff -Nruw linux-2.6.39.4-fbx/drivers/platform/intelce./Makefile linux-2.6.39.4-fbx/drivers/platform/intelce/Makefile
--- linux-2.6.39.4-fbx/drivers/platform/intelce./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/platform/intelce/Makefile	2011-06-15 18:56:43.185455429 +0200
@@ -0,0 +1,2 @@
+obj-$(CONFIG_INTELCE_GPIO)	+= gpio-intelce.o
+obj-$(CONFIG_INTELCE_DFX)	+= dfx.o
diff -Nruw linux-2.6.39.4-fbx/drivers/platform/tango2./Kconfig linux-2.6.39.4-fbx/drivers/platform/tango2/Kconfig
--- linux-2.6.39.4-fbx/drivers/platform/tango2./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/platform/tango2/Kconfig	2011-05-24 18:15:34.765806632 +0200
@@ -0,0 +1,30 @@
+#
+# TANGO2 devices configuration
+#
+
+menu "Tango2 devices"
+	depends on TANGO2
+
+config TANGO2_FIP
+	tristate "Front panel support"
+	select INPUT
+	---help---
+	  Tango2 FIP front panel support.
+
+config TANGO2_GPIO
+	tristate "GPIO sysfs support"
+	---help---
+	  Export GPIO attributes in sysfs.
+
+config TANGO2_IR
+	tristate "IR support"
+	---help---
+	  Tango2 IR (NEC/RC5/RC6) support.
+
+config TANGO2_FB
+	tristate "Framebuffer support"
+	depends on FB
+	---help---
+	  Tango2 framebuffer support.
+
+endmenu
diff -Nruw linux-2.6.39.4-fbx/drivers/platform/tango2./Makefile linux-2.6.39.4-fbx/drivers/platform/tango2/Makefile
--- linux-2.6.39.4-fbx/drivers/platform/tango2./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/drivers/platform/tango2/Makefile	2011-05-24 18:15:34.765806632 +0200
@@ -0,0 +1,6 @@
+# Makefile for the TANGO2 device drivers
+
+obj-$(CONFIG_TANGO2_FIP) += fip.o
+obj-$(CONFIG_TANGO2_GPIO) += gpio.o
+obj-$(CONFIG_TANGO2_IR) += ir.o
+obj-$(CONFIG_TANGO2_FB) += fb.o
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/drivers/spi/orion_tdm_spi.c	2011-06-15 18:56:43.435456131 +0200
@@ -0,0 +1,578 @@
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/orion_tdm_spi.h>
+#include <linux/gpio.h>
+#include <asm/unaligned.h>
+
+#define DRIVER_NAME			"orion_tdm_spi"
+
+/*
+ * registers
+ */
+#define PCM_CTRL_REG			0x0000
+#define PCM_DAA_CSS_CTRL_MASK		(1 << 15)
+
+#define SPI_CLK_PRESCALE_REG		0x3100
+#define SCLOCK_LOW_SHIFT		0
+#define SCLOCK_LOW_MASK			(0xff << SCLOCK_LOW_SHIFT)
+#define SCLOCK_HIGH_SHIFT		8
+#define SCLOCK_HIGH_MASK		(0xff << SCLOCK_HIGH_SHIFT)
+
+#define SPI_GLOBAL_CTRL_REG		0x3104
+#define CODEC_ENABLE_MASK		(1 << 0)
+
+#define SPI_CTRL_REG			0x3108
+#define SPI_STAT_MASK			(1 << 10)
+
+#define SPI_CODEC_ACCESS_L_REG		0x3130
+#define ACCESS_BYTE0_SHIFT		0
+#define ACCESS_BYTE1_SHIFT		8
+
+#define SPI_CODEC_ACCESS_H_REG		0x3134
+#define ACCESS_BYTE2_SHIFT		0
+#define ACCESS_BYTE3_SHIFT		8
+
+#define SPI_REG_ACCESS_CTRL_REG		0x3138
+#define BYTES_TO_XFER_MASK		0x3
+#define SPI_LSB_MSB_MASK		(1 << 2)
+#define SPI_RD_WR_MASK			(1 << 3)
+#define SPI_BYTES_TO_READ_SHIFT		4
+#define SPI_LO_SPEED_CLK_MASK		(1 << 5)
+#define SPI_READ_CS_HOLD_SHIFT		6
+
+#define SPI_READ_DATA_REG		0x313c
+
+#define SPI_REG_ACCESS_CTRL1_REG	0x3140
+#define SPI_WRITE_CS_HOLD_SHIFT		0
+
+#define SPI_OUT_EN_CTRL_REG		0x4000
+#define SPI_OUT_EN_DISABLE_MASK		(1 << 0)
+
+
+struct orion_tdm_spi {
+	struct spi_master		*master;
+	void __iomem			*base;
+
+	unsigned int			max_speed;
+	unsigned int			min_speed;
+
+	/* current configured speed/divs for each CS, drivers uses "low"
+	 * for CS0 and "high" for CS1 */
+	unsigned int			speeds[2];
+	u32				divs[2];
+
+	unsigned int			current_cs;
+	struct orion_tdm_spi_info	*spi_info;
+};
+
+MODULE_ALIAS("platform:" DRIVER_NAME);
+
+static inline u32 spi_readl(struct orion_tdm_spi *priv, u32 reg)
+{
+	u32 val;
+
+	val = readl(priv->base + reg);
+/* 	printk("spi_readl: readl at %08x => 0x%08x\n", */
+/* 	       priv->base + reg, val); */
+	return val;
+}
+
+static inline void spi_writel(struct orion_tdm_spi *priv, u32 val, u32 reg)
+{
+/* 	printk("spi_writl: writl at %08x <= 0x%08x\n", */
+/* 	       priv->base + reg, val); */
+	writel(val, priv->base + reg);
+}
+
+static int spi_baudrate_set(struct orion_tdm_spi *priv,
+			    unsigned int cs, unsigned int speed)
+{
+	u32 div, val;
+
+/* 	printk("spi_baudrate_set: cs:%u - speed:%u\n", cs, speed); */
+	if (priv->speeds[cs] == speed)
+		return 0;
+
+	/* find divider, the supported values are: 2...254 (even only) */
+	div = DIV_ROUND_UP(priv->spi_info->tclk, speed);
+	div = roundup(div, 2);
+
+	if (div > 254)
+		return 1;
+
+	if (div < 2)
+		div = 2;
+
+	/* don't reprogram div if not needed */
+	if (priv->divs[cs] == div) {
+		priv->speeds[cs] = speed;
+		return 0;
+	}
+
+	/* Convert the rate to SPI clock divisor value.	*/
+	val = spi_readl(priv, SPI_CLK_PRESCALE_REG);
+	if (cs) {
+		val &= ~SCLOCK_HIGH_MASK;
+		val |= div << SCLOCK_HIGH_SHIFT;
+	} else {
+		val &= ~SCLOCK_LOW_MASK;
+		val |= div << SCLOCK_LOW_SHIFT;
+	}
+	spi_writel(priv, val, SPI_CLK_PRESCALE_REG);
+
+	priv->speeds[cs] = speed;
+	priv->divs[cs] = div;
+	return 0;
+}
+
+static void spi_set_cs(struct orion_tdm_spi *priv, struct spi_device *spi,
+		       int active)
+{
+	struct orion_tdm_spi_info *spi_info;
+	int gpio;
+
+	spi_info = priv->spi_info;
+
+	/* set correct cs in hardware */
+	if (spi->chip_select != priv->current_cs) {
+		u32 val;
+
+		val = spi_readl(priv, PCM_CTRL_REG);
+		if (spi->chip_select)
+			val |= PCM_DAA_CSS_CTRL_MASK;
+		else
+			val &= ~PCM_DAA_CSS_CTRL_MASK;
+		spi_writel(priv, val, PCM_CTRL_REG);
+		priv->current_cs = spi->chip_select;
+	}
+
+	/* if not using gpio, hardware moves cs for us */
+	gpio = spi_info->cs_use_gpio[priv->current_cs];
+	if (gpio == -1)
+		return;
+
+	gpio_set_value(gpio, 1 - active);
+}
+
+static int do_spi_poll(struct orion_tdm_spi *priv)
+{
+	unsigned int loop;
+	u32 val;
+
+	for (loop = 0; loop < 1000; loop++) {
+		val = spi_readl(priv, SPI_CTRL_REG);
+		if (!(val & SPI_STAT_MASK))
+			return 0;
+	}
+	return 1;
+}
+
+static int do_write_read(struct orion_tdm_spi *priv, struct spi_device *spi,
+			 const u8 *tx, unsigned int tx_len,
+			 u8 *rx, unsigned int rx_len)
+{
+	u32 val;
+
+	if (do_spi_poll(priv)) {
+		dev_err(&spi->dev, "spi_poll timed out\n");
+		return 1;
+	}
+
+	val = tx[0];
+	if (tx_len > 1)
+		val |= tx[1] << 8;
+	spi_writel(priv, val, SPI_CODEC_ACCESS_L_REG);
+
+	if (tx_len > 2) {
+		val = tx[2];
+		if (tx_len > 3)
+			val |= tx[3] << 8;
+		spi_writel(priv, val, SPI_CODEC_ACCESS_H_REG);
+	}
+
+
+	val = tx_len - 1;
+	if (rx_len)
+		val |= SPI_RD_WR_MASK;
+	if (rx_len > 1)
+		val |= (1 << SPI_BYTES_TO_READ_SHIFT);
+	if (spi->chip_select) {
+		/* note: bit set to 1 => use high speed */
+		val |= SPI_LO_SPEED_CLK_MASK;
+	}
+	spi_writel(priv, val, SPI_REG_ACCESS_CTRL_REG);
+
+	val = spi_readl(priv, SPI_CTRL_REG);
+	val |= SPI_STAT_MASK;
+	spi_writel(priv, val, SPI_CTRL_REG);
+
+	if (do_spi_poll(priv)) {
+		dev_err(&spi->dev, "spi_poll timed out\n");
+		return 1;
+	}
+
+	if (rx_len) {
+		val = spi_readl(priv, SPI_READ_DATA_REG);
+		rx[0] = val & 0xff;
+		if (rx_len > 1)
+			rx[1] = (val >> 8) & 0xff;
+	}
+
+	return 0;
+}
+
+static int orion_tdm_spi_setup(struct spi_device *spi)
+{
+	struct orion_tdm_spi *priv;
+
+	priv = spi_master_get_devdata(spi->master);
+
+	if (spi->bits_per_word == 0)
+		spi->bits_per_word = 8;
+
+	if (spi->bits_per_word != 8) {
+		dev_err(&spi->dev, "setup: unsupported transfer width %u\n",
+			spi->bits_per_word);
+		return -EINVAL;
+	}
+
+	if ((spi->max_speed_hz == 0) ||
+	    (spi->max_speed_hz > priv->max_speed))
+		spi->max_speed_hz = priv->max_speed;
+
+	if (spi->max_speed_hz < priv->min_speed) {
+		dev_err(&spi->dev, "setup: requested speed too low %d Hz\n",
+			spi->max_speed_hz);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int orion_tdm_spi_transfer(struct spi_device *spi,
+				  struct spi_message *m)
+{
+	struct orion_tdm_spi *priv;
+	struct spi_transfer *t;
+	int want_write, cs_active;
+
+	m->actual_length = 0;
+	m->status = 0;
+
+/* 	printk("orion_tdm_spi_transfer for device speed %u\n", */
+/* 		spi->max_speed_hz); */
+
+	/* reject invalid messages and transfers */
+	if (list_empty(&m->transfers) || !m->complete)
+		return -EINVAL;
+
+	priv = spi_master_get_devdata(spi->master);
+
+	/*
+	 * first pass for sanity check
+	 *
+	 * hardware  is  dumb,  and   can't  read/write  at  the  same
+	 * time. Worst, you have to write at least one byte to be able
+	 * to read, and you can't not read more than two bytes.
+	 */
+	want_write = 0;
+
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+
+		if (!t->len)
+			continue;
+
+		if (t->tx_buf && t->rx_buf) {
+			dev_err(&spi->dev,
+				"message rejected : "
+				"full duplex transfer not supported\n");
+			m->status = -ENOTSUPP;
+			goto msg_done;
+		}
+
+		if (!t->tx_buf && !t->rx_buf && t->len) {
+			dev_err(&spi->dev,
+				"message rejected : "
+				"invalid transfer data buffers\n");
+			m->status = -EINVAL;
+			goto msg_done;
+		}
+
+		/* check if forced transfer width is valid */
+		if (t->bits_per_word && t->bits_per_word != 8) {
+			dev_err(&spi->dev,
+				"message rejected : "
+				"invalid transfer bits_per_word (%d bits)\n",
+				t->bits_per_word);
+			m->status = -EINVAL;
+			goto msg_done;
+		}
+
+		/* check if forced transfer speed if ok */
+		if (t->speed_hz && t->speed_hz < priv->min_speed) {
+			dev_err(&spi->dev,
+				"message rejected : "
+				"device min speed (%d Hz) exceeds "
+				"required transfer speed (%d Hz)\n",
+				priv->min_speed, t->speed_hz);
+			m->status = -EINVAL;
+			goto msg_done;
+		}
+
+		if (t->tx_buf)
+			want_write += t->len;
+		if (t->rx_buf) {
+			if (t->len > 2) {
+				dev_err(&spi->dev,
+					"message rejected : "
+					"marvell dumb spi can't read "
+					"more than 2 bytes\n");
+				m->status = -EINVAL;
+				goto msg_done;
+
+			}
+
+			if (want_write)
+				want_write = 0;
+			else {
+				dev_err(&spi->dev,
+					"message rejected : "
+					"marvell dumb spi can't read "
+					"without write first\n");
+				m->status = -EINVAL;
+				goto msg_done;
+			}
+		}
+	}
+
+/* 	printk("SPI CS\n"); */
+	spi_set_cs(priv, spi, 0);
+	cs_active = 0;
+
+	/* do the actual transfer, we need to coalesce write and read
+	 * transfer */
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		unsigned int i, speed;
+
+		if (!t->len)
+			continue;
+
+		/* get and configure speed for this transfer */
+		if (t->speed_hz)
+			speed = t->speed_hz;
+		else
+			speed = spi->max_speed_hz;
+
+		if (spi_baudrate_set(priv, spi->chip_select, speed)) {
+			m->status = -EINVAL;
+			goto msg_done;
+		}
+
+		/* write always one byte, if this is the last byte to
+		 * transfer, lookahead next transfer and read if
+		 * needed */
+		BUG_ON(!t->tx_buf);
+
+		for (i = 0; i < t->len;) {
+			struct spi_transfer *nt;
+			u8 *rx;
+			const u8 *tx;
+			unsigned int rx_len, tx_remain;
+
+			rx = NULL;
+			nt = NULL;
+			rx_len = 0;
+
+			tx_remain = t->len - i;
+			if (tx_remain == 1) {
+				struct list_head *e;
+
+				/* last byte to write, check if next
+				 * transfer is a read and coalesce */
+				e = t->transfer_list.next;
+				if (e != &m->transfers) {
+					nt = list_entry(e, struct spi_transfer,
+							transfer_list);
+					if (nt->rx_buf) {
+						rx = nt->rx_buf;
+						rx_len = nt->len;
+					} else
+						nt = NULL;
+				}
+			}
+
+			/* we can write 4 bytes at a time if not
+			 * reading */
+			if (tx_remain > 4)
+				tx_remain = 4;
+			else {
+				/* make sure we leave at least one
+				 * byte in case we need to coalesce
+				 * with next read */
+				if (tx_remain > 1)
+					tx_remain--;
+			}
+			tx = t->tx_buf + i;
+
+			if (!cs_active) {
+				spi_set_cs(priv, spi, 1);
+				cs_active = 1;
+			}
+
+			if (do_write_read(priv, spi, tx, tx_remain,
+					  rx, rx_len)) {
+				m->status = -EIO;
+				goto msg_done;
+			}
+
+			if (t->cs_change) {
+				spi_set_cs(priv, spi, 0);
+				cs_active = 0;
+			}
+
+			m->actual_length += tx_remain + rx_len;
+
+			/* skip next transfer if we coalesced it */
+			if (nt) {
+				t = nt;
+				break;
+			}
+
+			i += tx_remain;
+		}
+
+		if (t->delay_usecs)
+			udelay(t->delay_usecs);
+	}
+
+	if (cs_active)
+		spi_set_cs(priv, spi, 0);
+
+msg_done:
+	if (m->complete)
+		m->complete(m->context);
+	return m->status;
+}
+
+static int __init orion_tdm_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct orion_tdm_spi *priv;
+	struct resource *r;
+	struct orion_tdm_spi_info *spi_info;
+	int status = 0;
+	u32 val;
+
+	spi_info = pdev->dev.platform_data;
+
+	master = spi_alloc_master(&pdev->dev, sizeof (*priv));
+	if (master == NULL) {
+		dev_dbg(&pdev->dev, "master allocation failed\n");
+		return -ENOMEM;
+	}
+
+	if (pdev->id != -1)
+		master->bus_num = pdev->id;
+
+	master->setup = orion_tdm_spi_setup;
+	master->transfer = orion_tdm_spi_transfer;
+	master->num_chipselect = 2;
+	master->mode_bits = 0;
+
+	dev_set_drvdata(&pdev->dev, master);
+
+	priv = spi_master_get_devdata(master);
+	priv->master = master;
+	priv->spi_info = spi_info;
+
+	priv->max_speed = DIV_ROUND_UP(spi_info->tclk, 4);
+	priv->min_speed = DIV_ROUND_UP(spi_info->tclk, 254);
+	priv->current_cs = ~0;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		status = -ENODEV;
+		goto out;
+	}
+
+	if (!request_mem_region(r->start, (r->end - r->start) + 1,
+				dev_name(&pdev->dev))) {
+		status = -EBUSY;
+		goto out;
+	}
+
+	priv->base = ioremap(r->start, SZ_64K);
+
+	/* configure TDM SPI */
+	val = spi_readl(priv, SPI_OUT_EN_CTRL_REG);
+	val &= ~SPI_OUT_EN_DISABLE_MASK;
+	spi_writel(priv, val, SPI_OUT_EN_CTRL_REG);
+
+	val = spi_readl(priv, SPI_GLOBAL_CTRL_REG);
+	val |= CODEC_ENABLE_MASK;
+	spi_writel(priv, val, SPI_GLOBAL_CTRL_REG);
+
+	printk("orion_tdm_spi_probe will register master\n");
+
+	status = spi_register_master(master);
+	if (status < 0)
+		goto out_rel_mem;
+
+	return status;
+
+out_rel_mem:
+	release_mem_region(r->start, (r->end - r->start) + 1);
+out:
+	spi_master_put(master);
+	return status;
+}
+
+static int __exit orion_tdm_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct orion_tdm_spi *priv;
+	struct resource *r;
+
+	master = dev_get_drvdata(&pdev->dev);
+	priv = spi_master_get_devdata(master);
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(r->start, (r->end - r->start) + 1);
+
+	iounmap(priv->base);
+	spi_unregister_master(master);
+
+	return 0;
+}
+
+static struct platform_driver orion_tdm_spi_driver = {
+	.driver = {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.remove		= __exit_p(orion_tdm_spi_remove),
+};
+
+static int __init orion_tdm_spi_init(void)
+{
+	return platform_driver_probe(&orion_tdm_spi_driver,
+				     orion_tdm_spi_probe);
+}
+
+module_init(orion_tdm_spi_init);
+
+static void __exit orion_tdm_spi_exit(void)
+{
+	platform_driver_unregister(&orion_tdm_spi_driver);
+}
+
+module_exit(orion_tdm_spi_exit);
+
+MODULE_DESCRIPTION("Orion TDM SPI driver");
+MODULE_AUTHOR("Maxime Bizon <mbizon@freebox.fr>");
+MODULE_LICENSE("GPL");
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/drivers/video/ssd1327.c	2011-06-15 18:56:44.425458910 +0200
@@ -0,0 +1,700 @@
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/ssd1327.h>
+#include <linux/workqueue.h>
+#include <linux/gpio.h>
+#include <linux/fb.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/backlight.h>
+
+/*
+ * commands
+ */
+#define OPCODE_CONTRAST		0x81
+
+#define OPCODE_SET_COLUMN	0x15
+#define OPCODE_SET_ROW		0x75
+#define OPCODE_SET_REMAP	0xa0
+#define OPCODE_DISPLAY_NORMAL	0xa4
+#define OPCODE_DISPLAY_ALL_ON	0xa5
+#define OPCODE_DISPLAY_ALL_OFF	0xa6
+
+#define OPCODE_DISPLAY_OFF	0xae
+#define OPCODE_DISPLAY_ON	0xaf
+
+#define OPCODE_DEF_GRAY		0xb9
+
+#define SSD1327_MAX_BRIGHTNESS		0x81
+#define SSD1327_NOMINAL_BRIGHTNESS	0x64
+
+/*
+ * fbinfo
+ */
+static struct fb_fix_screeninfo ssd1327_fb_fix = {
+	.id		= "ssd1327",
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.visual		= FB_VISUAL_STATIC_PSEUDOCOLOR,
+	.xpanstep	= 0,
+	.ypanstep	= 1,
+	.ywrapstep	= 0,
+	.accel		= FB_ACCEL_NONE,
+};
+
+static struct fb_var_screeninfo ssd1327_fb_var = {
+	.bits_per_pixel	= 8,
+	.grayscale	= 1,
+	.nonstd		= 1,
+	.red.length	= 8,
+	.green.length	= 8,
+	.blue.length	= 8,
+};
+
+/*
+ * private data
+ */
+#define SSD1327_COLS		64
+#define SSD1327_ROWS		128
+#define GDDRAM_SIZE		SSD1327_COLS * SSD1327_ROWS
+
+struct ssd1327 {
+	struct mutex			mutex;
+
+	/* image of display ram */
+	u8				gddram[GDDRAM_SIZE];
+	u8				old_gddram[GDDRAM_SIZE];
+
+	/* data ram, 8 bits per pixel */
+	u8				*vmem;
+	unsigned int			vmem_size;
+
+	struct fb_info			*fb;
+	struct ssd1327_platform_data	*data;
+	struct spi_device		*spi;
+
+	struct backlight_device		*backlight;
+	unsigned int			brightness;
+
+	/* watchog timer */
+	struct delayed_work		wtd_work;
+	unsigned int			wtd_max;
+	atomic_t			wtd_count;
+};
+
+/*
+ * send command to device
+ */
+static int send_cmd(struct ssd1327 *priv, u8 cmd)
+{
+	struct ssd1327_platform_data *data;
+	int ret;
+
+	data = priv->spi->dev.platform_data;
+
+	mutex_lock(&priv->mutex);
+	gpio_set_value(data->data_select_gpio, 0);
+	ret = spi_write_then_read(priv->spi, &cmd, 1, NULL, 0);
+	mutex_unlock(&priv->mutex);
+	return ret;
+}
+
+/*
+ * send command list to device
+ */
+static int send_cmds(struct ssd1327 *priv, const u8 *cmd, unsigned int len)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < len; i++) {
+		ret = send_cmd(priv, cmd[i]);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+/*
+ * write given data into device gddram
+ */
+static int write_data(struct ssd1327 *priv, u8 *tx, unsigned int size)
+{
+	struct ssd1327_platform_data *data;
+	int ret;
+
+	data = priv->spi->dev.platform_data;
+
+	mutex_lock(&priv->mutex);
+	gpio_set_value(data->data_select_gpio, 1);
+	ret = spi_write(priv->spi, tx, size);
+	mutex_unlock(&priv->mutex);
+	return ret;
+}
+
+/*
+ * soft reset & initialize ssd1327
+ */
+static int ssd1327_init(struct ssd1327 *priv)
+{
+	const u8 init_cmds[] = { OPCODE_DISPLAY_ON,
+
+				 /* set even/odd splitting */
+				 OPCODE_SET_REMAP, (1 << 6),
+				 OPCODE_CONTRAST, SSD1327_NOMINAL_BRIGHTNESS,
+				 OPCODE_DEF_GRAY,
+				 OPCODE_DISPLAY_NORMAL,
+	};
+	int ret;
+
+	/* zero ram */
+	ret = write_data(priv, priv->gddram, GDDRAM_SIZE);
+	if (ret)
+		return ret;
+
+	return send_cmds(priv, init_cmds, sizeof (init_cmds));
+}
+
+/*
+ * update area
+ */
+static int ssd1327_fb_update(struct ssd1327 *priv)
+{
+	unsigned int col, row, w, h, i, count;
+	unsigned char *vmem;
+	u8 *start;
+	u8 ccmds[3] = { OPCODE_SET_COLUMN, 0, 0x3f };
+	u8 rcmds[3] = { OPCODE_SET_ROW, 0, 0x7f };
+	int toggle, last_toggle_pos, moved;
+
+	w = priv->data->width;
+	h = priv->data->height;
+
+	/* backup previous gddram */
+	memcpy(priv->old_gddram, priv->gddram, GDDRAM_SIZE);
+
+	vmem = priv->vmem + w * priv->fb->var.yoffset;
+
+	for (row = 0; row < SSD1327_ROWS; row++) {
+
+		if (row >= h)
+			break;
+
+		for (col = 0; col < SSD1327_COLS; col++) {
+			unsigned int nibble;
+			u8 val;
+
+			val = 0;
+			for (nibble = 0; nibble < 2; nibble++) {
+				unsigned int off, x;
+				u8 vval;
+
+				x = col * 2 + nibble;
+				if (x >= w)
+					break;
+
+				switch (priv->fb->var.rotate) {
+				case 0:
+				default:
+					off = row * w + x;
+					break;
+
+				case 180:
+					off = w * h - (row * w + x) - 1;
+					break;
+
+				case 90:
+					off = (w - x - 1) * w + row;
+					break;
+
+				case 270:
+					off = x * w + (h - row - 1);
+					break;
+				}
+
+				vval = vmem[off] >> 4;
+				val |= vval << (nibble * 4);
+			}
+
+			priv->gddram[row * SSD1327_COLS + col] = val;
+		}
+	}
+
+	/* count consecutive toggled bytes, each column/row address
+	 * change adds 6 bytes to send  */
+	moved = toggle = 0;
+	last_toggle_pos = -INT_MAX;
+	count = 0;
+	for (i = 0; i < GDDRAM_SIZE; i++) {
+		if (priv->gddram[i] ^ priv->old_gddram[i]) {
+			/* if crossing column boundary and first
+			 * address is not 0, we must send column
+			 * command */
+			if (moved && ((i % SSD1327_COLS) == 0)) {
+				count += 3;
+				moved = 0;
+			}
+
+			if (!toggle) {
+				if (i - last_toggle_pos < 6) {
+					unsigned int j;
+
+					/* fake last columns as dirty,
+					 * cheaper than repositionning
+					 * cursor */
+					for (j = last_toggle_pos; j < i; j++)
+						priv->old_gddram[j] =
+							~priv->gddram[j];
+
+					count += i - last_toggle_pos - 1;
+				} else {
+					/* send command to change
+					 * address & column */
+					count += 6;
+
+					/* if we changed first column address
+					 * to non 0, remember it */
+					if ((i % SSD1327_COLS))
+						moved = 1;
+					else
+						moved = 0;
+				}
+			}
+
+			toggle = 1;
+			count++;
+
+		} else {
+			if (toggle)
+				last_toggle_pos = i - 1;
+			toggle = 0;
+		}
+	}
+
+	/* force full gddram update if we would send more bytes
+	 * using clever update */
+	if (count > GDDRAM_SIZE)
+		return write_data(priv, priv->gddram, GDDRAM_SIZE);
+
+	moved = toggle = 0;
+	count = 0;
+	start = NULL;
+	for (i = 0; i < GDDRAM_SIZE; i++) {
+
+		if (priv->gddram[i] ^ priv->old_gddram[i]) {
+			/* if crossed column boundary and first
+			 * address is not 0, we must send command to
+			 * reset column*/
+			if (moved && ((i % SSD1327_COLS) == 0)) {
+				write_data(priv, start, count);
+				start += count;
+				count = 0;
+				ccmds[1] = 0;
+				send_cmds(priv, ccmds, 3);
+				moved = 0;
+			}
+
+			if (!toggle) {
+				ccmds[1] = i % SSD1327_COLS;
+				rcmds[1] = i / SSD1327_COLS;
+				send_cmds(priv, ccmds, 3);
+				send_cmds(priv, rcmds, 3);
+
+				/* if we changed first column address
+				 * to non 0, remember it */
+				if ((i % SSD1327_COLS))
+					moved = 1;
+				else
+					moved = 0;
+				start = &priv->gddram[i];
+			}
+
+			count++;
+			toggle = 1;
+
+		} else {
+			if (count) {
+				write_data(priv, start, count);
+				count = 0;
+			}
+			toggle = 0;
+		}
+	}
+
+	if (count)
+		write_data(priv, start, count);
+
+	/* reset position */
+	ccmds[1] = 0;
+	send_cmds(priv, ccmds, 3);
+	rcmds[1] = 0;
+	send_cmds(priv, rcmds, 3);
+	return 0;
+}
+
+/*
+ * frame buffer fill rect callback
+ */
+static void ssd1327_fb_fillrect(struct fb_info *info,
+				const struct fb_fillrect *rect)
+{
+	struct ssd1327 *priv = info->par;
+	sys_fillrect(info, rect);
+	atomic_set(&priv->wtd_count, priv->wtd_max);
+	ssd1327_fb_update(priv);
+}
+
+/*
+ * frame buffer copy area callback
+ */
+static void ssd1327_fb_copyarea(struct fb_info *info,
+				const struct fb_copyarea *area)
+{
+	struct ssd1327 *priv = info->par;
+	sys_copyarea(info, area);
+	atomic_set(&priv->wtd_count, priv->wtd_max);
+	ssd1327_fb_update(priv);
+}
+
+/*
+ * frame buffer image blit
+ */
+static void ssd1327_fb_imageblit(struct fb_info *info,
+				 const struct fb_image *image)
+{
+	struct ssd1327 *priv = info->par;
+	sys_imageblit(info, image);
+	atomic_set(&priv->wtd_count, priv->wtd_max);
+	ssd1327_fb_update(priv);
+}
+
+/*
+ * frame buffer pan callback
+ */
+static int ssd1327_fb_pan(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct ssd1327 *priv = info->par;
+	priv->fb->var.xoffset = var->xoffset;
+	priv->fb->var.yoffset = var->yoffset;
+	atomic_set(&priv->wtd_count, priv->wtd_max);
+	ssd1327_fb_update(priv);
+	return 0;
+}
+
+/*
+ * fram buffer set_par callback, set videomode
+ */
+static int ssd1327_fb_set_par(struct fb_info *info)
+{
+	struct ssd1327 *priv = info->par;
+	/* called after rotate update */
+	atomic_set(&priv->wtd_count, priv->wtd_max);
+	ssd1327_fb_update(priv);
+	return 0;
+}
+
+static int ssd1327_fb_check_var(struct fb_var_screeninfo *var,
+				struct fb_info *info)
+{
+	unsigned int rotate;
+
+	rotate = var->rotate;
+	if (rotate != 0 && rotate != 90 && rotate != 180 && rotate != 270)
+		rotate = 0;
+	*var = info->var;
+	var->rotate = rotate;
+	return 0;
+}
+
+/*
+ * frame buffer blank callback
+ */
+static int ssd1327_fb_blank(int blank, struct fb_info *info)
+{
+	return 0;
+}
+
+/*
+ * frame buffer write from userspace
+ */
+static ssize_t ssd1327_fb_write(struct fb_info *info, const char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	struct ssd1327 *priv = info->par;
+	unsigned long p = *ppos;
+	void *dst;
+	int err = 0;
+	unsigned long total_size;
+
+	if (info->state != FBINFO_STATE_RUNNING)
+		return -EPERM;
+
+	total_size = info->fix.smem_len;
+
+	if (p > total_size)
+		return -EFBIG;
+
+	if (count > total_size) {
+		err = -EFBIG;
+		count = total_size;
+	}
+
+	if (count + p > total_size) {
+		if (!err)
+			err = -ENOSPC;
+
+		count = total_size - p;
+	}
+
+	dst = (void __force *)(info->screen_base + p);
+
+	if (copy_from_user(dst, buf, count))
+		err = -EFAULT;
+
+	if  (!err)
+		*ppos += count;
+
+	atomic_set(&priv->wtd_count, priv->wtd_max);
+	ssd1327_fb_update(priv);
+
+	return (err) ? err : count;
+}
+
+static struct fb_ops ssd1327_fb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_write	= ssd1327_fb_write,
+	.fb_fillrect	= ssd1327_fb_fillrect,
+	.fb_copyarea	= ssd1327_fb_copyarea,
+	.fb_imageblit	= ssd1327_fb_imageblit,
+	.fb_pan_display	= ssd1327_fb_pan,
+	.fb_blank	= ssd1327_fb_blank,
+	.fb_check_var	= ssd1327_fb_check_var,
+	.fb_set_par	= ssd1327_fb_set_par,
+};
+
+/*
+ * watchdog timer
+ */
+static void wtd_work_cb(struct work_struct *t)
+{
+	struct ssd1327 *priv;
+	struct delayed_work *dwork;
+
+	dwork = container_of(t, struct delayed_work, work);
+	priv = container_of(dwork, struct ssd1327, wtd_work);
+
+	if (atomic_dec_and_test(&priv->wtd_count)) {
+		dev_err(&priv->spi->dev, "watchdog triggered\n");
+		memset(priv->vmem, 0, priv->vmem_size);
+		ssd1327_fb_update(priv);
+	}
+
+	schedule_delayed_work(&priv->wtd_work, HZ);
+}
+
+/*
+ * backlight control
+ */
+static int ssd1327_bl_update_status(struct backlight_device *bl)
+{
+	struct ssd1327 *priv;
+	u8 bl_cmds[4];
+	int ret;
+
+	priv = bl_get_data(bl);
+
+	bl_cmds[0] = OPCODE_CONTRAST;
+	bl_cmds[1] = bl->props.brightness;
+
+	ret = send_cmds(priv, bl_cmds, sizeof (bl_cmds));
+	if (ret < 0)
+		return ret;
+	priv->brightness = bl->props.brightness;
+	return 0;
+}
+
+static int ssd1327_bl_get_brightness(struct backlight_device *bl)
+{
+	struct ssd1327 *priv;
+	priv = bl_get_data(bl);
+	return priv->brightness;
+}
+
+static struct backlight_ops ssd1327_bl_ops = {
+	.update_status		= ssd1327_bl_update_status,
+	.get_brightness		= ssd1327_bl_get_brightness,
+};
+
+static const struct backlight_properties ssd1327_bl_props = {
+	.power		= FB_BLANK_UNBLANK,
+	.fb_blank	= FB_BLANK_UNBLANK,
+	.max_brightness	= SSD1327_MAX_BRIGHTNESS,
+	.type		= BACKLIGHT_RAW,
+};
+
+static int __devinit init_backlight(struct ssd1327 *priv)
+{
+	struct backlight_device *bl;
+
+	bl = backlight_device_register("ssd1327", &priv->spi->dev,
+				       priv, &ssd1327_bl_ops,
+				       &ssd1327_bl_props);
+	if (IS_ERR(bl)) {
+		dev_err(&priv->spi->dev, "error %ld on backlight register\n",
+			PTR_ERR(bl));
+		return PTR_ERR(bl);
+	}
+	priv->backlight = bl;
+	bl->props.brightness = priv->brightness;
+	return 0;
+}
+
+/*
+ * platform device probe callback
+ */
+static int __devinit ssd1327_probe(struct spi_device *spi)
+{
+	struct ssd1327 *priv;
+	struct ssd1327_platform_data *data;
+	struct fb_info *fb;
+	int ret;
+
+	data = spi->dev.platform_data;
+	if (!data) {
+		dev_err(&spi->dev, "no screen description\n");
+		return -ENODEV;
+	}
+
+	/* sanity check on screen size */
+	if (data->width > SSD1327_COLS * 2 ||
+	    data->height > SSD1327_ROWS) {
+		dev_err(&spi->dev, "unsupported screen dimension\n");
+		return -ENODEV;
+	}
+
+	fb = framebuffer_alloc(sizeof (*priv), &spi->dev);
+	if (!fb)
+		return -ENOMEM;
+	priv = fb->par;
+	mutex_init(&priv->mutex);
+	priv->spi = spi;
+	priv->data = data;
+	priv->fb = fb;
+	priv->brightness = SSD1327_NOMINAL_BRIGHTNESS;
+	priv->wtd_max = data->watchdog;
+
+	/* setup framebuffer */
+	fb->fbops = &ssd1327_fb_ops;
+	fb->flags = FBINFO_FLAG_DEFAULT | FBINFO_HWACCEL_YPAN;
+	fb->var = ssd1327_fb_var;
+	fb->fix = ssd1327_fb_fix;
+
+	fb->var.xres = data->width;
+	fb->var.yres = data->height;
+	fb->var.xres_virtual = data->width;
+	fb->var.yres_virtual = data->height * 2;
+
+	/* twice lcd size so we can pan in one direction */
+	fb->fix.smem_len = (data->width * data->height) * 2;
+	fb->fix.line_length = data->width;
+	fb->var.rotate = data->rotate;
+
+	/* allocate video memory */
+	priv->vmem_size = PAGE_ALIGN(fb->fix.smem_len);
+	priv->vmem = vmalloc(priv->vmem_size);
+	if (!priv->vmem) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+	memset(priv->vmem, 0, priv->vmem_size);
+	fb->screen_base = (char __iomem *)priv->vmem;
+
+	ret = ssd1327_init(priv);
+	if (ret)
+		goto fail;
+
+	if (init_backlight(priv))
+		goto fail;
+
+	/* register frame buffer */
+	ret = register_framebuffer(fb);
+	if (ret < 0)
+		goto fail;
+
+	INIT_DELAYED_WORK(&priv->wtd_work, wtd_work_cb);
+
+	if (priv->wtd_max) {
+		atomic_set(&priv->wtd_count, priv->wtd_max);
+		schedule_delayed_work(&priv->wtd_work, HZ);
+	}
+
+	dev_info(&spi->dev,
+		 "fb%d: SSD1327 frame buffer device (%ux%u screen)\n",
+		 fb->node, data->width, data->height);
+
+	dev_set_drvdata(&spi->dev, priv);
+	return 0;
+
+fail:
+	if (priv->vmem)
+		vfree(priv->vmem);
+	if (priv->backlight)
+		backlight_device_unregister(priv->backlight);
+	framebuffer_release(fb);
+	return ret;
+}
+
+/*
+ * platform device remove callback
+ */
+static int __devexit ssd1327_remove(struct spi_device *spi)
+{
+	struct ssd1327 *priv;
+	unsigned int i;
+
+	priv = dev_get_drvdata(&spi->dev);
+	cancel_delayed_work_sync(&priv->wtd_work);
+	unregister_framebuffer(priv->fb);
+	for (i = 0; i < priv->vmem_size; i += PAGE_SIZE) {
+		struct page *page;
+		page = vmalloc_to_page(priv->vmem + i);
+		page->mapping = NULL;
+	}
+	vfree(priv->vmem);
+	backlight_device_unregister(priv->backlight);
+	framebuffer_release(priv->fb);
+	return 0;
+}
+
+static struct spi_driver ssd1327_driver = {
+	.driver = {
+		.name		= "ssd1327",
+		.owner		= THIS_MODULE,
+	},
+	.probe		= ssd1327_probe,
+	.remove		= __devexit_p(ssd1327_remove),
+};
+
+static int __init ssd1327_module_init(void)
+{
+	return spi_register_driver(&ssd1327_driver);
+}
+
+static void __exit ssd1327_module_exit(void)
+{
+	spi_unregister_driver(&ssd1327_driver);
+}
+
+module_init(ssd1327_module_init);
+module_exit(ssd1327_module_exit);
+
+MODULE_DESCRIPTION("SSD1327 driver");
+MODULE_AUTHOR("Maxime Bizon <mbizon@freebox.fr>");
+MODULE_LICENSE("GPL");
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/include/linux/crash_zone.h	2011-05-24 18:15:37.545795075 +0200
@@ -0,0 +1,16 @@
+#ifndef CRASH_ZONE_H
+#define CRASH_ZONE_H
+
+#define CRASH_MAGIC	0xa7cecd6a
+
+struct crash_header
+{
+	unsigned int magic;
+	unsigned int len;
+	unsigned short checksum;
+	unsigned char data;
+};
+
+void __init crash_zone_set_param(unsigned char *zone, unsigned int size);
+
+#endif /* ! CRASH_ZONE_H */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/include/linux/fbxatm_dev.h	2011-06-20 17:00:14.296084288 +0200
@@ -0,0 +1,434 @@
+#ifndef LINUX_FBXATM_DEV_H_
+#define LINUX_FBXATM_DEV_H_
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/err.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include <linux/skbuff.h>
+#include <linux/mutex.h>
+#include <linux/fbxatm.h>
+#include <linux/device.h>
+#include <asm/atomic.h>
+#include <linux/if_vlan.h>
+#include <linux/fbxatm_remote.h>
+
+/*
+ * atm cell helper
+ */
+#define ATM_CELL_HDR_SIZE	5
+
+#define ATM_GET_GFC(h)		(((h)[0] & 0xf0) >> 4)
+#define ATM_SET_GFC(h,v)	do {					\
+					(h)[0] &= ~0xf0;		\
+					(h)[0] |= (v) << 4;		\
+				} while (0)
+
+#define ATM_GET_VPI(h)		((((h)[0] & 0x0f) << 4) |		\
+				 (((h)[1] & 0xf0) >> 4))
+#define ATM_SET_VPI(h,v)	do {					\
+					(h)[0] &= ~0xf;			\
+					(h)[1] &= ~0xf0;		\
+					(h)[0] |= (v) >> 4;		\
+					(h)[1] |= ((v) & 0xf) << 4;	\
+				} while (0)
+
+#define ATM_GET_VCI(h)		((((h)[1] & 0x0f) << 12) |		\
+				 ((h)[2] << 4) |			\
+				 ((((h)[3] & 0xf0) >> 4)))
+#define ATM_SET_VCI(h,v)	do {					\
+					(h)[1] &= ~0xf;			\
+					(h)[3] &= ~0xf0;		\
+					(h)[1] |= (v) >> 12;		\
+					(h)[2] = ((v) & 0xff0) >> 4;	\
+					(h)[3] |= ((v) & 0xf) << 4;	\
+				} while (0)
+
+
+#define ATM_GET_PT(h)		(((h)[3] & 0x0e) >> 1)
+#define ATM_SET_PT(h,v)		do {					\
+					(h)[3] &= ~0xe;			\
+					(h)[3] |= (v) << 1;		\
+				} while (0)
+
+#define ATM_GET_CLP(h)		(((h)[3] & 0x01))
+#define ATM_SET_CLP(h,v)	do {					\
+					(h)[3] &= ~1;			\
+					(h)[3] |= (v);			\
+				} while (0)
+
+#define ATM_GET_HEC(h)		((h)[4])
+#define ATM_SET_HEC(h,v)	do {					\
+					(h)[4] = (v);			\
+				} while (0)
+
+
+/*
+ * OAM definition
+ */
+#define OAM_VCI_SEG_F4			3
+#define OAM_VCI_END2END_F4		4
+
+#define OAM_PTI_SEG_F5			0x4
+#define OAM_PTI_END2END_F5		0x5
+
+#define OAM_TYPE_SHIFT			4
+#define OAM_TYPE_MASK			(0xf << OAM_TYPE_SHIFT)
+#define OAM_TYPE_FAULT_MANAGEMENT	0x1
+#define OAM_TYPE_PERF_MANAGEMENT	0x2
+#define OAM_TYPE_ACTIVATION		0x8
+
+#define FUNC_TYPE_SHIFT			0
+#define FUNC_TYPE_MASK			(0xf << FUNC_TYPE_SHIFT)
+#define FUNC_TYPE_AIS			0x0
+#define FUNC_TYPE_FERF			0x1
+#define FUNC_TYPE_CONT_CHECK		0x4
+#define FUNC_TYPE_OAM_LOOPBACK		0x8
+
+struct fbxatm_oam_cell_payload {
+	u8			cell_hdr[5];
+	u8			cell_type;
+	u8			loopback_indication;
+	u8			correlation_tag[4];
+	u8			loopback_id[16];
+	u8			source_id[16];
+	u8			reserved[8];
+	u8			crc10[2];
+};
+
+struct fbxatm_oam_cell {
+	struct fbxatm_oam_cell_payload	payload;
+	struct list_head		next;
+};
+
+struct fbxatm_oam_ping {
+	struct fbxatm_oam_ping_req	req;
+	u32				correlation_id;
+	int				replied;
+	wait_queue_head_t		wq;
+	struct list_head		next;
+};
+
+/*
+ * vcc/device stats
+ */
+struct fbxatm_vcc_stats {
+	unsigned long			rx_bytes;
+	unsigned long			tx_bytes;
+	unsigned long			rx_aal5;
+	unsigned long			tx_aal5;
+};
+
+struct fbxatm_dev_stats {
+	unsigned long			rx_bytes;
+	unsigned long			tx_bytes;
+	unsigned long			rx_aal5;
+	unsigned long			tx_aal5;
+	unsigned long			rx_f4_oam;
+	unsigned long			tx_f4_oam;
+	unsigned long			rx_f5_oam;
+	unsigned long			tx_f5_oam;
+	unsigned long			rx_bad_oam;
+	unsigned long			rx_bad_llid_oam;
+	unsigned long			rx_other_oam;
+	unsigned long			rx_dropped;
+	unsigned long			tx_drop_nolink;
+};
+
+/*
+ * vcc user ops
+ */
+struct fbxatm_vcc_uops {
+	void	(*link_change)(void *cb_data, int link,
+			       unsigned int rx_cell_rate,
+			       unsigned int tx_cell_rate);
+	void	(*rx_pkt)(struct sk_buff *skb, void *cb_data);
+	void	(*tx_done)(void *cb_data);
+};
+
+/*
+ * vcc status flags
+ */
+enum {
+	FBXATM_VCC_F_FULL		= (1 << 0),
+
+	FBXATM_VCC_F_LINK_UP		= (1 << 1),
+};
+
+
+/*
+ * vcc definition
+ */
+struct fbxatm_dev;
+
+struct fbxatm_vcc {
+	unsigned int			vpi;
+	unsigned int			vci;
+
+	struct fbxatm_vcc_qos		qos;
+
+	struct fbxatm_vcc_stats		stats;
+
+	enum fbxatm_vcc_user		user;
+	void				*user_priv;
+
+	struct fbxatm_dev		*adev;
+	void				*dev_priv;
+
+	spinlock_t			user_ops_lock;
+	const struct fbxatm_vcc_uops	*user_ops;
+	void				*user_cb_data;
+
+	unsigned int			to_drop_pkt;
+
+	spinlock_t			tx_lock;
+	unsigned long			vcc_flags;
+
+	struct list_head		next;
+};
+
+/*
+ * fbxatm device operation
+ */
+struct fbxatm_dev_ops {
+	int (*open)(struct fbxatm_vcc *vcc);
+
+	void (*close)(struct fbxatm_vcc *vcc);
+
+	int (*ioctl)(struct fbxatm_dev *adev,
+		     unsigned int cmd, void __user *arg);
+
+	int (*send)(struct fbxatm_vcc *vcc, struct sk_buff *skb);
+
+	int (*send_oam)(struct fbxatm_dev *adev,
+			struct fbxatm_oam_cell *cell);
+
+	int (*init_procfs)(struct fbxatm_dev *adev);
+	void (*release_procfs)(struct fbxatm_dev *adev);
+
+	struct module			*owner;
+};
+
+/*
+ * device flags
+ */
+enum {
+	FBXATM_DEV_F_LINK_UP		= (1 << 0),
+};
+
+/*
+ * fbxatm device definition
+ */
+struct fbxatm_dev {
+	int				ifindex;
+	unsigned long			dev_flags;
+
+	unsigned int			max_vcc;
+	unsigned int			vci_mask;
+	unsigned int			vpi_mask;
+	unsigned int			max_priority;
+	unsigned int			max_rx_priority;
+	unsigned int			tx_headroom;
+
+	char				*name;
+
+	/* unit: b/s */
+	unsigned int			link_rate_ds;
+	unsigned int			link_rate_us;
+
+	unsigned int			link_cell_rate_ds;
+	unsigned int			link_cell_rate_us;
+
+	const struct fbxatm_dev_ops	*ops;
+
+	spinlock_t			stats_lock;
+	struct fbxatm_dev_stats		stats;
+
+	struct list_head		vcc_list;
+
+	struct device			dev;
+
+	spinlock_t			oam_lock;
+	struct list_head		rx_oam_cells;
+	unsigned int			rx_oam_cells_count;
+	struct work_struct		oam_work;
+
+	struct list_head		oam_pending_ping;
+	u32				oam_correlation_id;
+
+	struct proc_dir_entry		*dev_proc_entry;
+	void				*priv;
+	struct list_head		next;
+};
+
+/*
+ * API for device drivers
+ */
+struct fbxatm_dev *fbxatm_alloc_device(int sizeof_priv);
+
+int fbxatm_register_device(struct fbxatm_dev *adev,
+			   const char *base_name,
+			   const struct fbxatm_dev_ops *ops);
+
+void fbxatm_free_device(struct fbxatm_dev *adev);
+
+void fbxatm_dev_set_link_up(struct fbxatm_dev *adev);
+
+void fbxatm_dev_set_link_down(struct fbxatm_dev *adev);
+
+int fbxatm_unregister_device(struct fbxatm_dev *adev);
+
+void fbxatm_netifrx_oam(struct fbxatm_dev *adev,
+			struct fbxatm_oam_cell *cell);
+
+
+static inline int fbxatm_vcc_link_is_up(struct fbxatm_vcc *vcc)
+{
+	return test_bit(FBXATM_VCC_F_LINK_UP, &vcc->vcc_flags);
+}
+
+#define	FBXATMDEV_ALIGN		4
+
+static inline void *fbxatm_dev_priv(struct fbxatm_dev *adev)
+{
+	return (u8 *)adev + ((sizeof(struct fbxatm_dev)
+			      + (FBXATMDEV_ALIGN - 1))
+			     & ~(FBXATMDEV_ALIGN - 1));
+}
+
+/*
+ * API for FBXATM stack user
+ */
+struct fbxatm_ioctl {
+	int (*handler)(struct socket *sock,
+		       unsigned int cmd, void __user *useraddr);
+
+	void (*release)(struct socket *sock);
+
+	struct module		*owner;
+	struct list_head	next;
+};
+
+void fbxatm_set_uops(struct fbxatm_vcc *vcc,
+		     const struct fbxatm_vcc_uops *user_ops,
+		     void *user_cb_data);
+
+struct fbxatm_vcc *
+fbxatm_bind_to_vcc(const struct fbxatm_vcc_id *id,
+		   enum fbxatm_vcc_user user);
+
+void fbxatm_unbind_vcc(struct fbxatm_vcc *vcc);
+
+
+static inline int fbxatm_vcc_queue_full(struct fbxatm_vcc *vcc)
+{
+	return test_bit(FBXATM_VCC_F_FULL, &vcc->vcc_flags);
+}
+
+#ifdef CONFIG_FBXATM_STACK
+/*
+ * stack user callback to send data on given vcc
+ */
+static inline int fbxatm_send(struct fbxatm_vcc *vcc, struct sk_buff *skb)
+{
+	int ret;
+	unsigned int len;
+
+	len = skb->len;
+
+	spin_lock_bh(&vcc->tx_lock);
+	if (!test_bit(FBXATM_VCC_F_LINK_UP, &vcc->vcc_flags)) {
+		spin_unlock_bh(&vcc->tx_lock);
+		dev_kfree_skb(skb);
+		spin_lock(&vcc->adev->stats_lock);
+		vcc->adev->stats.tx_drop_nolink++;
+		spin_unlock(&vcc->adev->stats_lock);
+		return 0;
+	}
+
+	ret = vcc->adev->ops->send(vcc, skb);
+	if (!ret) {
+		vcc->stats.tx_bytes += len;
+		vcc->stats.tx_aal5++;
+	}
+	spin_unlock_bh(&vcc->tx_lock);
+
+	if (!ret) {
+		spin_lock_bh(&vcc->adev->stats_lock);
+		vcc->adev->stats.tx_bytes += len;
+		vcc->adev->stats.tx_aal5++;
+		spin_unlock_bh(&vcc->adev->stats_lock);
+	}
+	return ret;
+}
+
+/*
+ * device callback when packet comes in
+ */
+static inline void fbxatm_netifrx(struct fbxatm_vcc *vcc, struct sk_buff *skb)
+{
+	unsigned int len;
+
+	len = skb->len;
+
+	spin_lock_bh(&vcc->user_ops_lock);
+	if (!vcc->user_ops) {
+		spin_unlock_bh(&vcc->user_ops_lock);
+		dev_kfree_skb(skb);
+		return;
+	}
+
+	if (vcc->to_drop_pkt) {
+		vcc->to_drop_pkt--;
+		spin_unlock_bh(&vcc->user_ops_lock);
+		dev_kfree_skb(skb);
+		return;
+	}
+
+	vcc->stats.rx_bytes += len;
+	vcc->stats.rx_aal5++;
+
+	vcc->user_ops->rx_pkt(skb, vcc->user_cb_data);
+	spin_unlock_bh(&vcc->user_ops_lock);
+
+	spin_lock_bh(&vcc->adev->stats_lock);
+	vcc->adev->stats.rx_bytes += len;
+	vcc->adev->stats.rx_aal5++;
+	spin_unlock_bh(&vcc->adev->stats_lock);
+}
+
+/*
+ * device callback when tx is done on vcc
+ */
+static inline void fbxatm_tx_done(struct fbxatm_vcc *vcc)
+{
+	spin_lock_bh(&vcc->user_ops_lock);
+	if (vcc->user_ops)
+		vcc->user_ops->tx_done(vcc->user_cb_data);
+	spin_unlock_bh(&vcc->user_ops_lock);
+}
+#else
+int fbxatm_send(struct fbxatm_vcc *vcc, struct sk_buff *skb);
+void fbxatm_netifrx(struct fbxatm_vcc *vcc, struct sk_buff *skb);
+void fbxatm_tx_done(struct fbxatm_vcc *vcc);
+#endif
+
+static inline unsigned int fbxatm_rx_reserve(void)
+{
+#ifdef CONFIG_FBXATM_STACK
+	/* normal stack, no headroom needed */
+	return 0;
+#else
+	/* remote stub, we need to send rx skb to another location,
+	 * adding the fbxatm_remote header, an ethernet header (with
+	 * possible vlan) */
+	return ALIGN(sizeof (struct fbxatm_remote_hdr) + VLAN_ETH_HLEN, 4);
+#endif
+}
+
+void fbxatm_register_ioctl(struct fbxatm_ioctl *ioctl);
+
+void fbxatm_unregister_ioctl(struct fbxatm_ioctl *ioctl);
+
+#endif /* !LINUX_FBXATM_DEV_H_ */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/include/linux/fbxatm.h	2011-05-24 18:15:37.555795034 +0200
@@ -0,0 +1,155 @@
+/*
+ * Generic fbxatm definition, exported to userspace
+ */
+#ifndef LINUX_FBXATM_H_
+#define LINUX_FBXATM_H_
+
+#include <linux/types.h>
+#include <linux/if.h>
+
+#define FBXATM_IOCTL_MAGIC		0xd3
+
+/* allow userspace usage without up to date kernel headers */
+#ifndef PF_FBXATM
+#define PF_FBXATM			32
+#define AF_FBXATM			PF_FBXATM
+#endif
+
+struct fbxatm_vcc_id {
+	int				dev_idx;
+	__u32				vpi;
+	__u32				vci;
+};
+
+enum fbxatm_vcc_user {
+	FBXATM_VCC_USER_NONE = 0,
+	FBXATM_VCC_USER_2684,
+	FBXATM_VCC_USER_PPPOA,
+};
+
+enum fbxatm_vcc_traffic_class {
+	FBXATM_VCC_TC_UBR_NO_PCR = 0,
+	FBXATM_VCC_TC_UBR,
+};
+
+struct fbxatm_vcc_qos {
+	__u32				traffic_class;
+	__u32				max_sdu;
+	__u32				max_buffered_pkt;
+	__u32				priority;
+	__u32				rx_priority;
+};
+
+
+/*
+ * VCC related
+ */
+struct fbxatm_vcc_params {
+	/* ADD/DEL/GET */
+	struct fbxatm_vcc_id		id;
+
+	/* ADD/GET */
+	struct fbxatm_vcc_qos		qos;
+
+	/* GET */
+	enum fbxatm_vcc_user		user;
+};
+
+#define FBXATM_IOCADD		_IOW(FBXATM_IOCTL_MAGIC,	1,	\
+					struct fbxatm_vcc_params)
+
+#define FBXATM_IOCDEL		_IOR(FBXATM_IOCTL_MAGIC,	2,	\
+					struct fbxatm_vcc_params)
+
+#define FBXATM_IOCGET		_IOWR(FBXATM_IOCTL_MAGIC,	3,	\
+					struct fbxatm_vcc_params)
+
+
+struct fbxatm_vcc_drop_params {
+	struct fbxatm_vcc_id		id;
+	unsigned int			drop_count;
+};
+
+#define FBXATM_IOCDROP		_IOWR(FBXATM_IOCTL_MAGIC,	5,	\
+					struct fbxatm_vcc_drop_params)
+
+/*
+ * OAM related
+ */
+enum fbxatm_oam_ping_type {
+	FBXATM_OAM_PING_SEG_F4	= 0,
+	FBXATM_OAM_PING_SEG_F5,
+	FBXATM_OAM_PING_E2E_F4,
+	FBXATM_OAM_PING_E2E_F5,
+};
+
+struct fbxatm_oam_ping_req {
+	/* only dev_idx for F4 */
+	struct fbxatm_vcc_id		id;
+
+	__u8				llid[16];
+	enum fbxatm_oam_ping_type	type;
+};
+
+#define FBXATM_IOCOAMPING	_IOWR(FBXATM_IOCTL_MAGIC,	10,	\
+				      struct fbxatm_oam_ping_req)
+
+
+/*
+ * PPPOA related
+ */
+enum fbxatm_pppoa_encap {
+	FBXATM_EPPPOA_AUTODETECT = 0,
+	FBXATM_EPPPOA_VCMUX,
+	FBXATM_EPPPOA_LLC,
+};
+
+struct fbxatm_pppoa_vcc_params {
+	struct fbxatm_vcc_id		id;
+	__u32				encap;
+	__u32				cur_encap;
+};
+
+#define FBXATM_PPPOA_IOCADD	_IOW(FBXATM_IOCTL_MAGIC,	20,	\
+					struct fbxatm_pppoa_vcc_params)
+
+#define FBXATM_PPPOA_IOCDEL	_IOW(FBXATM_IOCTL_MAGIC,	21,	\
+					struct fbxatm_pppoa_vcc_params)
+
+#define FBXATM_PPPOA_IOCGET	_IOWR(FBXATM_IOCTL_MAGIC,	22,	\
+					struct fbxatm_pppoa_vcc_params)
+
+
+
+/*
+ * 2684 related
+ */
+enum fbxatm_2684_encap {
+	FBXATM_E2684_VCMUX = 0,
+	FBXATM_E2684_LLC,
+};
+
+enum fbxatm_2684_payload {
+	FBXATM_P2684_BRIDGE = 0,
+	FBXATM_P2684_ROUTED,
+};
+
+struct fbxatm_2684_vcc_params {
+	struct fbxatm_vcc_id		id;
+
+	__u32				encap;
+	__u32				payload;
+	char				dev_name[IFNAMSIZ];
+};
+
+
+#define FBXATM_2684_IOCADD	_IOW(FBXATM_IOCTL_MAGIC,	30,	\
+					struct fbxatm_2684_vcc_params)
+
+#define FBXATM_2684_IOCDEL	_IOW(FBXATM_IOCTL_MAGIC,	31,	\
+					struct fbxatm_2684_vcc_params)
+
+#define FBXATM_2684_IOCGET	_IOWR(FBXATM_IOCTL_MAGIC,	32,	\
+					struct fbxatm_2684_vcc_params)
+
+#endif /* LINUX_FBXATM_H_ */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/include/linux/fbxatm_remote.h	2011-05-24 18:15:37.555795034 +0200
@@ -0,0 +1,216 @@
+#ifndef FBXATM_REMOTE_H_
+#define FBXATM_REMOTE_H_
+
+#include <linux/types.h>
+#include <linux/if_ether.h>
+#include <linux/netdevice.h>
+
+/*
+ * fbxatm remote protocol messages
+ */
+#define ETH_P_FBXATM_REMOTE	0x8844
+#define FBXATM_REMOTE_MAGIC	0xd76f8d2f
+
+enum fbxatm_remote_flags {
+	FBXATM_RFLAGS_ACK = (1 << 0),
+};
+
+enum fbxatm_remote_mtype {
+	/* driver => stub */
+	FBXATM_RMT_CONNECT = 0,
+
+	/* stub => driver */
+	FBXATM_RMT_DEV_LINK,
+	FBXATM_RMT_DEV_RX_OAM,
+
+	/* driver => stub */
+	FBXATM_RMT_KEEPALIVE,
+	FBXATM_RMT_DEV_SEND_OAM,
+	FBXATM_RMT_VCC_ACTION,
+
+	/* driver => stub */
+	FBXATM_RMT_VCC_SEND,
+
+	/* stub => driver */
+	FBXATM_RMT_VCC_QEMPTY,
+	FBXATM_RMT_VCC_RX,
+};
+
+struct fbxatm_remote_hdr {
+	u32	magic;
+	u8	flags;
+	u8	seq;
+	u16	len;
+	u16	sport;
+	u16	dport;
+
+	u32	session_id;
+	u32	mtype;
+};
+
+/*
+ * sent to destination port 0
+ */
+struct fbxatm_remote_connect {
+	u8	name[32];
+
+	u16	dev_link_port;
+	u16	dev_rx_oam_port;
+};
+
+struct fbxatm_remote_connect_ack {
+	u16	vcc_action_port;
+	u16	dev_send_oam_port;
+	u16	keepalive_port;
+	u16	pad;
+
+	u32	max_vcc;
+	u32	vci_mask;
+	u32	vpi_mask;
+	u32	max_priority;
+	u32	max_rx_priority;
+
+	u32	link;
+	u32	link_rate_ds;
+	u32	link_rate_us;
+	u32	link_cell_rate_ds;
+	u32	link_cell_rate_us;
+};
+
+/*
+ * sent on dev_link port
+ */
+struct fbxatm_remote_dev_link {
+	u32	link;
+	u32	link_rate_ds;
+	u32	link_rate_us;
+	u32	link_cell_rate_ds;
+	u32	link_cell_rate_us;
+};
+
+/*
+ * sent on vcc_action port
+ */
+struct fbxatm_remote_vcc_action {
+	/* 1: open - 0: close */
+	u32	action;
+
+	/*
+	 * open args
+	 */
+	u16	vcc_rx_port;
+	u16	vcc_qempty_port;
+
+	/* from vcc id struct */
+	u32	vpi;
+	u32	vci;
+
+	/* from qos struct */
+	u32	traffic_class;
+	u32	max_sdu;
+	u32	max_buffered_pkt;
+	u32	priority;
+	u32	rx_priority;
+
+	/*
+	 * close args
+	 */
+	u32	vcc_remote_id;
+};
+
+struct fbxatm_remote_vcc_action_ack {
+	u32	ret;
+
+	/* open args ack */
+	u32	vcc_remote_id;
+	u16	vcc_send_port;
+	u16	pad;
+};
+
+/*
+ * sent on vcc_send port
+ */
+struct fbxatm_remote_vcc_send_ack {
+	u32	full;
+};
+
+/*
+ * pseudo socket layer
+ */
+struct fbxatm_remote_sock;
+struct fbxatm_remote_ctx;
+
+struct fbxatm_remote_sockaddr {
+	u16		lport;
+	u16		dport;
+	u32		mtype;
+	int		infinite_retry;
+	int		(*deliver)(void *priv, struct sk_buff *skb,
+				   struct sk_buff **ack);
+	void		(*response)(void *priv, struct sk_buff *skb);
+	void		*priv;
+};
+
+struct sk_buff *fbxatm_remote_alloc_skb(struct fbxatm_remote_ctx *ctx,
+					unsigned int size);
+
+unsigned int fbxatm_remote_headroom(struct fbxatm_remote_ctx *ctx);
+
+void fbxatm_remote_sock_getaddr(struct fbxatm_remote_sock *sock,
+				struct fbxatm_remote_sockaddr *addr);
+
+void fbxatm_remote_sock_purge(struct fbxatm_remote_sock *sock);
+
+int fbxatm_remote_sock_pending(struct fbxatm_remote_sock *sock);
+
+struct fbxatm_remote_ctx *fbxatm_remote_alloc_ctx(struct net_device *netdev,
+						  u8 *remote_mac,
+						  u32 session_id,
+						  void (*timeout)(void *priv),
+						  void *priv);
+
+struct fbxatm_remote_sock *
+fbxatm_remote_sock_bind(struct fbxatm_remote_ctx *ctx,
+			struct fbxatm_remote_sockaddr *addr,
+			int send_ack);
+
+struct fbxatm_remote_sock *
+fbxatm_remote_sock_connect(struct fbxatm_remote_ctx *ctx,
+			   struct fbxatm_remote_sockaddr *addr,
+			   int need_ack);
+
+int fbxatm_remote_sock_send(struct fbxatm_remote_sock *sock,
+			    struct sk_buff *skb);
+
+int fbxatm_remote_sock_send_ack(struct fbxatm_remote_sock *sock,
+				struct sk_buff *skb);
+
+int fbxatm_remote_sock_send_raw_ack(struct fbxatm_remote_ctx *ctx,
+				    struct net_device *dev,
+				    u8 *remote_mac,
+				    struct fbxatm_remote_hdr *hdr,
+				    struct sk_buff *ack);
+
+void fbxatm_remote_sock_close(struct fbxatm_remote_sock *sock);
+
+void fbxatm_remote_set_unknown_cb(void (*cb)(struct net_device *,
+					     struct sk_buff *));
+
+void fbxatm_remote_free_ctx(struct fbxatm_remote_ctx *ctx);
+
+void fbxatm_remote_ctx_set_dead(struct fbxatm_remote_ctx *ctx);
+
+int fbxatm_remote_init(void);
+
+void fbxatm_remote_exit(void);
+
+/*
+ * platform data for fbxatm_remote driver
+ */
+struct fbxatm_remote_pdata {
+	u8	remote_mac[ETH_ALEN];
+	char	netdev_name[IFNAMSIZ];
+	char	remote_name[32];
+};
+
+#endif /* !FBXATM_REMOTE_H_ */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/include/linux/fbxgpio_core.h	2011-05-24 18:15:37.565794993 +0200
@@ -0,0 +1,39 @@
+/*
+ * fbxgpio.h for linux-freebox
+ * Created by <nschichan@freebox.fr> on Wed Feb 21 22:09:46 2007
+ * Freebox SA
+ */
+
+#ifndef FBXGPIO_H
+# define FBXGPIO_H
+
+# include <linux/types.h>
+
+/* can change pin direction */
+#define FBXGPIO_PIN_DIR_RW	(1 << 0)
+#define FBXGPIO_PIN_REVERSE_POL	(1 << 1)
+
+struct fbxgpio_operations {
+	int  (*get_datain)(int gpio);
+	void (*set_dataout)(int gpio, int val);
+	int  (*get_dataout)(int gpio);
+	void (*set_direction)(int gpio, int dir);
+	int  (*get_direction)(int gpio);
+};
+
+
+struct fbxgpio_pin {
+	const struct fbxgpio_operations	*ops;
+	const char			*pin_name;
+	uint32_t			flags;
+	int				direction;
+	int				pin_num;
+	unsigned int			cur_dataout;
+	struct device			*dev;
+};
+
+
+#define GPIO_DIR_IN	0x1
+#define GPIO_DIR_OUT	0x0
+
+#endif /* !FBXGPIO_H */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/include/linux/fbxmtd_map_ioctl.h	2011-05-24 18:15:37.565794993 +0200
@@ -0,0 +1,52 @@
+/*
+ * fbxmtd_map_ioctl.h for linux-freebox
+ * Created by <nschichan@freebox.fr> on Thu Feb  8 20:37:28 2007
+ * Freebox SA
+ */
+
+#ifndef FBXMTD_MAP_IOCTL_H
+# define FBXMTD_MAP_IOCTL_H
+
+/*
+ * IOCTL interface
+ */
+#define FBXMTD_MINOR	242
+
+#define FBXMTD_MAP_IOCTL_MAX_DEV	2
+#define FBXMTD_MAP_IOCTL_MAX_PART	16
+
+struct fbxmtd_map_ioctl_part
+{
+	char		name[32];
+	uint32_t	offset;
+	uint32_t	size;
+	uint32_t	flags;
+};
+
+struct fbxmtd_map_ioctl_dev
+{
+	char				name[32];
+	uint32_t			base_phys;
+	int				bus_width;
+	uint32_t			size;
+	uint32_t			status;
+	struct fbxmtd_map_ioctl_part	parts[FBXMTD_MAP_IOCTL_MAX_PART];
+	int				num_parts;
+};
+
+#define FBXMTD_MAP_IOCTL_NR	0x42
+
+struct fbxmtd_map_ioctl_query
+{
+	uint32_t	cmd;
+	uint32_t	param;
+	int		result;
+	void __user	*user_buf;
+	uint32_t	user_buf_size;
+};
+
+#define FBXMTDCTL_CMD_GET_DEVICES	0x1
+#define FBXMTDCTL_CMD_ADD_DEVICE	0x2
+#define FBXMTDCTL_CMD_DEL_DEVICE	0x3
+
+#endif /* !FBXMTD_MAP_IOCTL_H */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/include/linux/fbxprocfs.h	2011-05-24 18:15:37.565794993 +0200
@@ -0,0 +1,45 @@
+#ifndef FBXPROCFS_H_
+#define FBXPROCFS_H_
+
+#include <linux/proc_fs.h>
+#include <asm/atomic.h>
+
+struct fbxprocfs_client
+{
+	const char *dirname;
+	struct module *owner;
+	struct proc_dir_entry *dir;
+	atomic_t refcount;
+	struct list_head list;
+};
+
+struct fbxprocfs_ro_desc {
+	char		*name;
+	unsigned long	id;
+	int	(*rfunc)(char *, char **, off_t, int, int *, void *);
+};
+
+struct fbxprocfs_rw_desc {
+	char		*name;
+	unsigned long	id;
+	int	(*rfunc)(char *, char **, off_t, int, int *, void *);
+	int	(*wfunc)(struct file *, const char *, unsigned long, void *);
+};
+
+struct fbxprocfs_client *fbxprocfs_add_client(const char *dirname,
+					      struct module *owner);
+
+int fbxprocfs_remove_client(struct fbxprocfs_client *client);
+
+
+int
+fbxprocfs_create_entries(struct fbxprocfs_client *client,
+			 const struct fbxprocfs_ro_desc *ro_desc,
+			 const struct fbxprocfs_rw_desc *rw_desc);
+
+int
+fbxprocfs_remove_entries(struct fbxprocfs_client *client,
+			 const struct fbxprocfs_ro_desc *ro_desc,
+			 const struct fbxprocfs_rw_desc *rw_desc);
+
+#endif /* FBXPROCFS_H_ */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/include/linux/fbxserial.h	2011-09-09 16:11:25.390446439 +0200
@@ -0,0 +1,122 @@
+#ifndef FBXSERIAL_H_
+#define FBXSERIAL_H_
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+/*
+ * some part of serial may vary, we use abstract struct to store this,
+ * data content depends on type.
+ */
+#define EXTINFO_SIZE		128
+#define EXTINFO_MAX_COUNT	16
+
+/*
+ * extdev desc
+ */
+#define EXTINFO_TYPE_EXTDEV	1
+
+#define EXTDEV_TYPE_BUNDLE	1
+#define EXTDEV_TYPE_MAX		2
+
+struct fbx_serial_extinfo {
+	u32			type;
+
+	union {
+		/* extdev */
+		struct {
+			u32	type;
+			u32	model;
+			char	serial[64];
+		} extdev;
+
+		/* raw access */
+		unsigned char	data[EXTINFO_SIZE];
+	} u;
+}  __attribute__ ((packed));;
+
+
+/*
+ * master serial structure
+ */
+
+#define FBXSERIAL_VERSION	1
+
+#define FBXSERIAL_MAGIC		0x2d9521ab
+
+#define MAC_ADDR_SIZE		6
+#define RANDOM_DATA_SIZE	32
+
+/*
+ * this  is the  maximum size  we accept  to check  crc32  against, so
+ * structure may no grow larger than this
+ */
+#define FBXSERIAL_MAX_SIZE	8192
+
+struct fbx_serial {
+	u32	crc32;
+	u32	magic;
+	u32	struct_version;
+	u32	len;
+
+	/* board serial */
+	u16	type;
+	u8	version;
+	u8	manufacturer;
+	u16	year;
+	u8	week;
+	u32	number;
+	u32	flags;
+
+	/* mac address base */
+	u8	mac_addr_base[MAC_ADDR_SIZE];
+
+	/* mac address count */
+	u8	mac_count;
+
+	/* random data */
+	u8	random_data[RANDOM_DATA_SIZE];
+
+	/* last update of data (seconds since epoch) */
+	u32	last_modified;
+
+	/* count of following extinfo tag */
+	u32	extinfo_count;
+
+	/* beginning of extended info */
+	struct fbx_serial_extinfo	extinfos[EXTINFO_MAX_COUNT];
+
+} __attribute__ ((packed));
+
+
+/*
+ * default value to use in case magic is wrong (no cksum in that case)
+ */
+static inline void fbxserial_set_default(struct fbx_serial *s)
+{
+	memset(s, 0, sizeof (*s));
+	s->magic = FBXSERIAL_MAGIC;
+	s->struct_version = FBXSERIAL_VERSION;
+	s->len = sizeof (*s);
+	s->manufacturer = '_';
+	memcpy(s->mac_addr_base, "\x00\x07\xCB\x00\x00\xFD", 6);
+	s->mac_count = 1;
+}
+
+void
+fbxserialinfo_get_random(unsigned char *data, unsigned int len);
+
+void
+fbxserialinfo_get_mac_addr(unsigned char *data);
+
+int
+fbxserialinfo_read(void *data, struct fbx_serial *out);
+
+struct fbx_serial *fbxserialinfo_get(void);
+
+/*
+ * implemented in board specific code
+ */
+const struct fbx_serial *arch_get_fbxserial(void);
+
+#endif /* FBXSERIAL_H_ */
diff -Nruw linux-2.6.39.4-fbx/include/linux/remoti./Kbuild linux-2.6.39.4-fbx/include/linux/remoti/Kbuild
--- linux-2.6.39.4-fbx/include/linux/remoti./Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/include/linux/remoti/Kbuild	2011-07-19 15:41:05.604933495 +0200
@@ -0,0 +1,2 @@
+header-y	+= remoti.h remoti-netlink.h remoti-input-oad.h \
+		   remoti-input-fbx.h remoti-input.h
diff -Nruw linux-2.6.39.4-fbx/include/linux/remoti./remoti.h linux-2.6.39.4-fbx/include/linux/remoti/remoti.h
--- linux-2.6.39.4-fbx/include/linux/remoti./remoti.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/include/linux/remoti/remoti.h	2011-08-30 20:03:22.326572233 +0200
@@ -0,0 +1,466 @@
+#ifndef __REMOTI_H
+#define __REMOTI_H
+
+#include <linux/types.h>
+#ifdef __KERNEL__
+#include <linux/spinlock.h>
+#include <linux/input.h>
+#include <linux/sysfs.h>
+#include <linux/platform_device.h>
+#include <linux/completion.h>
+#include <linux/firmware.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+
+#include <linux/remoti/remoti-transport.h>
+#include <linux/remoti/remoti-input.h>
+#endif
+
+enum rnp_states {
+	RNP_STATE_UNSPEC,
+	RNP_STATE_READY,
+	RNP_STATE_FW_DOWNLOADING,
+	RNP_STATE_FW_FAILED,
+	RNP_STATE_PAIRING_FAILED,
+	RNP_STATE_MAX,
+};
+
+/*
+ * RTI definitions
+ */
+#define NPI_SYS_RES0		0
+#define NPI_SYS_SYS		1
+#define NPI_SYS_MAC		2
+#define NPI_SYS_NWK		3
+#define NPI_SYS_AF		4
+#define NPI_SYS_ZDO		5
+#define NPI_SYS_SAPI		6
+#define NPI_SYS_UTIL		7
+#define NPI_SYS_DBG		8
+#define NPI_SYS_APP		9
+#define NPI_SYS_RCAF		10
+#define NPI_SYS_RCN		11
+#define NPI_SYS_RCN_CLI		12
+#define NPI_SYS_BOOT		13
+#define NPI_SYS_MAX		14
+#define NPI_SYS_MASK		0x1F
+
+#define NPI_MAX_FRAME_LEN	128
+#define NPI_MAX_MSG_LEN		123
+
+#define NPI_POLL		0
+#define NPI_SREQ		1
+#define NPI_AREQ		2
+#define NPI_SRSP		3
+#define NPI_TYPE_MASK		3
+#define NPI_TYPE_SHIFT		5
+
+/*
+ * RCAF RPCs
+ */
+#define RTI_READ_ITEM		0x01
+#define RTI_WRITE_ITEM		0x02
+
+#define RTI_INIT_CNF		0x01
+#define RTI_INIT_REQ		0x03
+
+#define RTI_PAIR_CNF		0x02
+#define RTI_PAIR_REQ		0x04
+
+#define RTI_ALLOW_PAIR_CNF	0x04
+#define RTI_ALLOW_PAIR_REQ	0x06
+
+#define RTI_STANDBY_REQ		0x07
+#define RTI_STANDBY_CNF		0x06
+
+#define RTI_RECEIVE_DATA_CNF	0x03
+#define RTI_RECEIVE_DATA_IND	0x05
+
+#define RTI_ENABLE_SLEEP_REQ	0x09
+#define RTI_ENABLE_SLEEP_CNF	0x08
+
+#define RTI_DISABLE_SLEEP_REQ	0x0A
+#define RTI_DISABLE_SLEEP_CNF	0x09
+
+#define RTI_UNPAIR_REQ		0x0B
+#define RTI_UNPAIR_CNF		0x0A
+
+#define RTI_ALLOW_PAIR_ABRT_REQ	0x0D
+
+#define RTI_SB_RELOAD		0x10
+
+/* Test-mode only */
+#define RTI_RESET_REQ		0x13
+#define RTI_TEST_MODE_REQ	0x11
+#define RTI_TEST_RX_CNT_REQ	0x12
+
+#define RTI_CLEAR_TABLE_REQ	0x19
+#define RTI_CLEAR_TABLE_CNF	0x18
+
+#define RTI_ASSERT_DUMP_REQ	0x1B
+#define RTI_ASSERT_DUMP_CNF	0x1A
+
+/*
+ * Serial bootloader RPCs
+ */
+#define RTI_SB_HSK_REQ		0x04
+#define RTI_SB_WRITE_REQ	0x01
+#define RTI_SB_READ_REQ		0x02
+#define RTI_SB_ENABLE_REQ	0x03
+
+#define RTI_SB_FLASH_WORD	4
+
+/*
+ * Items
+ */
+#define RTI_ITEM_STARTUP_OPTS	0xA0
+#define RTI_ITEM_NODE_CAPS	0xA1
+#define RTI_ITEM_SUP_TGT_TYPES	0xA2
+#define RTI_ITEM_APP_CAPS	0xA3
+#define RTI_ITEM_DEV_TYPE_LIST	0xA4
+#define RTI_ITEM_PROF_ID_LIST	0xA5
+#define RTI_ITEM_DEF_STANDBY	0xA6
+#define RTI_ITEM_DEF_DUTY_CYCLE	0xA7
+#define RTI_ITEM_VENDOR_ID	0xA8
+#define RTI_ITEM_VENDOR_NAME	0xA9
+#define RTI_ITEM_DISC_DURATION	0xAA
+#define RTI_ITEM_DEF_LQI_THRES	0xAB
+
+#define RTI_ITEM_STAND_ACT_PER	0x60
+#define RTI_ITEM_CURR_CHANNEL	0x61
+#define RTI_ITEM_DISC_LQI_THRES	0x62
+#define RTI_ITEM_DUTY_CYCLE	0x64
+#define RTI_ITEM_FRAME_CNT	0x65
+#define RTI_ITEM_IN_POWERSAVE	0x67
+#define RTI_ITEM_MAX_CSMA_BACK	0x6A
+#define RTI_ITEM_MAX_FRAME_RET	0x6B
+#define RTI_ITEM_RESP_WAIT_TIME	0x6D
+#define RTI_ITEM_SCAN_DURATION	0x6E
+#define RTI_ITEM_USER_STRING	0x6F
+
+#define RTI_ITEM_IEEE_ADDR	0x84
+#define RTI_ITEM_PAN_ID		0x85
+#define RTI_ITEM_SHORT_ADDR	0x86
+#define RTI_ITEM_AGILITY_EN	0x87
+#define RTI_ITEM_TX_PWR		0x88
+
+#define RTI_ITEM_NUM_ACT_PT	0xB0
+#define RTI_ITEM_CURR_PT_INDEX	0xB1
+#define RTI_ITEM_CURR_PT_ENTRY	0xB2
+
+#define RTI_ITEM_SW_VER		0xC0
+#define RTI_ITEM_MAX_PT_ENTRIES	0xC1
+#define RTI_ITEM_PROTO_ID	0xC2
+#define RTI_ITEM_PROTO_VER	0xC3
+#define RTI_ITEM_FW_VER		0xC4
+
+#define RTI_ITEM_MIN		(RTI_ITEM_STAND_ACT_PER)
+#define RTI_ITEM_MAX		(RTI_ITEM_FW_VER)
+
+
+/* common error codes (see RemoTI API) */
+#define RTI_SUCCESS		0x00
+#define RTI_ERR_INV_INDEX	0xF9
+#define RTI_ERR_INV_PARAM	0xE8
+#define RTI_ERR_UNSUP_ATTR	0xF4
+#define RTI_ERR_NOT_PERM	0xB4
+#define RTI_ERR_NO_ORG_CAP	0xB0
+#define RTI_ERR_NO_REC_CAP	0xB1
+#define RTI_ERR_NO_RESP		0xB3
+#define RTI_ERR_OOM		0xBE
+#define RTI_ERR_PAIR_TIMEO	0x23
+#define RTI_ERR_UNK_STATUS	0x20
+#define RTI_ERR_OSAL_NO_TIMER	0x08
+#define RTI_ERR_OSAL_NV_FAILED	0x0A
+#define RTI_ERR_OSAL_NV_UNINIT	0x09
+#define RTI_ERR_OSAL_NV_BAD	0x0C
+#define RTI_ERR_MAC_EXP		0xF0
+#define RTI_ERR_MAC_OVF		0xF1
+#define RTI_ERR_MAC_NO_RES	0x1A
+#define RTI_ERR_MAC_BAD_STATE	0x19
+#define RTI_ERR_MAC_CHAN_ACC	0xE1
+#define RTI_ERR_MAC_NO_ACK	0xE9
+#define RTI_ERR_MAC_BCN		0xE0
+#define RTI_ERR_MAC_PAN_ID	0xEE
+#define RTI_ERR_MAC_SCAN	0xFC
+#define RTI_ERR_FAIL_DISC	0x21
+#define RTI_ERR_FAIL_PAIR	0x22
+#define RTI_ERR_NO_PAIR_IDX	0xB2
+#define RTI_ERR_PAIR_COMP	0x24
+#define RTI_ERR_SYNC_TIMEO	0xFF
+
+/*
+ * Vendor identifiers
+ */
+#define RTI_VENDOR_PANASONIC		0x0001
+#define RTI_VENDOR_SONY			0x0002
+#define RTI_VENDOR_SAMSUNG		0x0003
+#define RTI_VENDOR_PHILIPS		0x0004
+#define RTI_VENDOR_FREESCALE		0x0005
+#define RTI_VENDOR_OKI			0x0006
+#define RTI_VENDOR_TEXAS_INSTRUMENTS	0x0007
+#define RTI_VENDOR_FREEBOX		0x10A5
+
+#define RTI_SEC_KEY_LEN			16
+#define RTI_MAX_NUM_DEV_TYPES		3
+
+/* Per-device pairing entry */
+struct rti_pairing_entry {
+	__u8	pairing_ref;
+	__le16	src_nwk_addr;
+	__u8	log_channel;
+        __u8	ieee_addr[8];
+	__le16	pan_id;
+	__le16	nwk_addr;
+	__u8	rec_cap;
+	__u8	sec_key_valid;
+	__u8	sec_key[RTI_SEC_KEY_LEN];
+	__le16	vendor_id;
+	__u8	dev_type_list[RTI_MAX_NUM_DEV_TYPES];
+	__u32	frame_counter;
+} __attribute__((__packed__));
+
+#define RTI_PT_ENTRY_SIZE       (sizeof(struct rti_pairing_entry))
+
+#ifdef __KERNEL__
+
+static inline const char *remoti_rnp_error(u8 val)
+{
+	switch (val) {
+	case RTI_SUCCESS:
+		return "success";
+	case RTI_ERR_INV_INDEX:
+		return "invalid index";
+	case RTI_ERR_INV_PARAM:
+		return "invalid parameter";
+	case RTI_ERR_UNSUP_ATTR:
+		return "unsupported attribute";
+	case RTI_ERR_NOT_PERM:
+		return "not permitted";
+	case RTI_ERR_NO_ORG_CAP:
+		return "originator pairing table full";
+	case RTI_ERR_NO_REC_CAP:
+		return "recipient pairing table full";
+	case RTI_ERR_NO_RESP:
+		return "no response";
+	case RTI_ERR_OOM:
+		return "out of memory";
+	case RTI_ERR_PAIR_TIMEO:
+		return "pairing timeout";
+	case RTI_ERR_UNK_STATUS:
+		return "unknown RTI status";
+	case RTI_ERR_OSAL_NO_TIMER:
+		return "no OSAL timer available";
+	case RTI_ERR_OSAL_NV_FAILED:
+		return "NVRAM operation failed";
+	case RTI_ERR_OSAL_NV_UNINIT:
+		return "NVRAM item not initialized";
+	case RTI_ERR_OSAL_NV_BAD:
+		return "NVRAM item invalid length";
+	case RTI_ERR_MAC_EXP:
+		return "MAC transaction expired";
+	case RTI_ERR_MAC_OVF:
+		return "MAC transaction overflow";
+	case RTI_ERR_MAC_NO_RES:
+		return "MAC resource unavailable";
+	case RTI_ERR_MAC_BAD_STATE:
+		return "MAC state not allowed";
+	case RTI_ERR_MAC_CHAN_ACC:
+		return "MAC channel access failure";
+	case RTI_ERR_MAC_NO_ACK:
+		return "MAC transaction got no ACK";
+	case RTI_ERR_MAC_BCN:
+		return "MAC transaction w/ beacon lost";
+	case RTI_ERR_MAC_PAN_ID:
+		return "PAN ID conflict";
+	case RTI_ERR_MAC_SCAN:
+		return "MAC background scan in progress";
+	case RTI_ERR_FAIL_DISC:
+		return "failed to discover";
+	case RTI_ERR_NO_PAIR_IDX:
+		return "pairing reference invalid";
+	case RTI_ERR_PAIR_COMP:
+		return "pairing already completed";
+	case RTI_ERR_SYNC_TIMEO:
+		return "NPI synchronisation timeout";
+	default:
+		return "unknown";
+	}
+
+	return NULL;
+}
+
+/*
+ * Map a RemoTI error code to a standard Linux error code
+ */
+static inline int remoti_map_error(u8 val)
+{
+	switch (val) {
+	case RTI_SUCCESS:
+	case RTI_ERR_PAIR_COMP:
+		return 0;
+
+	case RTI_ERR_INV_INDEX:
+	case RTI_ERR_INV_PARAM:
+	case RTI_ERR_UNK_STATUS:
+	case RTI_ERR_OSAL_NV_BAD:
+	default:
+		return -EINVAL;
+
+	case RTI_ERR_UNSUP_ATTR:
+		return -ENOTSUPP;
+
+	case RTI_ERR_NOT_PERM:
+	case RTI_ERR_MAC_BAD_STATE:
+	case RTI_ERR_MAC_SCAN:
+		return -EPERM;
+
+	case RTI_ERR_NO_ORG_CAP:
+	case RTI_ERR_NO_REC_CAP:
+		return -ENOSPC;
+
+	case RTI_ERR_NO_RESP:
+	case RTI_ERR_PAIR_TIMEO:
+	case RTI_ERR_MAC_NO_ACK:
+	case RTI_ERR_MAC_BCN:
+	case RTI_ERR_MAC_EXP:
+	case RTI_ERR_SYNC_TIMEO:
+	case RTI_ERR_MAC_CHAN_ACC:
+	case RTI_ERR_FAIL_DISC:
+		return -ETIMEDOUT;
+
+	case RTI_ERR_OOM:
+	case RTI_ERR_OSAL_NO_TIMER:
+	case RTI_ERR_MAC_OVF:
+	case RTI_ERR_MAC_NO_RES:
+		return -ENOMEM;
+
+	case RTI_ERR_OSAL_NV_FAILED:
+	case RTI_ERR_OSAL_NV_UNINIT:
+		return -EIO;
+
+	case RTI_ERR_MAC_PAN_ID:
+		return -EEXIST;
+	}
+}
+
+/* Commonly used structures to describe frames */
+struct rti_hdr {
+	u8	len;
+	u8	subsys;
+	u8	cmd;
+} __packed;
+
+/*
+ * Payload starting after SOF + header
+ */
+#define RTI_HDR_SIZE	(sizeof(struct rti_hdr))
+
+struct remoti_msg {
+	u8 type;
+	u8 subsys;
+	u8 cmd;
+	u8 len;
+	u8 *data;
+	u8 flags;
+	u8 reply[NPI_MAX_MSG_LEN];
+};
+
+enum {
+	MSG_NO_RESP = 0,
+	MSG_STD_RESP,
+	MSG_NO_STD_RESP
+};
+
+struct remoti_rnp_msg {
+	struct remoti_msg *msg;
+	int status;
+	struct list_head next;
+	struct completion completion;
+};
+
+/*
+ * Values for 'status'
+ */
+enum {
+	MSG_QUEUED = 0,
+	MSG_SENT,
+	MSG_COMPLETED
+};
+
+struct remoti_command {
+	struct remoti_msg msg;
+	u8		fixed:1;
+	const char 	*name;
+	int		(*cnf)(struct remoti_device *rf,
+				const struct remoti_msg *msg);
+	int		(*post_init)(struct remoti_device *rf);
+	int		(*exit)(struct remoti_device *rf);
+	int		(*close)(struct remoti_device *rf);
+	struct list_head cmd_list;
+};
+
+struct remoti_transport;
+
+int remoti_send_frame(struct remoti_device *rf, struct remoti_msg *msg);
+int remoti_read_item(struct remoti_device *rf,
+			const u8 item, const u8 item_len,
+			void *value, size_t *len);
+int remoti_write_item(struct remoti_device *rf,
+			const u8 item,
+			const void *value, const size_t len);
+int remoti_receive_frame(struct remoti_transport *tsp,
+						const u8 *buf, const u8 len);
+int remoti_check_frame(struct remoti_transport *tsp,
+						const u8 *buf, const u8 len);
+void remoti_transport_close(struct remoti_transport *tsp);
+int remoti_reload_firmware(struct remoti_device *rf);
+
+int remoti_register_command(struct remoti_command *cmd);
+void remoti_unregister_command(struct remoti_command *cmd);
+
+struct remoti_command *remoti_find_cmd_by_id(const u8 id);
+
+static inline unsigned fw_data_is_empty(u8 *data, size_t count)
+{
+	while (count--)
+		if (*data++)
+			return 0;
+	return 1;
+}
+
+struct remoti_platform_data {
+	unsigned int reset_gpio;
+	unsigned int reset_polarity;
+};
+
+struct remoti_device {
+	struct platform_device	*pdev;
+	struct remoti_transport	*tsp;
+	spinlock_t		lock;
+	u8			state;
+
+	struct list_head	cmd_list;
+
+	/* rw items */
+	int                     cmd_status;
+
+	struct remoti_remote_dev input_devs[REMOTI_INPUT_COUNT];
+
+	/* firmware related stuff */
+	struct firmware		*fw;
+	struct workqueue_struct	*workqueue;
+	struct delayed_work	hw_init_work;
+	struct delayed_work	hw_firmware_work;
+
+	struct remoti_platform_data pdata;
+
+	struct work_struct	tx_work;
+	struct list_head	tx_msg_list;
+	spinlock_t		tx_msg_list_lock;
+};
+
+#endif /* __KERNEL__ */
+
+
+#endif /* __REMOTI_H */
diff -Nruw linux-2.6.39.4-fbx/include/linux/remoti./remoti-input-fbx.h linux-2.6.39.4-fbx/include/linux/remoti/remoti-input-fbx.h
--- linux-2.6.39.4-fbx/include/linux/remoti./remoti-input-fbx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/include/linux/remoti/remoti-input-fbx.h	2011-07-19 15:41:05.604933495 +0200
@@ -0,0 +1,70 @@
+#ifndef __REMOTI_INPUT_FBX_H
+#define __REMOTI_INPUT_FBX_H
+
+enum gyro_calib_states {
+        GYRO_CALIB_STATUS_OK,
+        GYRO_CALIB_STATUS_OUT_RANGE,
+        GYRO_CALIB_STATUS_WRITE_FAILED,
+        GYRO_CALIB_STATUS_DRIFT,
+        GYRO_CALIB_STATUS_ALDY_STARTED,
+        GYRO_CALIB_STATUS_TIMED_OUT
+};
+
+enum {
+	REMOTI_ATTR_INPUT_FBX_UNSPEC,
+	REMOTI_ATTR_INPUT_FBX_STATE,
+	REMOTI_ATTR_INPUT_FBX_STATUS,
+	REMOTI_ATTR_INPUT_FBX_INDEX,
+	REMOTI_ATTR_INPUT_FBX_GYRO_PARAMS,
+	REMOTI_ATTR_INPUT_FBX_ACCEL_PARAMS,
+	REMOTI_ATTR_INPUT_FBX_MAX
+};
+
+enum {
+	REMOTI_CMD_INPUT_FBX_UNSPEC,
+	REMOTI_CMD_INPUT_FBX_NEW_STATE,
+	REMOTI_CMD_INPUT_FBX_START_UPDATE,
+	REMOTI_CMD_INPUT_FBX_START_CALIB,
+	REMOTI_CMD_INPUT_FBX_GET_GYRO_PARAMS,
+	REMOTI_CMD_INPUT_FBX_SET_GYRO_STATE,
+	REMOTI_CMD_INPUT_FBX_GET_GYRO_STATE,
+	REMOTI_CMD_INPUT_FBX_GET_ACCEL_PARAMS,
+	REMOTI_CMD_INPUT_FBX_SET_ACCEL_STATE,
+	REMOTI_CMD_INPUT_FBX_GET_ACCEL_STATE,
+	REMOTI_CMD_INPUT_FBX_MAX
+};
+
+enum {
+	REMOTI_TYPE_INPUT_FBX_UNSPEC,
+	REMOTI_TYPE_INPUT_FBX_U8,
+	REMOTI_TYPE_INPUT_FBX_GYRO_PARAMS,
+	REMOTI_TYPE_INPUT_FBX_ACCEL_PARAMS,
+	REMOTI_TYPE_INPUT_FBX_MAX,
+};
+
+enum {
+	ACCELERO_MODEL_ST = 0,
+	ACCELERO_MODEL_ADI,
+};
+
+enum {
+	GYRO_MODEL_ANALOG = 0,
+	GYRO_MODEL_DIGITAL,
+};
+
+/* Physical gyro parameters */
+struct remoti_gyro_params {
+	__u8 deadband;
+	__s8 x_gain;
+        __s8 y_gain;
+        __s8 x_offset;
+        __s8 y_offset;
+        __u8 model;
+} __attribute__((__packed__));
+
+/* Physical accelerometer parameters */
+struct remoti_accel_params {
+	__u8 model;
+} __attribute__((__packed__));
+
+#endif /* __REMOTI_INPUT_FBX_H */
diff -Nruw linux-2.6.39.4-fbx/include/linux/remoti./remoti-input.h linux-2.6.39.4-fbx/include/linux/remoti/remoti-input.h
--- linux-2.6.39.4-fbx/include/linux/remoti./remoti-input.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/include/linux/remoti/remoti-input.h	2011-08-16 14:59:06.897872980 +0200
@@ -0,0 +1,162 @@
+#ifndef __REMOTI_INPUT_H
+#define __REMOTI_INPUT_H
+
+struct remoti_input_stats {
+	__u8 avg_lqi;
+	uint64_t rx_bytes;
+	uint64_t tx_bytes;
+	uint64_t events;
+	uint64_t tx_retries;
+};
+
+enum {
+	REMOTI_ATTR_INPUT_UNSPEC,
+	REMOTI_ATTR_INPUT_CMD,
+	REMOTI_ATTR_INPUT_INDEX,
+	REMOTI_ATTR_INPUT_NAME,
+	REMOTI_ATTR_INPUT_STATS,
+	REMOTI_ATTR_INPUT_STATUS,
+	REMOTI_ATTR_INPUT_MAX,
+};
+
+enum {
+	REMOTI_CMD_INPUT_UNSPEC,
+	REMOTI_CMD_INPUT_GET_STATS,
+	REMOTI_CMD_INPUT_UNPAIR,
+	REMOTI_CMD_INPUT_GET_NAME,
+	REMOTI_CMD_INPUT_GET_STATUS,
+	REMOTI_CMD_INPUT_NEW_DEVICE,
+	REMOTI_CMD_INPUT_MAX,
+};
+
+enum {
+	REMOTI_TYPE_INPUT_UNSPEC,
+	REMOTI_TYPE_INPUT_INDEX,
+	REMOTI_TYPE_INPUT_STATUS,
+	REMOTI_TYPE_INPUT_STRING,
+	REMOTI_TYPE_INPUT_STATS,
+	REMOTI_TYPE_INPUT_MAX,
+};
+
+#define REMOTI_STATUS_PAIRED	(1 << 0)
+#define REMOTI_STATUS_SECURED	(1 << 1)
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/completion.h>
+#include <linux/firmware.h>
+#include <linux/hwmon.h>
+#include <linux/mutex.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+
+#include <linux/remoti/remoti.h>
+
+/* Tx options */
+#define RCN_TX_OPT_BCAST	0x01
+#define RCN_TX_OPT_IEEE_ADDR	0x02
+#define RCN_TX_OPT_ACK		0x04
+#define RCN_TX_OPT_SEC		0x08
+#define RCN_TX_OPT_SINGLE	0x10
+#define RCN_TX_OPT_CHAN		0x20
+#define RCN_TX_OPT_VEN		0x40
+
+/* Rx options */
+#define RCN_RX_OPT_BCAST	0x01
+#define RCN_RX_OPT_SEC		0x02
+#define RCN_RX_OPT_VEN		0x04
+
+/* Remote control types */
+#define RTI_DEV_REMOTE_CONTROL	0x01
+
+#define CERC_PROFILE_ID		0xC0
+
+/* We also use it for an unpair confirmation */
+struct rti_pair_cnf {
+	u8	status;
+	u8	dst_idx;
+	u8	dev_type;
+} __packed;
+
+struct rti_rx_data_ind {
+	u8	src_idx;
+	u8	profile_id;
+	__le16	vendor_id;
+	u8	rx_lqi;
+	u8	rx_flags;
+	u8	len;
+	u8	data[];
+} __packed;
+
+struct rti_tx_data_req {
+	u8      dst_idx;
+	u8      profile_id;
+	__le16  vendor_id;
+	u8      tx_flags;
+	u8      len;
+} __packed;
+
+
+struct remoti_remote_dev;
+
+struct remoti_vendor_attr {
+	u8				id;
+	const struct attribute_group	*groups;
+	unsigned			num_groups;
+	int				(*init)(struct remoti_remote_dev *);
+	void				(*exit)(struct remoti_remote_dev *);
+	struct list_head		attr_list;
+};
+
+int remoti_register_vendor_attr(struct remoti_vendor_attr *attr);
+void remoti_unregister_vendor_attr(struct remoti_vendor_attr *attr);
+
+struct remoti_remote_dev {
+	/* sysfs attributes */
+	struct attribute_group *groups;
+	unsigned num_groups;
+
+	unsigned int type;
+	u8 index;
+	u8 paired:1;
+	u8 secured:1;
+	u8 last_cmd;
+	__le16 vendor_id;
+
+	struct remoti_input_stats stats;
+
+	struct mutex lock;
+
+	/* input related members */
+	struct input_dev *input_dev;
+	u16 *keycode;
+	struct timer_list release_timer;
+	int last_key_index;
+	struct delayed_work commit_work;
+
+	struct remoti_device *rf;
+};
+
+#define REMOTI_INPUT_COUNT	10
+
+static inline bool index_is_valid(u8 index)
+{
+	return (index < REMOTI_INPUT_COUNT);
+}
+
+struct remoti_vendor_command {
+	u8			id;	/* unique identifier */
+	int			(*handler)(struct remoti_remote_dev *,
+					const struct rti_rx_data_ind *);
+	int			(*commit)(struct remoti_remote_dev *);
+	void			(*close)(struct remoti_remote_dev *);
+	struct list_head	cmd_list;
+};
+
+int remoti_register_vendor_command(struct remoti_vendor_command *cmd);
+void remoti_unregister_vendor_command(struct remoti_vendor_command *cmd);
+
+#endif /* __KERNEL__ */
+
+#endif /* __REMOTI_INPUT_H */
diff -Nruw linux-2.6.39.4-fbx/include/linux/remoti./remoti-input-oad.h linux-2.6.39.4-fbx/include/linux/remoti/remoti-input-oad.h
--- linux-2.6.39.4-fbx/include/linux/remoti./remoti-input-oad.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/include/linux/remoti/remoti-input-oad.h	2011-07-19 15:41:05.604933495 +0200
@@ -0,0 +1,44 @@
+#ifndef __REMOTI_INPUT_OAD_H
+#define __REMOTI_INPUT_OAD_H
+
+enum oad_states {
+	OAD_STATE_UNSPEC,
+	OAD_STATE_READY,
+	OAD_STATE_FW_DOWNLOADING,
+	OAD_STATE_FW_FAILED,
+	OAD_STATE_FW_UPTODATE,
+	OAD_STATE_MAX,
+};
+
+enum {
+	REMOTI_ATTR_INPUT_OAD_UNSPEC,
+	REMOTI_ATTR_INPUT_OAD_VERSION,
+	REMOTI_ATTR_INPUT_OAD_STATE,
+	REMOTI_ATTR_INPUT_OAD_INDEX,
+	REMOTI_ATTR_INPUT_OAD_MAX,
+};
+
+enum {
+	REMOTI_CMD_INPUT_OAD_UNSPEC,
+	REMOTI_CMD_INPUT_OAD_GET_VERSION,
+	REMOTI_CMD_INPUT_OAD_GET_STATE,
+	REMOTI_CMD_INPUT_OAD_NEW_STATE,
+	REMOTI_CMD_INPUT_OAD_FW_PROGRESS,
+	REMOTI_CMD_INPUT_OAD_START,
+	REMOTI_CMD_INPUT_OAD_CANCEL,
+	REMOTI_CMD_INPUT_OAD_MAX,
+};
+
+enum {
+	REMOTI_TYPE_INPUT_OAD_UNSPEC,
+	REMOTI_TYPE_INPUT_OAD_U8,
+	REMOTI_TYPE_INPUT_OAD_U32,
+	REMOTI_TYPE_INPUT_OAD_MAX,
+};
+
+/*
+ * Progress related
+ */
+#define OAD_PROGRESS_STEP	(1)
+
+#endif /* __REMOTI_INPUT_OAD_H */
diff -Nruw linux-2.6.39.4-fbx/include/linux/remoti./remoti-netlink.h linux-2.6.39.4-fbx/include/linux/remoti/remoti-netlink.h
--- linux-2.6.39.4-fbx/include/linux/remoti./remoti-netlink.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/include/linux/remoti/remoti-netlink.h	2011-06-15 18:56:45.715462527 +0200
@@ -0,0 +1,61 @@
+#ifndef __REMOTI_NETLINK_H
+#define __REMOTI_NETLINK_H
+
+#include <linux/remoti/remoti.h>
+
+/* Exported attributes */
+enum {
+	REMOTI_ATTR_RNP_UNSPEC,
+	REMOTI_ATTR_RNP_CMD_ID,
+	REMOTI_ATTR_RNP_CMD_STATUS,
+	REMOTI_ATTR_RNP_STATE,
+	REMOTI_ATTR_RNP_CMD_FW,
+	REMOTI_ATTR_RNP_COUNTERS,
+	REMOTI_ATTR_RNP_TRANSPORT,
+	REMOTI_ATTR_RNP_MAX,
+};
+
+enum {
+	REMOTI_CMD_RNP_UNSPEC,
+	REMOTI_CMD_RNP_GET_STATE,
+	REMOTI_CMD_RNP_NEW_STATE,
+	REMOTI_CMD_RNP_SEND_CMD,
+	REMOTI_CMD_RNP_GET_CMD_STATUS,
+	REMOTI_CMD_RNP_RELOAD_FW,
+	REMOTI_CMD_RNP_GET_STATS,
+	REMOTI_CMD_RNP_GET_TRANSPORT,
+	REMOTI_CMD_RNP_READ_ITEM,
+	REMOTI_CMD_RNP_FW_PROGRESS,
+	REMOTI_CMD_RNP_MAX,
+};
+
+enum {
+	REMOTI_TYPE_UNSPEC,
+	REMOTI_TYPE_U8,
+	REMOTI_TYPE_INT,
+	REMOTI_TYPE_STATS,
+	REMOTI_TYPE_STRING,
+	REMOTI_TYPE_RNP_CMD,
+	REMOTI_TYPE_ITEM,
+	REMOTI_TYPE_MAX,
+};
+
+/* Nested attributes */
+enum {
+	REMOTI_TYPE_RNP_CMD_UNSPEC,
+	REMOTI_TYPE_RNP_CMD_ARGS,
+	REMOTI_TYPE_RNP_CMD_MAX,
+};
+
+#define RTI_FW_PROGRESS_STEP	(1)
+
+#ifdef __KERNEL__
+
+int remoti_netlink_register(struct remoti_device *rf);
+void remoti_netlink_unregister(void);
+
+int remoti_mcast_msg(const int cmd, const int type, const void *arg);
+
+#endif
+
+#endif /* __REMOTI_NETLINK_H */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/include/linux/smsc_cap1066.h	2011-05-24 18:15:37.645794659 +0200
@@ -0,0 +1,12 @@
+#ifndef SMSC_CAP1066_H_
+#define SMSC_CAP1066_H_
+
+#define CAP1066_MAX_BTNS	6
+
+struct smsc_cap1066_pdata {
+	unsigned short	key_map[CAP1066_MAX_BTNS];
+	unsigned int	irq_gpio;
+	bool		has_irq_gpio;
+};
+
+#endif /* ! SMSC_CAP1066_H_ */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/include/linux/spi/orion_tdm_spi.h	2011-05-24 18:15:37.665794577 +0200
@@ -0,0 +1,9 @@
+#ifndef __LINUX_SPI_ORION_TDM_SPI_H
+#define __LINUX_SPI_ORION_TDM_SPI_H
+
+struct orion_tdm_spi_info {
+	u32	tclk;
+	int	cs_use_gpio[2];
+};
+
+#endif
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/include/linux/spi/ssd1327.h	2011-05-24 18:15:37.665794577 +0200
@@ -0,0 +1,20 @@
+#ifndef __LINUX_SPI_SSD1327_H
+#define __LINUX_SPI_SSD1327_H
+
+struct ssd1327_platform_data {
+	/* attached screen info */
+	unsigned int		width;
+	unsigned int		height;
+
+	int			rotate;
+
+	/* gpio used to select command/data */
+	int			data_select_gpio;
+
+	/* watchdog (second), enabled if non zero, screen is blanked
+	 * if nothing is written for this number of seconds */
+	unsigned int		watchdog;
+};
+
+#endif /* ! __LINUX_SPI_SSD1327_H */
+
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/lib/fbxserial.c	2011-05-24 18:15:37.795794038 +0200
@@ -0,0 +1,117 @@
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/vmalloc.h>
+#include <linux/crc32.h>
+
+#include <asm/io.h>
+
+#include <linux/fbxserial.h>
+
+#define PFX "builtin-fbxserial: "
+
+static void __init
+fbxserialinfo_use_default(struct fbx_serial *serial)
+{
+	printk(KERN_WARNING PFX "warning: using default serial infos\n");
+	fbxserial_set_default(serial);
+}
+
+/*
+ * add trailing 0 for bundle string here.
+ */
+static void __init
+bundle_fixup(struct fbx_serial *serial)
+{
+	struct fbx_serial_extinfo *p;
+	int i;
+
+	for (i = 0; i < be32_to_cpu(serial->extinfo_count); i++) {
+
+		if (i >= EXTINFO_MAX_COUNT)
+			break;
+
+		p = &serial->extinfos[i];
+		if (be32_to_cpu(p->type) == EXTINFO_TYPE_EXTDEV &&
+		    be32_to_cpu(p->u.extdev.type) == EXTDEV_TYPE_BUNDLE) {
+			int size;
+
+			size = sizeof (p->u.extdev.serial);
+			p->u.extdev.serial[size - 1] = 0;
+		}
+	}
+}
+
+/*
+ * called from  arch code early  in the boot sequence.   This function
+ * returns 1  in case serial infos are  invalid/unreadable and default
+ * values have been used.
+ */
+int __init
+fbxserialinfo_read(void *data, struct fbx_serial *out)
+{
+	uint32_t sum;
+
+	/*
+	 * get partial serial data from flash/whatever.
+	 */
+	memcpy(out, data, sizeof (*out));
+
+	/* check magic first */
+	if (be32_to_cpu(out->magic) != FBXSERIAL_MAGIC) {
+		printk(KERN_NOTICE PFX "invalid magic (%08x, expected %08x), "
+			"using defaults !\n", be32_to_cpu(out->magic),
+		       FBXSERIAL_MAGIC);
+		goto out_default;
+	}
+
+	/* fetch size for which we have to check CRC */
+	if (be32_to_cpu(out->len) > FBXSERIAL_MAX_SIZE) {
+		printk(KERN_NOTICE PFX "structure size too big (%d), "
+		       "using defaults !\n", be32_to_cpu(out->len));
+		goto out_default;
+	}
+
+	/* compute and check checksum */
+	sum = crc32(0, data + 4, be32_to_cpu(out->len) - 4);
+
+	if (be32_to_cpu(out->crc32) != sum) {
+		printk(KERN_NOTICE PFX "invalid checksum (%08x, "
+		       "expected %08x), using defaults !\n", sum,
+		       be32_to_cpu(out->crc32));
+		goto out_default;
+	}
+
+	printk(KERN_INFO PFX "Found valid serial infos !\n");
+	bundle_fixup(out);
+	return 0;
+
+ out_default:
+	fbxserialinfo_use_default(out);
+	bundle_fixup(out);
+	return 1;
+}
+
+void
+fbxserialinfo_get_random(unsigned char *data, unsigned int len)
+{
+	const struct fbx_serial *s;
+
+	s = arch_get_fbxserial();
+
+	if (len > sizeof (s->random_data))
+		len = sizeof (s->random_data);
+
+	memcpy(data, s->random_data, len);
+}
+EXPORT_SYMBOL(fbxserialinfo_get_random);
+
+void
+fbxserialinfo_get_mac_addr(unsigned char *data)
+{
+	const struct fbx_serial *s;
+
+	s = arch_get_fbxserial();
+	memcpy(data, s->mac_addr_base, MAC_ADDR_SIZE);
+}
+EXPORT_SYMBOL(fbxserialinfo_get_mac_addr);
diff -Nruw linux-2.6.39.4-fbx/net/fbxatm./crc10.c linux-2.6.39.4-fbx/net/fbxatm/crc10.c
--- linux-2.6.39.4-fbx/net/fbxatm./crc10.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/net/fbxatm/crc10.c	2011-05-24 18:15:37.865793748 +0200
@@ -0,0 +1,48 @@
+#include <linux/types.h>
+
+static const u16 crc10_table[256] = {
+	0x0000, 0x0233, 0x0255, 0x0066, 0x0299, 0x00aa, 0x00cc, 0x02ff,
+	0x0301, 0x0132, 0x0154, 0x0367, 0x0198, 0x03ab, 0x03cd, 0x01fe,
+	0x0031, 0x0202, 0x0264, 0x0057, 0x02a8, 0x009b, 0x00fd, 0x02ce,
+	0x0330, 0x0103, 0x0165, 0x0356, 0x01a9, 0x039a, 0x03fc, 0x01cf,
+	0x0062, 0x0251, 0x0237, 0x0004, 0x02fb, 0x00c8, 0x00ae, 0x029d,
+	0x0363, 0x0150, 0x0136, 0x0305, 0x01fa, 0x03c9, 0x03af, 0x019c,
+	0x0053, 0x0260, 0x0206, 0x0035, 0x02ca, 0x00f9, 0x009f, 0x02ac,
+	0x0352, 0x0161, 0x0107, 0x0334, 0x01cb, 0x03f8, 0x039e, 0x01ad,
+	0x00c4, 0x02f7, 0x0291, 0x00a2, 0x025d, 0x006e, 0x0008, 0x023b,
+	0x03c5, 0x01f6, 0x0190, 0x03a3, 0x015c, 0x036f, 0x0309, 0x013a,
+	0x00f5, 0x02c6, 0x02a0, 0x0093, 0x026c, 0x005f, 0x0039, 0x020a,
+	0x03f4, 0x01c7, 0x01a1, 0x0392, 0x016d, 0x035e, 0x0338, 0x010b,
+	0x00a6, 0x0295, 0x02f3, 0x00c0, 0x023f, 0x000c, 0x006a, 0x0259,
+	0x03a7, 0x0194, 0x01f2, 0x03c1, 0x013e, 0x030d, 0x036b, 0x0158,
+	0x0097, 0x02a4, 0x02c2, 0x00f1, 0x020e, 0x003d, 0x005b, 0x0268,
+	0x0396, 0x01a5, 0x01c3, 0x03f0, 0x010f, 0x033c, 0x035a, 0x0169,
+	0x0188, 0x03bb, 0x03dd, 0x01ee, 0x0311, 0x0122, 0x0144, 0x0377,
+	0x0289, 0x00ba, 0x00dc, 0x02ef, 0x0010, 0x0223, 0x0245, 0x0076,
+	0x01b9, 0x038a, 0x03ec, 0x01df, 0x0320, 0x0113, 0x0175, 0x0346,
+	0x02b8, 0x008b, 0x00ed, 0x02de, 0x0021, 0x0212, 0x0274, 0x0047,
+	0x01ea, 0x03d9, 0x03bf, 0x018c, 0x0373, 0x0140, 0x0126, 0x0315,
+	0x02eb, 0x00d8, 0x00be, 0x028d, 0x0072, 0x0241, 0x0227, 0x0014,
+	0x01db, 0x03e8, 0x038e, 0x01bd, 0x0342, 0x0171, 0x0117, 0x0324,
+	0x02da, 0x00e9, 0x008f, 0x02bc, 0x0043, 0x0270, 0x0216, 0x0025,
+	0x014c, 0x037f, 0x0319, 0x012a, 0x03d5, 0x01e6, 0x0180, 0x03b3,
+	0x024d, 0x007e, 0x0018, 0x022b, 0x00d4, 0x02e7, 0x0281, 0x00b2,
+	0x017d, 0x034e, 0x0328, 0x011b, 0x03e4, 0x01d7, 0x01b1, 0x0382,
+	0x027c, 0x004f, 0x0029, 0x021a, 0x00e5, 0x02d6, 0x02b0, 0x0083,
+	0x012e, 0x031d, 0x037b, 0x0148, 0x03b7, 0x0184, 0x01e2, 0x03d1,
+	0x022f, 0x001c, 0x007a, 0x0249, 0x00b6, 0x0285, 0x02e3, 0x00d0,
+	0x011f, 0x032c, 0x034a, 0x0179, 0x0386, 0x01b5, 0x01d3, 0x03e0,
+	0x021e, 0x002d, 0x004b, 0x0278, 0x0087, 0x02b4, 0x02d2, 0x00e1,
+};
+
+static u16 crc10_byte(u16 crc, const u8 c)
+{
+	return ((crc << 8) & 0x3ff) ^ crc10_table[(crc >> 2) & 0xff] ^ c;
+}
+
+u16 crc10(u16 crc, const u8 *buffer, size_t len)
+{
+	while (len--)
+		crc = crc10_byte(crc, *buffer++);
+	return crc;
+}
diff -Nruw linux-2.6.39.4-fbx/net/fbxatm./fbxatm_2684.c linux-2.6.39.4-fbx/net/fbxatm/fbxatm_2684.c
--- linux-2.6.39.4-fbx/net/fbxatm./fbxatm_2684.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/net/fbxatm/fbxatm_2684.c	2011-05-24 18:15:37.865793748 +0200
@@ -0,0 +1,741 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>
+#include <linux/rtnetlink.h>
+#include <linux/pkt_sched.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/icmp.h>
+#include <linux/proc_fs.h>
+#include <net/ip.h>
+#include <net/route.h>
+#include <linux/fbxatm_dev.h>
+
+#include "fbxatm_priv.h"
+
+#define PFX	"fbxatm_2684: "
+
+static LIST_HEAD(fbxatm_2684_dev_list);
+static DEFINE_MUTEX(fbxatm_2684_mutex);
+
+#define LLC_NEEDED_HEADROOM		10
+#define VCMUX_BRIDGED_NEEDED_HEADROOM	2
+
+#define LLC			0xaa, 0xaa, 0x03
+#define SNAP_BRIDGED		0x00, 0x80, 0xc2
+#define SNAP_ROUTED		0x00, 0x00, 0x00
+#define PID_ETHERNET_NOFCS	0x00, 0x07
+
+static u8 llc_bridged_802d3_pad[] = { LLC, SNAP_BRIDGED, PID_ETHERNET_NOFCS,
+				      0, 0 };
+static u8 llc_snap_routed[] = { LLC, SNAP_ROUTED };
+
+/*
+ * private data for 2684 vcc
+ */
+struct fbxatm_2684_vcc {
+	struct fbxatm_vcc		*vcc;
+
+	struct net_device		*dev;
+	struct fbxatm_2684_vcc_params	params;
+
+	spinlock_t			tx_lock;
+
+	struct net_device_stats		stats;
+
+	struct list_head		next;
+};
+
+/*
+ * reconstruct missing part of skb header because of retx and netifrx
+ * it
+ */
+static void fix_iph_netifrx(struct fbxatm_2684_vcc *vcc, struct sk_buff *skb)
+{
+	struct iphdr *iph;
+
+	/* don't do this if this seems to be already a valid ip
+	 * packet */
+	iph = (struct iphdr *)skb->data;
+	if (iph->version == 4) {
+		netif_rx(skb);
+		return;
+	}
+
+	/* 4 bytes have been removed, and 4 bytes overwritten */
+	if (skb_headroom(skb) < 4) {
+		printk(KERN_ERR PFX "fix_iph_netifrx: skb has no headroom\n");
+		return;
+	}
+
+	/* if skb  len is 64,  the following operation may  generate a
+	 * bad ip  header, since  the original ip  total len  may have
+	 * been lower than 64 (because of ethernet padding).
+	 */
+	skb_push(skb, 4);
+	iph = (struct iphdr *)skb->data;
+
+	/* fill lost  fields, we  will need to  recompute checksum...,
+	 * skb will then  be cache hot, so this should  not be a great
+	 * deal */
+	iph->version = 4;
+	iph->ihl = 5;
+	iph->tos = 0;
+	iph->tot_len = htons(skb->len);
+	iph->id = 0;
+	iph->frag_off = htons(IP_DF);
+	iph->ttl = 64;
+
+	iph->check = 0;
+	iph->check = ip_fast_csum((u8 *)iph, 5);
+
+	netif_rx(skb);
+}
+
+/*
+ * fbxatm stack receive callback, called from softirq
+ */
+static void vcc_rx_callback(struct sk_buff *skb, void *data)
+{
+	struct fbxatm_2684_vcc *priv;
+
+	priv = (struct fbxatm_2684_vcc *)data;
+
+	switch (priv->params.encap) {
+	case FBXATM_E2684_VCMUX:
+		switch (priv->params.payload) {
+		case FBXATM_P2684_BRIDGE:
+			/* assume 802.3, need to remove 2 bytes zero
+			 * padding */
+			if (skb->len < 2 || memcmp(skb->data, "\0\0", 2))
+				goto drop;
+			skb_pull(skb, 2);
+			skb->protocol = eth_type_trans(skb, priv->dev);
+			memset(skb->data, 0, 2);
+			break;
+
+		case FBXATM_P2684_ROUTED:
+			/* assume ipv4 */
+			skb->protocol = htons(ETH_P_IP);
+			break;
+		}
+		break;
+
+	case FBXATM_E2684_LLC:
+		switch (priv->params.payload) {
+		case FBXATM_P2684_BRIDGE:
+		{
+			/* recognize only 802.3 */
+			if (skb->len < sizeof(llc_bridged_802d3_pad))
+				goto drop;
+
+			if (memcmp(skb->data, llc_bridged_802d3_pad, 7))
+				goto drop;
+
+			/* don't check the last bytes of pid, it can
+			 * be 1 or 7 depending on the presence of
+			 * FCS */
+			skb_pull(skb, sizeof(llc_bridged_802d3_pad));
+			skb->protocol = eth_type_trans(skb, priv->dev);
+			break;
+		}
+
+		case FBXATM_P2684_ROUTED:
+		{
+			u16 proto;
+			unsigned int offset;
+
+			if (skb->len < sizeof(llc_snap_routed) + 2)
+				goto drop;
+
+			offset = sizeof (llc_snap_routed);
+			proto = skb->data[offset] << 8;
+			proto |= skb->data[offset + 1];
+
+			skb->protocol = proto;
+			skb_pull(skb, sizeof(llc_snap_routed) + 2);
+			break;
+		}
+		}
+		break;
+	}
+
+	skb->dev = priv->dev;
+	skb->pkt_type = PACKET_HOST;
+	skb->rx_class = priv->vcc->qos.rx_priority;
+	priv->stats.rx_bytes += skb->len;
+	priv->stats.rx_packets++;
+
+	/* FIXME: remove this once retx has been fully removed on CO
+	 * side */
+	if (priv->params.encap == FBXATM_E2684_VCMUX &&
+	    priv->params.payload == FBXATM_P2684_ROUTED &&
+	    priv->vcc->vpi == 8 &&
+	    (priv->vcc->vci == 33 ||
+	     priv->vcc->vci == 34 ||
+	     priv->vcc->vci == 37))
+		fix_iph_netifrx(priv, skb);
+	else
+		netif_rx(skb);
+	return;
+
+drop:
+	priv->stats.rx_errors++;
+	dev_kfree_skb(skb);
+}
+
+/*
+ * fbxatm stack tx done callback, called from softirq
+ */
+static void vcc_tx_done_callback(void *data)
+{
+	struct fbxatm_2684_vcc *priv;
+
+	priv = (struct fbxatm_2684_vcc *)data;
+
+	spin_lock(&priv->tx_lock);
+	if (netif_queue_stopped(priv->dev))
+		netif_wake_queue(priv->dev);
+	spin_unlock(&priv->tx_lock);
+}
+
+/*
+ * fbxatm stack callback when vcc link changes
+ */
+static void vcc_link_change(void *data, int link,
+			    unsigned int rx_cell_rate,
+			    unsigned int tx_cell_rate)
+{
+	struct fbxatm_2684_vcc *priv;
+
+	priv = (struct fbxatm_2684_vcc *)data;
+
+	if (link)
+		netif_carrier_on(priv->dev);
+	else
+		netif_carrier_off(priv->dev);
+}
+
+/*
+ * vcc user ops, callback from fbxatm stack
+ */
+static const struct fbxatm_vcc_uops fbxatm_2684_uops = {
+	.link_change	= vcc_link_change,
+	.rx_pkt		= vcc_rx_callback,
+	.tx_done	= vcc_tx_done_callback,
+};
+
+/*
+ * netdevice xmit callback
+ */
+static int fbxatm_2684_netdev_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct fbxatm_2684_vcc *priv;
+	int ret;
+	unsigned int needed_headroom;
+
+	priv = netdev_priv(dev);
+
+	/*
+	 * check if we have to expand skb head
+	 */
+	needed_headroom = 0;
+	if (priv->params.encap == FBXATM_E2684_VCMUX) {
+		if (priv->params.payload == FBXATM_P2684_BRIDGE)
+			needed_headroom = VCMUX_BRIDGED_NEEDED_HEADROOM;
+	} else
+		needed_headroom = LLC_NEEDED_HEADROOM;
+
+	if (skb_headroom(skb) < needed_headroom) {
+		struct sk_buff *nskb;
+		unsigned int new_head;
+
+		new_head = skb_headroom(skb) + needed_headroom;
+		nskb = skb_realloc_headroom(skb, new_head);
+		dev_kfree_skb(skb);
+		if (!nskb)
+			goto dropped;
+		skb = nskb;
+	}
+
+	switch (priv->params.encap) {
+	case FBXATM_E2684_VCMUX:
+		switch (priv->params.payload) {
+		case FBXATM_P2684_BRIDGE:
+			skb_push(skb, 2);
+			memset(skb->data, 0, 2);
+			break;
+		case FBXATM_P2684_ROUTED:
+			/* nothing to do */
+			break;
+		}
+		break;
+
+	case FBXATM_E2684_LLC:
+		switch (priv->params.payload) {
+		case FBXATM_P2684_BRIDGE:
+			skb_push(skb, sizeof(llc_bridged_802d3_pad));
+			memcpy(skb->data, llc_bridged_802d3_pad,
+			       sizeof(llc_bridged_802d3_pad));
+			break;
+
+		case FBXATM_P2684_ROUTED:
+		{
+			unsigned int offset;
+
+			skb_push(skb, sizeof(llc_snap_routed));
+			memcpy(skb->data, llc_snap_routed,
+			       sizeof(llc_snap_routed));
+
+			offset = sizeof (llc_snap_routed);
+			skb->data[offset] = (skb->protocol >> 8) & 0xff;
+			skb->data[offset + 1] = skb->protocol & 0xff;
+			break;
+		}
+		}
+		break;
+	}
+
+	spin_lock(&priv->tx_lock);
+
+	ret = fbxatm_send(priv->vcc, skb);
+	if (ret) {
+		/* packet was not sent, queue is full */
+		netif_stop_queue(dev);
+		spin_unlock(&priv->tx_lock);
+		return NETDEV_TX_BUSY;
+	}
+
+	/* check if queue is full */
+	priv->stats.tx_bytes += skb->len;
+	priv->stats.tx_packets++;
+
+	if (fbxatm_vcc_queue_full(priv->vcc))
+		netif_stop_queue(dev);
+	spin_unlock(&priv->tx_lock);
+
+	return NETDEV_TX_OK;
+
+dropped:
+	priv->stats.tx_errors++;
+	return NETDEV_TX_OK;
+}
+
+/*
+ * netdevice get_stats callback
+ */
+static struct net_device_stats *
+fbxatm_2684_netdev_get_stats(struct net_device *dev)
+{
+	struct fbxatm_2684_vcc *priv;
+	priv = netdev_priv(dev);
+	return &priv->stats;
+}
+
+/*
+ * netdevice setup callback for bridge encap
+ */
+static void setup_bridged(struct net_device *dev)
+{
+	ether_setup(dev);
+}
+
+/*
+ * netdevice setup callback for routed encap
+ */
+static void setup_routed(struct net_device *dev)
+{
+	dev->type		= ARPHRD_PPP;
+	dev->hard_header_len	= 0;
+	dev->mtu		= 1500;
+	dev->addr_len		= 0;
+	dev->tx_queue_len	= 128;
+	dev->flags		= IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
+}
+
+static const struct net_device_ops fbxatm_2684_ops = {
+	.ndo_start_xmit		= fbxatm_2684_netdev_xmit,
+	.ndo_get_stats		= fbxatm_2684_netdev_get_stats,
+};
+
+/*
+ * sysfs callback, show encapsulation
+ */
+static ssize_t show_encap(struct device *d,
+			  struct device_attribute *attr, char *buf)
+{
+	struct fbxatm_2684_vcc *priv = netdev_priv(to_net_dev(d));
+
+	switch (priv->params.encap) {
+	case FBXATM_E2684_LLC:
+		return sprintf(buf, "llc\n");
+	case FBXATM_E2684_VCMUX:
+	default:
+		return sprintf(buf, "vcmux\n");
+	}
+}
+
+static DEVICE_ATTR(encap, S_IRUGO, show_encap, NULL);
+
+/*
+ * sysfs callback, show payload
+ */
+static ssize_t show_payload(struct device *d,
+			    struct device_attribute *attr, char *buf)
+{
+	struct fbxatm_2684_vcc *priv = netdev_priv(to_net_dev(d));
+
+	switch (priv->params.payload) {
+	case FBXATM_P2684_BRIDGE:
+		return sprintf(buf, "bridge\n");
+	case FBXATM_P2684_ROUTED:
+	default:
+		return sprintf(buf, "routed\n");
+	}
+}
+
+static DEVICE_ATTR(payload, S_IRUGO, show_payload, NULL);
+
+/*
+ * sysfs callback, show vcc id
+ */
+static ssize_t show_vcc(struct device *d,
+			struct device_attribute *attr, char *buf)
+{
+	struct fbxatm_2684_vcc *priv = netdev_priv(to_net_dev(d));
+
+	return sprintf(buf, "%u.%u.%u\n",
+		       priv->vcc->adev->ifindex,
+		       priv->vcc->vpi, priv->vcc->vci);
+}
+
+static DEVICE_ATTR(vcc, S_IRUGO, show_vcc, NULL);
+
+static struct attribute *fbxatm2684_attrs[] = {
+	&dev_attr_encap.attr,
+	&dev_attr_payload.attr,
+	&dev_attr_vcc.attr,
+	NULL
+};
+
+static struct attribute_group fbxatm2684_group = {
+	.name = "fbxatm2684",
+	.attrs = fbxatm2684_attrs,
+};
+
+/*
+ * create sysfs files for 2684 device
+ */
+static int vcc2684_sysfs_register(struct fbxatm_2684_vcc *priv,
+				  struct net_device *dev)
+{
+	int ret;
+
+	ret = sysfs_create_group(&dev->dev.kobj, &fbxatm2684_group);
+	if (ret)
+		goto out1;
+
+	ret = sysfs_create_link(&dev->dev.kobj,
+				&priv->vcc->adev->dev.kobj, "fbxatm_dev");
+	if (ret)
+		goto out2;
+
+	return 0;
+
+out2:
+	sysfs_remove_group(&dev->dev.kobj, &fbxatm2684_group);
+out1:
+	return ret;
+}
+
+/*
+ * remove sysfs files for 2684 device
+ */
+static void vcc2684_sysfs_unregister(struct fbxatm_2684_vcc *priv,
+				     struct net_device *dev)
+{
+	sysfs_remove_group(&dev->dev.kobj, &fbxatm2684_group);
+	sysfs_remove_link(&dev->dev.kobj, "fbxatm_dev");
+}
+
+/*
+ * register netdevice & sysfs attribute
+ */
+static int register_2684_netdev(struct fbxatm_2684_vcc *priv,
+				struct net_device *dev)
+{
+	int ret;
+
+	/* hold rtnl while registering netdevice and creating sysfs
+	 * files to avoid race */
+	rtnl_lock();
+
+	if (strchr(dev->name, '%')) {
+		ret = dev_alloc_name(dev, dev->name);
+		if (ret < 0)
+			goto out;
+	}
+
+	ret = register_netdevice(dev);
+	if (ret)
+		goto out;
+
+	ret = vcc2684_sysfs_register(priv, dev);
+	if (ret)
+		goto out_unregister;
+
+	rtnl_unlock();
+	return 0;
+
+out_unregister:
+	unregister_netdevice(dev);
+
+out:
+	rtnl_unlock();
+	return ret;
+}
+
+/*
+ * create a RFC2684 encapsulation on given vcc
+ */
+static int __create_2684_vcc(const struct fbxatm_2684_vcc_params *params)
+{
+	struct fbxatm_2684_vcc *priv;
+	struct fbxatm_vcc *vcc;
+	struct net_device *dev;
+	void (*netdev_setup_cb)(struct net_device *dev);
+	int ret;
+
+	/* sanity check */
+	switch (params->encap) {
+	case FBXATM_E2684_VCMUX:
+	case FBXATM_E2684_LLC:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (params->payload) {
+	case FBXATM_P2684_BRIDGE:
+		netdev_setup_cb = setup_bridged;
+		break;
+	case FBXATM_P2684_ROUTED:
+		netdev_setup_cb = setup_routed;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (!params->dev_name[0])
+		return -EINVAL;
+
+	/* bind to vcc */
+	vcc = fbxatm_bind_to_vcc(&params->id, FBXATM_VCC_USER_2684);
+	if (IS_ERR(vcc))
+		return PTR_ERR(vcc);
+
+	/* create netdevice */
+	dev = alloc_netdev(sizeof(*priv), params->dev_name, netdev_setup_cb);
+	if (!dev) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	priv = netdev_priv(dev);
+	memset(priv, 0, sizeof (priv));
+	memcpy(&priv->params, params, sizeof (*params));
+	memcpy(dev->name, priv->params.dev_name, IFNAMSIZ);
+
+	spin_lock_init(&priv->tx_lock);
+	priv->dev = dev;
+	priv->vcc = vcc;
+
+	dev->netdev_ops = &fbxatm_2684_ops;
+
+	/* make sure kernel generated packet have correct headroom for
+	 * encapsulation/payload */
+	dev->hard_header_len += vcc->adev->tx_headroom;
+	switch (params->encap) {
+	case FBXATM_E2684_VCMUX:
+	default:
+		if (params->payload == FBXATM_P2684_BRIDGE)
+			dev->hard_header_len += VCMUX_BRIDGED_NEEDED_HEADROOM;
+		break;
+	case FBXATM_E2684_LLC:
+		dev->hard_header_len += LLC_NEEDED_HEADROOM;
+		break;
+	}
+
+	ret = register_2684_netdev(priv, dev);
+	if (ret)
+		goto fail;
+
+	if (fbxatm_vcc_link_is_up(vcc))
+		netif_carrier_on(dev);
+	else
+		netif_carrier_off(dev);
+	list_add_tail(&priv->next, &fbxatm_2684_dev_list);
+	fbxatm_set_uops(vcc, &fbxatm_2684_uops, priv);
+	return 0;
+
+fail:
+	fbxatm_unbind_vcc(vcc);
+	if (dev)
+		free_netdev(dev);
+	return ret;
+}
+
+/*
+ * find 2684 vcc from id
+ */
+static struct fbxatm_2684_vcc *__find_2684_vcc(const struct fbxatm_vcc_id *id)
+{
+	struct fbxatm_2684_vcc *priv;
+	int found;
+
+	/* find it */
+	found = 0;
+	list_for_each_entry(priv, &fbxatm_2684_dev_list, next) {
+		if (priv->vcc->adev->ifindex != id->dev_idx ||
+		    priv->vcc->vpi != id->vpi || priv->vcc->vci != id->vci)
+			continue;
+
+		found = 1;
+		break;
+	}
+
+	if (found)
+		return priv;
+	return NULL;
+}
+
+/*
+ * create a RFC2684 encapsulation on given vcc
+ */
+static int create_2684_vcc(const struct fbxatm_2684_vcc_params *params)
+{
+	int ret;
+
+	mutex_lock(&fbxatm_2684_mutex);
+	ret = __create_2684_vcc(params);
+	mutex_unlock(&fbxatm_2684_mutex);
+	return ret;
+}
+
+/*
+ * remove RFC2684 encapsulation from given vcc
+ */
+static int __remove_2684_vcc(const struct fbxatm_2684_vcc_params *params)
+{
+	struct fbxatm_2684_vcc *priv;
+
+	priv = __find_2684_vcc(&params->id);
+	if (!priv)
+		return -ENOENT;
+
+	/* close netdevice, fbxatm_2684_netdev_xmit cannot be called
+	 * again */
+	rtnl_lock();
+	dev_close(priv->dev);
+	rtnl_unlock();
+
+	fbxatm_unbind_vcc(priv->vcc);
+	vcc2684_sysfs_unregister(priv, priv->dev);
+	unregister_netdev(priv->dev);
+	list_del(&priv->next);
+	free_netdev(priv->dev);
+	return 0;
+}
+
+/*
+ * remove RFC2684 encapsulation from given vcc
+ */
+static int remove_2684_vcc(const struct fbxatm_2684_vcc_params *params)
+{
+	int ret;
+
+	mutex_lock(&fbxatm_2684_mutex);
+	ret = __remove_2684_vcc(params);
+	mutex_unlock(&fbxatm_2684_mutex);
+	return ret;
+}
+
+/*
+ * 2684 related ioctl handler
+ */
+static int fbxatm_2684_ioctl(struct socket *sock,
+			     unsigned int cmd, void __user *useraddr)
+{
+	int ret;
+
+	ret = 0;
+
+	switch (cmd) {
+	case FBXATM_2684_IOCADD:
+	case FBXATM_2684_IOCDEL:
+	{
+		struct fbxatm_2684_vcc_params params;
+
+		if (copy_from_user(&params, useraddr, sizeof(params)))
+			return -EFAULT;
+
+		if (cmd == FBXATM_2684_IOCADD)
+			ret = create_2684_vcc(&params);
+		else
+			ret = remove_2684_vcc(&params);
+		break;
+	}
+
+	case FBXATM_2684_IOCGET:
+	{
+		struct fbxatm_2684_vcc_params params;
+		struct fbxatm_2684_vcc *priv;
+
+		if (copy_from_user(&params, useraddr, sizeof(params)))
+			return -EFAULT;
+
+		mutex_lock(&fbxatm_2684_mutex);
+		priv = __find_2684_vcc(&params.id);
+		if (!priv)
+			ret = -ENOENT;
+		else {
+			memcpy(&params, &priv->params, sizeof (params));
+			memcpy(params.dev_name, priv->dev->name, IFNAMSIZ);
+		}
+		mutex_unlock(&fbxatm_2684_mutex);
+
+		if (ret)
+			return ret;
+
+		if (copy_to_user(useraddr, &params, sizeof(params)))
+			return -EFAULT;
+		break;
+	}
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+
+	return ret;
+}
+
+static struct fbxatm_ioctl fbxatm_2684_ioctl_ops = {
+	.handler	= fbxatm_2684_ioctl,
+	.owner		= THIS_MODULE,
+};
+
+int __init fbxatm_2684_init(void)
+{
+	fbxatm_register_ioctl(&fbxatm_2684_ioctl_ops);
+	return 0;
+}
+
+void fbxatm_2684_exit(void)
+{
+	fbxatm_unregister_ioctl(&fbxatm_2684_ioctl_ops);
+}
diff -Nruw linux-2.6.39.4-fbx/net/fbxatm./fbxatm_core.c linux-2.6.39.4-fbx/net/fbxatm/fbxatm_core.c
--- linux-2.6.39.4-fbx/net/fbxatm./fbxatm_core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/net/fbxatm/fbxatm_core.c	2011-06-20 17:00:14.296084288 +0200
@@ -0,0 +1,206 @@
+#include <linux/init.h>
+#include <linux/net.h>
+#include <linux/socket.h>
+#include <linux/fbxatm.h>
+#include <linux/fbxatm_dev.h>
+#include <net/sock.h>
+#include "fbxatm_priv.h"
+
+static DEFINE_MUTEX(ioctl_mutex);
+static LIST_HEAD(ioctl_list);
+
+void fbxatm_register_ioctl(struct fbxatm_ioctl *ioctl)
+{
+	mutex_lock(&ioctl_mutex);
+	list_add_tail(&ioctl->next, &ioctl_list);
+	mutex_unlock(&ioctl_mutex);
+}
+
+void fbxatm_unregister_ioctl(struct fbxatm_ioctl *ioctl)
+{
+	mutex_lock(&ioctl_mutex);
+	list_del(&ioctl->next);
+	mutex_unlock(&ioctl_mutex);
+}
+
+static int fbxatm_sock_ioctl(struct socket *sock, unsigned int cmd,
+			     unsigned long arg)
+{
+	struct fbxatm_ioctl *ioctl;
+	void __user *useraddr;
+	int ret;
+
+	/* sanity check */
+	useraddr = (void __user *)arg;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	ret = -ENOIOCTLCMD;
+	mutex_lock(&ioctl_mutex);
+
+	list_for_each_entry(ioctl, &ioctl_list, next) {
+		if (!ioctl->handler)
+			continue;
+
+		if (!try_module_get(ioctl->owner))
+			continue;
+
+		ret = ioctl->handler(sock, cmd, useraddr);
+		module_put(ioctl->owner);
+		if (ret != -ENOIOCTLCMD)
+			break;
+	}
+	mutex_unlock(&ioctl_mutex);
+
+	return ret;
+}
+
+static int fbxatm_sock_release(struct socket *sock)
+{
+	struct fbxatm_ioctl *ioctl;
+	struct sock *sk = sock->sk;
+
+	mutex_lock(&ioctl_mutex);
+
+	list_for_each_entry(ioctl, &ioctl_list, next) {
+		if (!ioctl->release)
+			continue;
+
+		if (!try_module_get(ioctl->owner))
+			continue;
+
+		ioctl->release(sock);
+		module_put(ioctl->owner);
+	}
+	mutex_unlock(&ioctl_mutex);
+
+	if (sk)
+		sock_put(sk);
+
+	return 0;
+}
+
+static const struct proto_ops fbxatm_proto_ops = {
+	.family		= PF_FBXATM,
+
+	.release =	fbxatm_sock_release,
+	.ioctl =	fbxatm_sock_ioctl,
+
+	.bind =		sock_no_bind,
+	.connect =	sock_no_connect,
+	.socketpair =	sock_no_socketpair,
+	.accept =	sock_no_accept,
+	.getname =	sock_no_getname,
+	.poll =		sock_no_poll,
+	.listen =	sock_no_listen,
+	.shutdown =	sock_no_shutdown,
+	.setsockopt =	sock_no_setsockopt,
+	.getsockopt =	sock_no_getsockopt,
+	.sendmsg =	sock_no_sendmsg,
+	.recvmsg =	sock_no_recvmsg,
+	.mmap =		sock_no_mmap,
+	.sendpage =	sock_no_sendpage,
+	.owner		= THIS_MODULE,
+};
+
+static struct proto fbxatm_proto = {
+        .name           = "fbxatm",
+        .owner          =  THIS_MODULE,
+        .obj_size       = sizeof (struct sock),
+};
+
+static int fbxatm_sock_create(struct net *net, struct socket *sock,
+			      int protocol, int kern)
+{
+	struct sock *sk;
+
+        sk = sk_alloc(net, PF_FBXATM, GFP_KERNEL, &fbxatm_proto);
+	if (!sk)
+		return -ENOMEM;
+
+        sock_init_data(sock, sk);
+        sock->state = SS_UNCONNECTED;
+        sock->ops = &fbxatm_proto_ops;
+	return 0;
+}
+
+static struct net_proto_family fbxatm_family_ops = {
+	.family = PF_FBXATM,
+	.create = fbxatm_sock_create,
+	.owner = THIS_MODULE,
+};
+
+
+static int __init fbxatm_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "Freebox ATM stack\n");
+	ret = fbxatm_sysfs_init();
+	if (ret)
+		return ret;
+
+	ret = fbxatm_procfs_init();
+	if (ret)
+		goto fail_sysfs;
+
+	ret = fbxatm_vcc_init();
+	if (ret)
+		goto fail_procfs;
+
+	ret = fbxatm_2684_init();
+	if (ret)
+		goto fail_vcc;
+
+	ret = fbxatm_pppoa_init();
+	if (ret)
+		goto fail_2684;
+
+	ret = proto_register(&fbxatm_proto, 0);
+	if (ret)
+		goto fail_pppoa;
+
+	ret = sock_register(&fbxatm_family_ops);
+	if (ret)
+		goto fail_proto;
+
+	return 0;
+
+fail_proto:
+	proto_unregister(&fbxatm_proto);
+
+fail_pppoa:
+	fbxatm_pppoa_exit();
+
+fail_2684:
+	fbxatm_2684_exit();
+
+fail_vcc:
+	fbxatm_vcc_exit();
+
+fail_procfs:
+	fbxatm_procfs_exit();
+
+fail_sysfs:
+	fbxatm_sysfs_exit();
+	printk(KERN_ERR "failed to initialize Freebox ATM stack\n");
+	return ret;
+}
+
+static void __exit fbxatm_exit(void)
+{
+	sock_unregister(PF_FBXATM);
+	proto_unregister(&fbxatm_proto);
+	fbxatm_pppoa_exit();
+	fbxatm_2684_exit();
+	fbxatm_vcc_exit();
+	fbxatm_procfs_exit();
+	fbxatm_sysfs_exit();
+}
+
+subsys_initcall(fbxatm_init);
+module_exit(fbxatm_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_NETPROTO(PF_FBXATM);
diff -Nruw linux-2.6.39.4-fbx/net/fbxatm./fbxatm_dev.c linux-2.6.39.4-fbx/net/fbxatm/fbxatm_dev.c
--- linux-2.6.39.4-fbx/net/fbxatm./fbxatm_dev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/net/fbxatm/fbxatm_dev.c	2011-06-15 18:56:45.975463255 +0200
@@ -0,0 +1,957 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+#include <linux/mutex.h>
+#include <linux/bitops.h>
+#include <linux/fbxatm_dev.h>
+#include "fbxatm_priv.h"
+
+/*
+ * list of registered device & lock
+ */
+LIST_HEAD(fbxatm_dev_list);
+
+/*
+ * big "rtnl" lock
+ */
+DEFINE_MUTEX(fbxatm_mutex);
+static int fbxatm_ifindex = -1;
+
+/*
+ * find device by index
+ */
+static struct fbxatm_dev *__fbxatm_dev_get_by_index(int ifindex)
+{
+	struct fbxatm_dev *pdev;
+
+	list_for_each_entry(pdev, &fbxatm_dev_list, next) {
+		if (pdev->ifindex == ifindex)
+			return pdev;
+	}
+	return NULL;
+}
+
+/*
+ * find vcc by id
+ */
+static struct fbxatm_vcc *
+__fbxatm_vcc_get_by_id(const struct fbxatm_vcc_id *id)
+{
+	struct fbxatm_dev *adev;
+	struct fbxatm_vcc *vcc;
+	int found;
+
+	adev = __fbxatm_dev_get_by_index(id->dev_idx);
+	if (!adev)
+		return ERR_PTR(-ENODEV);
+
+	found = 0;
+	list_for_each_entry(vcc, &adev->vcc_list, next) {
+		if (vcc->vpi != id->vpi || vcc->vci != id->vci)
+			continue;
+		found = 1;
+		break;
+	}
+
+	if (found)
+		return vcc;
+	return ERR_PTR(-ENOENT);
+}
+
+/*
+ * allocate device
+ */
+struct fbxatm_dev *fbxatm_alloc_device(int sizeof_priv)
+{
+	unsigned int size;
+
+	size = sizeof(struct fbxatm_dev) + sizeof_priv + FBXATMDEV_ALIGN;
+	return kzalloc(size, GFP_KERNEL);
+}
+
+EXPORT_SYMBOL(fbxatm_alloc_device);
+
+/*
+ * calculate crc10 of oam cell
+ */
+static void compute_oam_crc10(struct fbxatm_oam_cell_payload *cell)
+{
+	u8 *pdu;
+	u16 crc;
+
+	/* crc10 does not cover header */
+	pdu = (u8 *)&cell->cell_type;
+	memset(cell->crc10, 0, 2);
+
+	crc = crc10(0, pdu, sizeof (*cell) - sizeof (cell->cell_hdr));
+	cell->crc10[0] = crc >> 8;
+	cell->crc10[1] = crc & 0xff;
+}
+
+/*
+ * check crc10 of oam cell
+ */
+static int check_oam_crc10(struct fbxatm_oam_cell_payload *cell)
+{
+	u8 *pdu;
+	u16 crc;
+
+	pdu = (u8 *)&cell->cell_type;
+
+	crc = (cell->crc10[0] << 8) | cell->crc10[1];
+	memset(cell->crc10, 0, 2);
+
+	if (crc != crc10(0, pdu, sizeof (*cell) - sizeof (cell->cell_hdr)))
+		return 1;
+
+	return 0;
+}
+
+/*
+ * send an oam ping and wait for answer
+ */
+static int do_oam_ping(struct fbxatm_oam_ping *ping)
+{
+	struct fbxatm_dev *adev;
+	struct fbxatm_oam_cell *oam_cell;
+	struct fbxatm_oam_cell_payload *cell;
+	u8 *hdr;
+	int ret;
+
+	switch (ping->req.type) {
+	case FBXATM_OAM_PING_SEG_F4:
+	case FBXATM_OAM_PING_E2E_F4:
+		return -ENOTSUPP;
+	case FBXATM_OAM_PING_SEG_F5:
+	case FBXATM_OAM_PING_E2E_F5:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* find device */
+	mutex_lock(&fbxatm_mutex);
+	adev = __fbxatm_dev_get_by_index(ping->req.id.dev_idx);
+	if (!adev) {
+		ret = -ENODEV;
+		goto out_unlock;
+	}
+
+	if (!test_bit(FBXATM_DEV_F_LINK_UP, &adev->dev_flags)) {
+		ret = -ENETDOWN;
+		goto out_unlock;
+	}
+
+	/* if f5, vcc need to be opened */
+	switch (ping->req.type) {
+	case FBXATM_OAM_PING_SEG_F5:
+	case FBXATM_OAM_PING_E2E_F5:
+	{
+		struct fbxatm_vcc *vcc;
+
+		vcc = __fbxatm_vcc_get_by_id(&ping->req.id);
+		if (IS_ERR(vcc)) {
+			ret = -ENETDOWN;
+			goto out_unlock;
+		}
+		break;
+	}
+
+	default:
+		break;
+	}
+
+	ping->correlation_id = ++adev->oam_correlation_id;
+
+	/* prepare atm oam cell and send it */
+	oam_cell = kmalloc(sizeof (*oam_cell), GFP_KERNEL);
+	if (!oam_cell) {
+		ret = -ENOMEM;
+		goto out_unlock;
+	}
+	cell = &oam_cell->payload;
+
+	hdr = cell->cell_hdr;
+	ATM_SET_GFC(hdr, 0);
+
+	ATM_SET_VPI(hdr, ping->req.id.vpi);
+	ATM_SET_VCI(hdr, ping->req.id.vci);
+	if (ping->req.type == FBXATM_OAM_PING_E2E_F5)
+		ATM_SET_PT(hdr, OAM_PTI_END2END_F5);
+	else
+		ATM_SET_PT(hdr, OAM_PTI_SEG_F5);
+	ATM_SET_CLP(hdr, 0);
+	ATM_SET_HEC(hdr, 0);
+
+	cell->cell_type = (OAM_TYPE_FAULT_MANAGEMENT << OAM_TYPE_SHIFT) |
+		(FUNC_TYPE_OAM_LOOPBACK << FUNC_TYPE_SHIFT);
+	cell->loopback_indication = 1;
+
+	memcpy(cell->correlation_tag, &ping->correlation_id,
+	       sizeof (cell->correlation_tag));
+	memcpy(cell->loopback_id, ping->req.llid, sizeof (ping->req.llid));
+	memset(cell->source_id, 0x6a, sizeof (cell->source_id));
+	memset(cell->reserved, 0x6a, sizeof (cell->reserved));
+
+	compute_oam_crc10(cell);
+
+	ret = adev->ops->send_oam(adev, oam_cell);
+	if (ret)
+		goto out_unlock;
+
+	/* wait for an answer */
+	list_add(&ping->next, &adev->oam_pending_ping);
+	ping->replied = 0;
+	init_waitqueue_head(&ping->wq);
+	mutex_unlock(&fbxatm_mutex);
+
+	ret = wait_event_interruptible_timeout(ping->wq, ping->replied,
+					       HZ * 5);
+	list_del(&ping->next);
+
+	if (ret == -ERESTARTSYS)
+		return ret;
+
+	if (ping->replied < 0) {
+		/* ping failed */
+		return ping->replied;
+	}
+
+	if (!ping->replied) {
+		/* timeout */
+		return -ETIME;
+	}
+
+	return 0;
+
+
+out_unlock:
+	mutex_unlock(&fbxatm_mutex);
+	return ret;
+}
+
+/*
+ * special llid values
+ */
+static const u8 llid_all1[16] = { 0xff, 0xff, 0xff, 0xff,
+				  0xff, 0xff, 0xff, 0xff,
+				  0xff, 0xff, 0xff, 0xff,
+				  0xff, 0xff, 0xff, 0xff };
+
+static const u8 llid_all0[16] = { 0 };
+
+/*
+ * handle incoming oam cell
+ */
+static void handle_oam_cell(struct fbxatm_dev *adev,
+			    struct fbxatm_oam_cell *oam_cell)
+{
+	struct fbxatm_oam_cell_payload *cell;
+	u16 vci;
+	u8 *hdr, pt, oam, func;
+
+	/* check CRC10 */
+	cell = &oam_cell->payload;
+	if (check_oam_crc10(cell)) {
+		adev->stats.rx_bad_oam++;
+		goto out;
+	}
+
+	/* drop f4 cells */
+	hdr = cell->cell_hdr;
+	vci = ATM_GET_VCI(hdr);
+
+	if (vci == OAM_VCI_SEG_F4 || vci == OAM_VCI_END2END_F4) {
+		adev->stats.rx_f4_oam++;
+		goto out;
+	}
+
+	/* keep f5 cells only */
+	pt = ATM_GET_PT(hdr);
+	if (pt != OAM_PTI_SEG_F5 && pt != OAM_PTI_END2END_F5) {
+		adev->stats.rx_other_oam++;
+		goto out;
+	}
+
+	adev->stats.rx_f5_oam++;
+
+	/* keep oam loopback type only */
+	oam = (cell->cell_type & OAM_TYPE_MASK) >> OAM_TYPE_SHIFT;
+	func = (cell->cell_type & FUNC_TYPE_MASK) >> FUNC_TYPE_SHIFT;
+
+	if (oam != OAM_TYPE_FAULT_MANAGEMENT ||
+	    func != FUNC_TYPE_OAM_LOOPBACK) {
+		adev->stats.rx_other_oam++;
+		goto out;
+	}
+
+	if (cell->loopback_indication & 1) {
+		int match, ret;
+
+		/* request, check for llid match */
+		match = 0;
+		switch (pt) {
+		case OAM_PTI_SEG_F5:
+			/* 0x0 or 0xffffffff */
+			if (!memcmp(cell->loopback_id, llid_all0,
+				    sizeof (llid_all0)))
+				match = 1;
+			/* fallthrough */
+
+		case OAM_PTI_END2END_F5:
+			/* 0xffffffff only */
+			if (!memcmp(cell->loopback_id, llid_all1,
+				    sizeof (llid_all1)))
+				match = 1;
+			break;
+		}
+
+		if (!match) {
+			adev->stats.rx_bad_llid_oam++;
+			goto out;
+		}
+
+		/* ok, update llid and answer */
+		cell->loopback_indication = 0;
+		memcpy(cell->loopback_id, llid_all1, sizeof (llid_all1));
+		compute_oam_crc10(cell);
+
+		mutex_lock(&fbxatm_mutex);
+		ret = adev->ops->send_oam(adev, oam_cell);
+		mutex_unlock(&fbxatm_mutex);
+
+		if (!ret) {
+			/* send successful, don't free cell */
+			return;
+		}
+
+	} else {
+		struct fbxatm_oam_ping *ping;
+
+		/* reply, find a matching sender */
+		mutex_lock(&fbxatm_mutex);
+		list_for_each_entry(ping, &adev->oam_pending_ping, next) {
+
+			/* compare correlation id */
+			if (memcmp(&ping->correlation_id,
+				   cell->correlation_tag,
+				   sizeof (cell->correlation_tag)))
+				continue;
+
+			/* compare ping type */
+			switch (ping->req.type) {
+			case FBXATM_OAM_PING_SEG_F5:
+				if (pt != OAM_PTI_SEG_F5)
+					continue;
+				break;
+			case FBXATM_OAM_PING_E2E_F5:
+				if (pt != OAM_PTI_END2END_F5)
+					continue;
+				break;
+			default:
+				break;
+			}
+
+			/* seems we have a match */
+			ping->replied = 1;
+			wake_up(&ping->wq);
+		}
+		mutex_unlock(&fbxatm_mutex);
+	}
+
+out:
+	kfree(oam_cell);
+}
+
+/*
+ * oam rx processing workqueue
+ */
+static void fbxatm_oam_work(struct work_struct *work)
+{
+	struct fbxatm_dev *adev;
+	struct fbxatm_oam_cell *cell;
+
+	adev = container_of(work, struct fbxatm_dev, oam_work);
+
+	do {
+		cell = NULL;
+		spin_lock_bh(&adev->oam_lock);
+		if (!list_empty(&adev->rx_oam_cells)) {
+			cell = list_first_entry(&adev->rx_oam_cells,
+						struct fbxatm_oam_cell, next);
+			list_del(&cell->next);
+			adev->rx_oam_cells_count--;
+		}
+		spin_unlock_bh(&adev->oam_lock);
+
+		if (cell)
+			handle_oam_cell(adev, cell);
+
+	} while (cell);
+}
+
+/*
+ * register given device
+ */
+static int __fbxatm_register_device(struct fbxatm_dev *adev,
+				    const char *base_name,
+				    const struct fbxatm_dev_ops *ops)
+{
+	struct fbxatm_dev *pdev;
+	int name_len, count, ret;
+	long *inuse;
+
+	adev->ops = ops;
+	INIT_LIST_HEAD(&adev->vcc_list);
+	INIT_LIST_HEAD(&adev->next);
+	spin_lock_init(&adev->stats_lock);
+	spin_lock_init(&adev->oam_lock);
+	INIT_LIST_HEAD(&adev->rx_oam_cells);
+	INIT_WORK(&adev->oam_work, fbxatm_oam_work);
+	INIT_LIST_HEAD(&adev->oam_pending_ping);
+	get_random_bytes(&adev->oam_correlation_id, 4);
+
+	name_len = strlen(base_name);
+	adev->name = kmalloc(name_len + 10, GFP_KERNEL);
+	if (!adev->name) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	/* allocate ifindex */
+	while (1) {
+		if (++fbxatm_ifindex < 0)
+			fbxatm_ifindex = 0;
+		if (__fbxatm_dev_get_by_index(fbxatm_ifindex))
+			continue;
+		adev->ifindex = fbxatm_ifindex;
+		break;
+	}
+
+	/* allocate device name */
+	inuse = (long *)get_zeroed_page(GFP_ATOMIC);
+	if (!inuse) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	list_for_each_entry(pdev, &fbxatm_dev_list, next) {
+		unsigned long val;
+		char *end;
+
+		/* look for common prefix */
+		if (strncmp(base_name, pdev->name, name_len))
+			continue;
+
+		/* make sure name is the same, not just a prefix */
+		val = simple_strtoul(pdev->name + name_len, &end, 10);
+		if (!*end)
+			continue;
+
+		set_bit(val, inuse);
+	}
+
+	count = find_first_zero_bit(inuse, PAGE_SIZE * 8);
+	free_page((unsigned long)inuse);
+
+	snprintf(adev->name, name_len + 10, "%s%d", base_name, count);
+	list_add_tail(&adev->next, &fbxatm_dev_list);
+
+	/* create procfs entries */
+	ret = fbxatm_proc_dev_register(adev);
+	if (ret)
+		goto fail;
+
+	/* call device procfs init if any */
+	if (adev->ops->init_procfs) {
+		ret = adev->ops->init_procfs(adev);
+		if (ret)
+			goto fail_procfs;
+	}
+
+	/* create sysfs entries */
+	ret = fbxatm_register_dev_sysfs(adev);
+	if (ret)
+		goto fail_procfs;
+
+	return 0;
+
+fail_procfs:
+	fbxatm_proc_dev_deregister(adev);
+
+fail:
+	list_del(&adev->next);
+	kfree(adev->name);
+	return ret;
+}
+
+/*
+ * take lock and register device
+ */
+int fbxatm_register_device(struct fbxatm_dev *adev,
+			   const char *base_name,
+			   const struct fbxatm_dev_ops *ops)
+{
+	int ret;
+
+	mutex_lock(&fbxatm_mutex);
+	ret = __fbxatm_register_device(adev, base_name, ops);
+	mutex_unlock(&fbxatm_mutex);
+	return ret;
+}
+
+EXPORT_SYMBOL(fbxatm_register_device);
+
+/*
+ * change device "link" state
+ */
+static void fbxatm_dev_set_link(struct fbxatm_dev *adev, int link)
+{
+	struct fbxatm_vcc *vcc;
+
+	/* prevent new vcc creation and oam ping */
+	mutex_lock(&fbxatm_mutex);
+
+	if (link) {
+		memset(&adev->stats, 0, sizeof (adev->stats));
+		list_for_each_entry(vcc, &adev->vcc_list, next)
+			memset(&vcc->stats, 0, sizeof (vcc->stats));
+		wmb();
+		set_bit(FBXATM_DEV_F_LINK_UP, &adev->dev_flags);
+		list_for_each_entry(vcc, &adev->vcc_list, next) {
+			set_bit(FBXATM_VCC_F_LINK_UP, &vcc->vcc_flags);
+			if (!vcc->user_ops || !vcc->user_ops->link_change)
+				continue;
+			vcc->user_ops->link_change(vcc->user_cb_data, 1,
+						   adev->link_cell_rate_ds,
+						   adev->link_cell_rate_us);
+		}
+	} else {
+		/* prevent further oam cells input */
+		spin_lock_bh(&adev->oam_lock);
+		clear_bit(FBXATM_DEV_F_LINK_UP, &adev->dev_flags);
+		spin_unlock_bh(&adev->oam_lock);
+
+		/* flush rx oam work */
+		cancel_work_sync(&adev->oam_work);
+
+		/* now disable tx on all vcc */
+		list_for_each_entry(vcc, &adev->vcc_list, next) {
+			spin_lock_bh(&vcc->tx_lock);
+			clear_bit(FBXATM_VCC_F_LINK_UP, &vcc->vcc_flags);
+			spin_unlock_bh(&vcc->tx_lock);
+			if (!vcc->user_ops || !vcc->user_ops->link_change)
+				continue;
+			vcc->user_ops->link_change(vcc->user_cb_data, 0, 0, 0);
+		}
+	}
+
+	fbxatm_dev_change_sysfs(adev);
+	mutex_unlock(&fbxatm_mutex);
+}
+
+/*
+ * set device "link" to up, allowing vcc/device send ops to be called,
+ * this function sleeps
+ */
+void fbxatm_dev_set_link_up(struct fbxatm_dev *adev)
+{
+	if (!test_bit(FBXATM_DEV_F_LINK_UP, &adev->dev_flags))
+		printk(KERN_INFO "%s: link UP - "
+		       "down: %u kbit/s - up: %u kbit/s\n", adev->name,
+		       adev->link_rate_ds / 1000, adev->link_rate_us / 1000);
+	return fbxatm_dev_set_link(adev, 1);
+}
+
+EXPORT_SYMBOL(fbxatm_dev_set_link_up);
+
+/*
+ * set device link to down, disallowing any vcc/device send ops to be
+ * called, this function sleeps
+ */
+void fbxatm_dev_set_link_down(struct fbxatm_dev *adev)
+{
+	if (test_bit(FBXATM_DEV_F_LINK_UP, &adev->dev_flags))
+		printk(KERN_INFO "%s: link DOWN\n", adev->name);
+	return fbxatm_dev_set_link(adev, 0);
+}
+
+EXPORT_SYMBOL(fbxatm_dev_set_link_down);
+
+/*
+ * take lock and unregister device
+ */
+int fbxatm_unregister_device(struct fbxatm_dev *adev)
+{
+	int ret;
+
+	ret = 0;
+	mutex_lock(&fbxatm_mutex);
+
+	if (!list_empty(&adev->vcc_list)) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	list_del(&adev->next);
+
+	if (adev->ops->release_procfs)
+		adev->ops->release_procfs(adev);
+	fbxatm_proc_dev_deregister(adev);
+
+	fbxatm_unregister_dev_sysfs(adev);
+out:
+	mutex_unlock(&fbxatm_mutex);
+	return ret;
+}
+
+EXPORT_SYMBOL(fbxatm_unregister_device);
+
+/*
+ * actually free device memory
+ */
+void __fbxatm_free_device(struct fbxatm_dev *adev)
+{
+	kfree(adev->name);
+	kfree(adev);
+}
+
+/*
+ * free device memory
+ */
+void fbxatm_free_device(struct fbxatm_dev *adev)
+{
+	/* actual free is done in sysfs release */
+//	class_device_put(&adev->class_dev);
+}
+
+EXPORT_SYMBOL(fbxatm_free_device);
+
+/*
+ * device callback when oam cell comes in
+ */
+void fbxatm_netifrx_oam(struct fbxatm_dev *adev, struct fbxatm_oam_cell *cell)
+{
+	spin_lock_bh(&adev->oam_lock);
+	if (!test_bit(FBXATM_DEV_F_LINK_UP, &adev->dev_flags) ||
+	    adev->rx_oam_cells_count > 8) {
+		kfree(cell);
+		spin_unlock_bh(&adev->oam_lock);
+		return;
+	}
+	adev->rx_oam_cells_count++;
+	list_add_tail(&cell->next, &adev->rx_oam_cells);
+	spin_unlock_bh(&adev->oam_lock);
+	schedule_work(&adev->oam_work);
+}
+
+EXPORT_SYMBOL(fbxatm_netifrx_oam);
+
+/*
+ * set user ops on vcc
+ */
+void fbxatm_set_uops(struct fbxatm_vcc *vcc,
+		     const struct fbxatm_vcc_uops *user_ops,
+		     void *user_cb_data)
+{
+	spin_lock_bh(&vcc->user_ops_lock);
+	vcc->user_ops = user_ops;
+	vcc->user_cb_data = user_cb_data;
+	spin_unlock_bh(&vcc->user_ops_lock);
+}
+
+/*
+ * bind to given vcc
+ */
+static struct fbxatm_vcc *
+__fbxatm_bind_to_vcc(const struct fbxatm_vcc_id *id,
+		     enum fbxatm_vcc_user user)
+{
+	struct fbxatm_vcc *vcc;
+
+	vcc = __fbxatm_vcc_get_by_id(id);
+	if (IS_ERR(vcc))
+		return vcc;
+
+	if (vcc->user != FBXATM_VCC_USER_NONE)
+		return ERR_PTR(-EBUSY);
+
+	vcc->user = user;
+	return vcc;
+}
+
+/*
+ * bind to given vcc
+ */
+struct fbxatm_vcc *
+fbxatm_bind_to_vcc(const struct fbxatm_vcc_id *id,
+		   enum fbxatm_vcc_user user)
+{
+	struct fbxatm_vcc *vcc;
+
+	mutex_lock(&fbxatm_mutex);
+	vcc = __fbxatm_bind_to_vcc(id, user);
+	mutex_unlock(&fbxatm_mutex);
+	return vcc;
+}
+
+/*
+ * unbind from given vcc
+ */
+void fbxatm_unbind_vcc(struct fbxatm_vcc *vcc)
+{
+	spin_lock_bh(&vcc->user_ops_lock);
+	vcc->user_ops = NULL;
+	vcc->user_cb_data = NULL;
+	vcc->user = FBXATM_VCC_USER_NONE;
+	spin_unlock_bh(&vcc->user_ops_lock);
+}
+
+/*
+ * open vcc on given device
+ */
+static int __fbxatm_dev_open_vcc(const struct fbxatm_vcc_id *id,
+				 const struct fbxatm_vcc_qos *qos)
+{
+	struct fbxatm_vcc *vcc;
+	struct fbxatm_dev *adev;
+	int ret, count;
+
+	/* check vpi/vci unicity  */
+	vcc = __fbxatm_vcc_get_by_id(id);
+	if (!IS_ERR(vcc))
+		return -EBUSY;
+
+	/* sanity check */
+	switch (qos->traffic_class) {
+	case FBXATM_VCC_TC_UBR_NO_PCR:
+	case FBXATM_VCC_TC_UBR:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (qos->max_sdu > 4096)
+		return -EINVAL;
+
+	if (qos->max_buffered_pkt > 128)
+		return -EINVAL;
+
+	adev = __fbxatm_dev_get_by_index(id->dev_idx);
+	if (!adev)
+		return -ENODEV;
+
+	/* make sure device accept requested priorities */
+	if (qos->priority > adev->max_priority)
+		return -EINVAL;
+
+	if (qos->rx_priority > adev->max_rx_priority)
+		return -EINVAL;
+
+	/* don't open more vcc than device can handle */
+	count = 0;
+	list_for_each_entry(vcc, &adev->vcc_list, next)
+		count++;
+	if (count + 1 > adev->max_vcc)
+		return -ENOSPC;
+
+	/* make sure vpi/vci is valid for this device */
+	if ((~adev->vpi_mask & id->vpi) || (~adev->vci_mask & id->vci))
+		return -EINVAL;
+
+	if (!try_module_get(adev->ops->owner))
+		return -ENODEV;
+
+	/* ok, create vcc */
+	vcc = kzalloc(sizeof (*vcc), GFP_KERNEL);
+	if (!vcc)
+		return -ENOMEM;
+
+	spin_lock_init(&vcc->user_ops_lock);
+	spin_lock_init(&vcc->tx_lock);
+	vcc->vpi = id->vpi;
+	vcc->vci = id->vci;
+	vcc->adev = adev;
+	vcc->to_drop_pkt = 0;
+	memcpy(&vcc->qos, qos, sizeof (*qos));
+
+	ret = adev->ops->open(vcc);
+	if (ret) {
+		kfree(vcc);
+		return ret;
+	}
+
+	/* inherit vcc link state from device */
+	if (test_bit(FBXATM_DEV_F_LINK_UP, &adev->dev_flags))
+		set_bit(FBXATM_VCC_F_LINK_UP, &vcc->vcc_flags);
+
+	list_add_tail(&vcc->next, &adev->vcc_list);
+	return ret;
+}
+
+/*
+ * find device & open vcc on it
+ */
+static int fbxatm_dev_open_vcc(const struct fbxatm_vcc_id *id,
+			       const struct fbxatm_vcc_qos *qos)
+{
+	int ret;
+
+	mutex_lock(&fbxatm_mutex);
+	ret = __fbxatm_dev_open_vcc(id, qos);
+	mutex_unlock(&fbxatm_mutex);
+	return ret;
+}
+
+/*
+ * close vcc on device
+ */
+static int __fbxatm_dev_close_vcc(struct fbxatm_vcc *vcc)
+{
+	struct fbxatm_dev *adev;
+
+	if (vcc->user != FBXATM_VCC_USER_NONE)
+		return -EBUSY;
+	adev = vcc->adev;
+	module_put(adev->ops->owner);
+	adev->ops->close(vcc);
+	list_del(&vcc->next);
+	kfree(vcc);
+	return 0;
+}
+
+/*
+ * find device & vcc and close it
+ */
+static int fbxatm_dev_close_vcc(const struct fbxatm_vcc_id *id)
+{
+	struct fbxatm_vcc *vcc;
+	int ret;
+
+	mutex_lock(&fbxatm_mutex);
+	vcc = __fbxatm_vcc_get_by_id(id);
+	if (IS_ERR(vcc))
+		ret = PTR_ERR(vcc);
+	else
+		ret = __fbxatm_dev_close_vcc(vcc);
+	mutex_unlock(&fbxatm_mutex);
+	return ret;
+}
+
+/*
+ * ioctl handler
+ */
+static int fbxatm_vcc_ioctl(struct socket *sock,
+			    unsigned int cmd, void __user *useraddr)
+{
+	int ret;
+
+	ret = 0;
+
+	switch (cmd) {
+	case FBXATM_IOCADD:
+	case FBXATM_IOCDEL:
+	{
+		struct fbxatm_vcc_params params;
+
+		if (copy_from_user(&params, useraddr, sizeof(params)))
+			return -EFAULT;
+
+		if (cmd == FBXATM_IOCADD)
+			ret = fbxatm_dev_open_vcc(&params.id, &params.qos);
+		else
+			ret = fbxatm_dev_close_vcc(&params.id);
+		break;
+	}
+
+	case FBXATM_IOCGET:
+	{
+		struct fbxatm_vcc_params params;
+		struct fbxatm_vcc *vcc;
+
+		if (copy_from_user(&params, useraddr, sizeof(params)))
+			return -EFAULT;
+
+		mutex_lock(&fbxatm_mutex);
+		vcc = __fbxatm_vcc_get_by_id(&params.id);
+		if (IS_ERR(vcc))
+			ret = PTR_ERR(vcc);
+		else {
+			memcpy(&params.qos, &vcc->qos, sizeof (vcc->qos));
+			params.user = vcc->user;
+		}
+		mutex_unlock(&fbxatm_mutex);
+
+		if (ret)
+			return ret;
+
+		if (copy_to_user(useraddr, &params, sizeof(params)))
+			return -EFAULT;
+		break;
+	}
+
+	case FBXATM_IOCOAMPING:
+	{
+		struct fbxatm_oam_ping ping;
+
+		if (copy_from_user(&ping.req, useraddr, sizeof(ping.req)))
+			return -EFAULT;
+
+		ret = do_oam_ping(&ping);
+		if (ret)
+			return ret;
+
+		if (copy_to_user(useraddr, &ping.req, sizeof(ping.req)))
+			return -EFAULT;
+		break;
+	}
+
+	case FBXATM_IOCDROP:
+	{
+		struct fbxatm_vcc_drop_params params;
+		struct fbxatm_vcc *vcc;
+
+		if (copy_from_user(&params, useraddr, sizeof(params)))
+			return -EFAULT;
+
+		mutex_lock(&fbxatm_mutex);
+		vcc = __fbxatm_vcc_get_by_id(&params.id);
+		if (IS_ERR(vcc))
+			ret = PTR_ERR(vcc);
+		else {
+			spin_lock_bh(&vcc->user_ops_lock);
+			vcc->to_drop_pkt += params.drop_count;
+			spin_unlock_bh(&vcc->user_ops_lock);
+			ret = 0;
+		}
+		mutex_unlock(&fbxatm_mutex);
+
+		if (ret)
+			return ret;
+		break;
+	}
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+
+	return ret;
+}
+
+static struct fbxatm_ioctl fbxatm_vcc_ioctl_ops = {
+	.handler	= fbxatm_vcc_ioctl,
+	.owner		= THIS_MODULE,
+};
+
+int __init fbxatm_vcc_init(void)
+{
+	fbxatm_register_ioctl(&fbxatm_vcc_ioctl_ops);
+	return 0;
+}
+
+void fbxatm_vcc_exit(void)
+{
+	fbxatm_unregister_ioctl(&fbxatm_vcc_ioctl_ops);
+}
diff -Nruw linux-2.6.39.4-fbx/net/fbxatm./fbxatm_pppoa.c linux-2.6.39.4-fbx/net/fbxatm/fbxatm_pppoa.c
--- linux-2.6.39.4-fbx/net/fbxatm./fbxatm_pppoa.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/net/fbxatm/fbxatm_pppoa.c	2011-05-24 18:15:37.875793706 +0200
@@ -0,0 +1,485 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/if_pppox.h>
+#include <linux/ppp_channel.h>
+#include <linux/ppp_defs.h>
+#include <linux/if_ppp.h>
+#include <linux/fbxatm.h>
+#include <linux/fbxatm_dev.h>
+#include "fbxatm_priv.h"
+
+#define PFX	"fbxatm_pppoa: "
+
+static LIST_HEAD(fbxatm_pppoa_vcc_list);
+static DEFINE_MUTEX(fbxatm_pppoa_mutex);
+
+/*
+ * private data for pppoa vcc
+ */
+struct fbxatm_pppoa_vcc {
+	struct fbxatm_vcc		*vcc;
+	struct fbxatm_pppoa_vcc_params	params;
+	enum fbxatm_pppoa_encap		cur_encap;
+
+	/* used by ppp */
+	int				flags;
+	struct ppp_channel		chan;
+
+	struct socket			*sock;
+	struct list_head		next;
+};
+
+
+#define __LLC_HDR		0xfe, 0xfe, 0x03
+#define __NLPID_PPP		0xcf
+#define __PPP_LCP		0xc0, 0x21
+
+static const u8 llc_ppp[]	= { __LLC_HDR, __NLPID_PPP };
+static const u8 llc_ppp_lcp[]	= { __LLC_HDR, __NLPID_PPP, __PPP_LCP };
+static const u8 lcp[]		= { __PPP_LCP };
+
+
+/*
+ * fbxatm stack receive callback, called from softirq
+ */
+static void vcc_rx_callback(struct sk_buff *skb, void *data)
+{
+	struct fbxatm_pppoa_vcc *priv;
+
+	priv = (struct fbxatm_pppoa_vcc *)data;
+
+	if (priv->chan.ppp == NULL) {
+		dev_kfree_skb(skb);
+		return;
+	}
+
+	switch (priv->cur_encap) {
+	case FBXATM_EPPPOA_VCMUX:
+		/* nothing to do */
+		break;
+
+	case FBXATM_EPPPOA_LLC:
+		/* make sure llc header is present and remove */
+		if (skb->len < sizeof(llc_ppp) ||
+		    memcmp(skb->data, llc_ppp, sizeof(llc_ppp)))
+			goto error;
+		skb_pull(skb, sizeof(llc_ppp));
+		break;
+
+	case FBXATM_EPPPOA_AUTODETECT:
+		/* look for lcp, with an llc header or not */
+		if (skb->len >= sizeof(llc_ppp_lcp) &&
+		    !memcmp(skb->data, llc_ppp_lcp, sizeof(llc_ppp_lcp))) {
+			priv->cur_encap = FBXATM_EPPPOA_LLC;
+			skb_pull(skb, sizeof(llc_ppp));
+			break;
+		}
+
+		if (skb->len >= sizeof(lcp) &&
+		    !memcmp(skb->data, lcp, sizeof (lcp))) {
+			priv->cur_encap = FBXATM_EPPPOA_VCMUX;
+			break;
+		}
+
+		/* no match */
+		goto error;
+	}
+
+	ppp_input(&priv->chan, skb);
+	return;
+
+error:
+	dev_kfree_skb(skb);
+	ppp_input_error(&priv->chan, 0);
+}
+
+/*
+ * fbxatm stack tx done callback, called from softirq
+ */
+static void vcc_tx_done_callback(void *data)
+{
+	struct fbxatm_pppoa_vcc *priv;
+	priv = (struct fbxatm_pppoa_vcc *)data;
+	ppp_output_wakeup(&priv->chan);
+}
+
+/*
+ * vcc user ops, callback from fbxatm stack
+ */
+static const struct fbxatm_vcc_uops fbxatm_pppoa_vcc_uops = {
+	.rx_pkt		= vcc_rx_callback,
+	.tx_done	= vcc_tx_done_callback,
+};
+
+/*
+ * ppp xmit callback
+ */
+static int ppp_xmit(struct ppp_channel *chan, struct sk_buff *skb)
+{
+	struct fbxatm_pppoa_vcc *priv;
+	struct sk_buff *to_send_skb, *nskb;
+	int ret;
+
+	priv = (struct fbxatm_pppoa_vcc *)chan->private;
+
+	/* MAYBE FIXME: handle protocol compression ? */
+
+	to_send_skb = skb;
+	nskb = NULL;
+
+	/* send using vcmux encap if not yet known */
+	switch (priv->cur_encap) {
+	case FBXATM_EPPPOA_AUTODETECT:
+	case FBXATM_EPPPOA_VCMUX:
+		break;
+
+	case FBXATM_EPPPOA_LLC:
+	{
+		unsigned int headroom;
+
+		headroom = skb_headroom(skb);
+
+		if (headroom < sizeof(llc_ppp)) {
+			headroom += sizeof(llc_ppp);
+			nskb = skb_realloc_headroom(skb, headroom);
+			if (!nskb) {
+				dev_kfree_skb(skb);
+				return 1;
+			}
+			to_send_skb = nskb;
+		}
+
+		skb_push(to_send_skb, sizeof(llc_ppp));
+		memcpy(to_send_skb->data, llc_ppp, sizeof(llc_ppp));
+		break;
+	}
+	}
+
+	ret = fbxatm_send(priv->vcc, to_send_skb);
+	if (ret) {
+		/* packet was not sent, queue is full, free any newly
+		 * created skb */
+		if (nskb)
+			dev_kfree_skb(nskb);
+		else {
+			/* restore original skb if we altered it */
+			if (priv->cur_encap == FBXATM_EPPPOA_LLC)
+				skb_pull(skb, sizeof(llc_ppp));
+		}
+
+		/* suspend ppp output, will be woken up by
+		 * ppp_output_wakeup, we're called under ppp lock so
+		 * we can't race with tx done */
+		return 0;
+	}
+
+	/* packet was sent, if we sent a copy free the original */
+	if (nskb)
+		dev_kfree_skb(skb);
+
+	if (fbxatm_vcc_queue_full(priv->vcc))
+		ppp_output_stop(chan);
+
+	return 1;
+}
+
+static int ppp_ioctl(struct ppp_channel *chan, unsigned int cmd,
+		     unsigned long arg)
+{
+	struct fbxatm_pppoa_vcc *priv;
+	int ret;
+
+	priv = (struct fbxatm_pppoa_vcc *)chan->private;
+
+	switch (cmd) {
+	case PPPIOCGFLAGS:
+		ret = put_user(priv->flags, (int __user *)arg) ? -EFAULT : 0;
+		break;
+	case PPPIOCSFLAGS:
+		ret = get_user(priv->flags, (int __user *) arg) ? -EFAULT : 0;
+		break;
+	default:
+		ret = -ENOTTY;
+		break;
+	}
+	return ret;
+}
+
+static struct ppp_channel_ops fbxatm_pppoa_ppp_ops = {
+	.start_xmit = ppp_xmit,
+	.ioctl = ppp_ioctl,
+};
+
+/*
+ * find pppoa vcc from id
+ */
+static struct fbxatm_pppoa_vcc *
+__find_pppoa_vcc(const struct fbxatm_vcc_id *id)
+{
+	struct fbxatm_pppoa_vcc *priv;
+	int found;
+
+	/* find it */
+	found = 0;
+	list_for_each_entry(priv, &fbxatm_pppoa_vcc_list, next) {
+		if (priv->vcc->adev->ifindex != id->dev_idx ||
+		    priv->vcc->vpi != id->vpi ||
+		    priv->vcc->vci != id->vci)
+			continue;
+
+		found = 1;
+		break;
+	}
+
+	if (found)
+		return priv;
+	return NULL;
+}
+
+/*
+ * find pppoa vcc from socket
+ */
+static struct fbxatm_pppoa_vcc *
+__find_pppoa_vcc_from_socket(const struct socket *sock)
+{
+	struct fbxatm_pppoa_vcc *priv;
+	int found;
+
+	/* find it */
+	found = 0;
+	list_for_each_entry(priv, &fbxatm_pppoa_vcc_list, next) {
+		if (priv->sock != sock)
+			continue;
+
+		found = 1;
+		break;
+	}
+
+	if (found)
+		return priv;
+	return NULL;
+}
+
+/*
+ * bind to given vcc
+ */
+static int __bind_pppoa_vcc(const struct fbxatm_pppoa_vcc_params *params,
+			    struct socket *sock)
+{
+	struct fbxatm_pppoa_vcc *priv;
+	int ret;
+
+	/* sanity check */
+	switch (params->encap) {
+	case FBXATM_EPPPOA_AUTODETECT:
+	case FBXATM_EPPPOA_VCMUX:
+	case FBXATM_EPPPOA_LLC:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	memcpy(&priv->params, params, sizeof (*params));
+	priv->cur_encap = params->encap;
+
+	/* bind to vcc */
+	priv->vcc = fbxatm_bind_to_vcc(&params->id, FBXATM_VCC_USER_PPPOA);
+	if (IS_ERR(priv->vcc)) {
+		ret = PTR_ERR(priv->vcc);
+		goto fail;
+	}
+
+	fbxatm_set_uops(priv->vcc, &fbxatm_pppoa_vcc_uops, priv);
+	priv->chan.private = priv;
+	priv->chan.ops = &fbxatm_pppoa_ppp_ops;
+	priv->chan.mtu = priv->vcc->qos.max_sdu - PPP_HDRLEN;
+	priv->chan.hdrlen = 0;
+	priv->sock = sock;
+
+	if (priv->cur_encap != FBXATM_EPPPOA_VCMUX) {
+		/* assume worst case if vcmux is not forced */
+		priv->chan.mtu -= sizeof(llc_ppp);
+		priv->chan.hdrlen += sizeof(llc_ppp);
+	}
+
+	priv->chan.mtu -= priv->vcc->adev->tx_headroom;
+	priv->chan.hdrlen += priv->vcc->adev->tx_headroom;
+
+	ret = ppp_register_channel(&priv->chan);
+	if (ret)
+		goto fail_unbind;
+	list_add_tail(&priv->next, &fbxatm_pppoa_vcc_list);
+	return 0;
+
+fail_unbind:
+	fbxatm_unbind_vcc(priv->vcc);
+
+fail:
+	kfree(priv);
+	return ret;
+}
+
+/*
+ * bind to given vcc
+ */
+static int bind_pppoa_vcc(const struct fbxatm_pppoa_vcc_params *params,
+			  struct socket *sock)
+{
+	int ret;
+
+	mutex_lock(&fbxatm_pppoa_mutex);
+	ret = __bind_pppoa_vcc(params, sock);
+	mutex_unlock(&fbxatm_pppoa_mutex);
+	return ret;
+}
+
+/*
+ * unbind from given vcc
+ */
+static void __unbind_pppoa_vcc(struct fbxatm_pppoa_vcc *priv)
+{
+	ppp_unregister_channel(&priv->chan);
+	fbxatm_unbind_vcc(priv->vcc);
+	list_del(&priv->next);
+	kfree(priv);
+}
+
+/*
+ * unbind from given vcc
+ */
+static int unbind_pppoa_vcc(const struct fbxatm_pppoa_vcc_params *params)
+{
+	struct fbxatm_pppoa_vcc *priv;
+	int ret;
+
+	ret = 0;
+	mutex_lock(&fbxatm_pppoa_mutex);
+	priv = __find_pppoa_vcc(&params->id);
+	if (!priv)
+		ret = -ENOENT;
+	else
+		__unbind_pppoa_vcc(priv);
+	mutex_unlock(&fbxatm_pppoa_mutex);
+	return ret;
+}
+
+/*
+ * pppoa related ioctl handler
+ */
+static int fbxatm_pppoa_ioctl(struct socket *sock,
+			      unsigned int cmd, void __user *useraddr)
+{
+	int ret;
+
+	ret = 0;
+
+	switch (cmd) {
+	case FBXATM_PPPOA_IOCADD:
+	case FBXATM_PPPOA_IOCDEL:
+	{
+		struct fbxatm_pppoa_vcc_params params;
+
+		if (copy_from_user(&params, useraddr, sizeof(params)))
+			return -EFAULT;
+
+		if (cmd == FBXATM_PPPOA_IOCADD)
+			ret = bind_pppoa_vcc(&params, sock);
+		else
+			ret = unbind_pppoa_vcc(&params);
+		break;
+	}
+
+	case FBXATM_PPPOA_IOCGET:
+	{
+		struct fbxatm_pppoa_vcc_params params;
+		struct fbxatm_pppoa_vcc *priv;
+
+		if (copy_from_user(&params, useraddr, sizeof(params)))
+			return -EFAULT;
+
+		mutex_lock(&fbxatm_pppoa_mutex);
+		priv = __find_pppoa_vcc(&params.id);
+		if (!priv)
+			ret = -ENOENT;
+		else
+			memcpy(&params, &priv->params, sizeof (params));
+		mutex_unlock(&fbxatm_pppoa_mutex);
+
+		if (ret)
+			return ret;
+
+		if (copy_to_user(useraddr, &params, sizeof(params)))
+			return -EFAULT;
+		break;
+	}
+
+	case PPPIOCGCHAN:
+	case PPPIOCGUNIT:
+	{
+		struct fbxatm_pppoa_vcc *priv;
+		int value;
+
+		value = 0;
+
+		mutex_lock(&fbxatm_pppoa_mutex);
+		priv = __find_pppoa_vcc_from_socket(sock);
+		if (!priv)
+			ret = -ENOENT;
+		else {
+			if (cmd == PPPIOCGCHAN)
+				value = ppp_channel_index(&priv->chan);
+			else
+				value = ppp_unit_number(&priv->chan);
+		}
+		mutex_unlock(&fbxatm_pppoa_mutex);
+
+		if (ret)
+			return ret;
+
+		if (copy_to_user(useraddr, &value, sizeof(value)))
+			ret = -EFAULT;
+		break;
+	}
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+
+	return ret;
+}
+
+/*
+ * pppoa related release handler
+ */
+static void fbxatm_pppoa_release(struct socket *sock)
+{
+	struct fbxatm_pppoa_vcc *priv;
+
+	mutex_lock(&fbxatm_pppoa_mutex);
+	priv = __find_pppoa_vcc_from_socket(sock);
+	if (priv)
+		__unbind_pppoa_vcc(priv);
+	mutex_unlock(&fbxatm_pppoa_mutex);
+}
+
+static struct fbxatm_ioctl fbxatm_pppoa_ioctl_ops = {
+	.handler	= fbxatm_pppoa_ioctl,
+	.release	= fbxatm_pppoa_release,
+	.owner		= THIS_MODULE,
+};
+
+int __init fbxatm_pppoa_init(void)
+{
+	fbxatm_register_ioctl(&fbxatm_pppoa_ioctl_ops);
+	return 0;
+}
+
+void fbxatm_pppoa_exit(void)
+{
+	fbxatm_unregister_ioctl(&fbxatm_pppoa_ioctl_ops);
+}
diff -Nruw linux-2.6.39.4-fbx/net/fbxatm./fbxatm_priv.h linux-2.6.39.4-fbx/net/fbxatm/fbxatm_priv.h
--- linux-2.6.39.4-fbx/net/fbxatm./fbxatm_priv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/net/fbxatm/fbxatm_priv.h	2011-05-24 18:15:37.875793706 +0200
@@ -0,0 +1,67 @@
+#ifndef FBXATM_PRIV_H_
+#define FBXATM_PRIV_H_
+
+#include <linux/list.h>
+#include <linux/mutex.h>
+
+extern struct list_head fbxatm_dev_list;
+extern struct mutex fbxatm_mutex;
+
+int __init fbxatm_vcc_init(void);
+
+void fbxatm_vcc_exit(void);
+
+void __fbxatm_free_device(struct fbxatm_dev *adev);
+
+int __init fbxatm_2684_init(void);
+
+void fbxatm_2684_exit(void);
+
+/*
+ * pppoa
+ */
+#ifdef CONFIG_PPP
+int __init fbxatm_pppoa_init(void);
+
+void fbxatm_pppoa_exit(void);
+#else
+static inline int fbxatm_pppoa_init(void) { return 0; };
+static inline void fbxatm_pppoa_exit(void) { };
+#endif
+
+/*
+ * procfs stuff
+ */
+int fbxatm_proc_dev_register(struct fbxatm_dev *dev);
+
+void fbxatm_proc_dev_deregister(struct fbxatm_dev *dev);
+
+struct proc_dir_entry *fbxatm_proc_misc_register(const char *path);
+
+void fbxatm_proc_misc_deregister(const char *path);
+
+int __init fbxatm_procfs_init(void);
+
+void fbxatm_procfs_exit(void);
+
+
+/*
+ * sysfs stuff
+ */
+int __init fbxatm_sysfs_init(void);
+
+void fbxatm_sysfs_exit(void);
+
+void fbxatm_dev_change_sysfs(struct fbxatm_dev *adev);
+
+int fbxatm_register_dev_sysfs(struct fbxatm_dev *adev);
+
+void fbxatm_unregister_dev_sysfs(struct fbxatm_dev *adev);
+
+
+/*
+ * crc10
+ */
+u16 crc10(u16 crc, const u8 *buffer, size_t len);
+
+#endif /* !FBXATM_PRIV_H_ */
diff -Nruw linux-2.6.39.4-fbx/net/fbxatm./fbxatm_procfs.c linux-2.6.39.4-fbx/net/fbxatm/fbxatm_procfs.c
--- linux-2.6.39.4-fbx/net/fbxatm./fbxatm_procfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/net/fbxatm/fbxatm_procfs.c	2011-06-20 17:00:14.296084288 +0200
@@ -0,0 +1,340 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/fbxatm_dev.h>
+#include <net/net_namespace.h>
+#include "fbxatm_priv.h"
+
+static struct proc_dir_entry *fbxatm_proc_root;
+
+/*
+ * /proc/net/atm/vcc
+ */
+static int vcc_seq_show(struct seq_file *seq, void *v)
+{
+	struct fbxatm_vcc *vcc;
+
+	if (v == (void *)SEQ_START_TOKEN) {
+		seq_printf(seq, "%s",
+			   "Itf.VPI.VCI USER TC MaxSDU  RX TX  RXAAL5 "
+			   "TXAAL5\n");
+		return 0;
+	}
+
+	vcc = (struct fbxatm_vcc *)v;
+	seq_printf(seq, "%d.%u.%u %d ", vcc->adev->ifindex,
+		   vcc->vpi, vcc->vci, vcc->user);
+	seq_printf(seq, "%u %u ", vcc->qos.traffic_class, vcc->qos.max_sdu);
+	seq_printf(seq, "%lu %lu  %lu %lu\n",
+		   vcc->stats.rx_bytes,
+		   vcc->stats.tx_bytes,
+		   vcc->stats.rx_aal5,
+		   vcc->stats.tx_aal5);
+	return 0;
+}
+
+static void *vcc_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	struct fbxatm_dev *adev;
+	struct fbxatm_vcc *tvcc, *vcc;
+	int count;
+
+	mutex_lock(&fbxatm_mutex);
+
+	if (!*pos)
+		return SEQ_START_TOKEN;
+
+	count = 1;
+	tvcc = NULL;
+	list_for_each_entry(adev, &fbxatm_dev_list, next) {
+		list_for_each_entry(vcc, &adev->vcc_list, next) {
+			if (count == *pos) {
+				tvcc = vcc;
+				break;
+			}
+			count++;
+		}
+	}
+
+	return tvcc;
+}
+
+static void *vcc_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	struct fbxatm_dev *adev;
+	struct fbxatm_vcc *last_vcc, *vcc, *tvcc;
+
+	if (v == (void *)SEQ_START_TOKEN) {
+		if (list_empty(&fbxatm_dev_list))
+			return NULL;
+		adev = list_entry(fbxatm_dev_list.next, struct fbxatm_dev,
+				  next);
+		last_vcc = NULL;
+	} else {
+		last_vcc = (struct fbxatm_vcc *)v;
+		adev = last_vcc->adev;
+	}
+
+	tvcc = NULL;
+	list_for_each_entry_continue(adev, &fbxatm_dev_list, next) {
+
+		if (last_vcc && last_vcc->adev == adev) {
+			vcc = last_vcc;
+			list_for_each_entry_continue(vcc, &adev->vcc_list,
+						     next) {
+				tvcc = vcc;
+				break;
+			}
+		} else {
+			list_for_each_entry(vcc, &adev->vcc_list, next) {
+				tvcc = vcc;
+				break;
+			}
+		}
+	}
+
+	if (tvcc)
+		(*pos)++;
+	return tvcc;
+}
+
+static void vcc_seq_stop(struct seq_file *seq, void *v)
+{
+	mutex_unlock(&fbxatm_mutex);
+}
+
+static const struct seq_operations vcc_seq_ops = {
+	.start		= vcc_seq_start,
+	.next		= vcc_seq_next,
+	.stop		= vcc_seq_stop,
+	.show		= vcc_seq_show,
+};
+
+static int vcc_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &vcc_seq_ops);
+}
+
+static const struct file_operations vcc_seq_fops = {
+	.open		= vcc_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+/*
+ * /proc/net/atm/dev
+ */
+static int adev_seq_show(struct seq_file *seq, void *v)
+{
+	struct fbxatm_dev *adev;
+
+	if (v == (void *)SEQ_START_TOKEN) {
+		seq_printf(seq, "%s",
+			   "Itf  RX TX  RXAAL5 TXAAL5  RXF4OAM TXF4OAM  "
+			   "RXF5OAM TXF5OAM  RXBADOAM RXBADLLIDOAM "
+			   "RXOTHEROAM RXDROPPED TXDROPNOLINK\n");
+		return 0;
+	}
+
+	adev = (struct fbxatm_dev *)v;
+	seq_printf(seq, "%d  %lu %lu  %lu %lu  ",
+		   adev->ifindex,
+		   adev->stats.rx_bytes,
+		   adev->stats.tx_bytes,
+		   adev->stats.rx_aal5,
+		   adev->stats.tx_aal5);
+
+	seq_printf(seq, "%lu %lu  %lu %lu  %lu %lu %lu %lu %lu\n",
+		   adev->stats.rx_f4_oam,
+		   adev->stats.tx_f4_oam,
+
+		   adev->stats.rx_f5_oam,
+		   adev->stats.tx_f5_oam,
+
+		   adev->stats.rx_bad_oam,
+		   adev->stats.rx_bad_llid_oam,
+		   adev->stats.rx_other_oam,
+		   adev->stats.rx_dropped,
+		   adev->stats.tx_drop_nolink);
+	return 0;
+}
+
+static void *adev_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	struct fbxatm_dev *adev, *tadev;
+	int count;
+
+	mutex_lock(&fbxatm_mutex);
+
+	if (!*pos)
+		return SEQ_START_TOKEN;
+
+	count = 1;
+	tadev = NULL;
+	list_for_each_entry(adev, &fbxatm_dev_list, next) {
+		if (count == *pos) {
+			tadev = adev;
+			break;
+		}
+		count++;
+	}
+
+	return tadev;
+}
+
+static void *adev_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	struct fbxatm_dev *adev, *tadev;
+
+	if (v == (void *)SEQ_START_TOKEN) {
+		if (list_empty(&fbxatm_dev_list))
+			return NULL;
+		adev = list_entry(fbxatm_dev_list.next, struct fbxatm_dev,
+				  next);
+	} else
+		adev = (struct fbxatm_dev *)v;
+
+	tadev = NULL;
+	list_for_each_entry_continue(adev, &fbxatm_dev_list, next) {
+		tadev = adev;
+		break;
+	}
+
+	if (tadev)
+		(*pos)++;
+	return tadev;
+}
+
+static void adev_seq_stop(struct seq_file *seq, void *v)
+{
+	mutex_unlock(&fbxatm_mutex);
+}
+
+static const struct seq_operations adev_seq_ops = {
+	.start		= adev_seq_start,
+	.next		= adev_seq_next,
+	.stop		= adev_seq_stop,
+	.show		= adev_seq_show,
+};
+
+static int adev_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &adev_seq_ops);
+}
+
+static const struct file_operations adev_seq_fops = {
+	.open		= adev_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+
+/*
+ * create device private entry in proc
+ */
+int fbxatm_proc_dev_register(struct fbxatm_dev *adev)
+{
+	adev->dev_proc_entry = proc_mkdir(adev->name, fbxatm_proc_root);
+	if (!adev->dev_proc_entry)
+		return 1;
+	return 0;
+}
+
+
+void fbxatm_proc_dev_deregister(struct fbxatm_dev *adev)
+{
+	remove_proc_entry(adev->name, fbxatm_proc_root);
+}
+
+/*
+ * create misc private entry in proc
+ */
+struct proc_dir_entry *fbxatm_proc_misc_register(const char *path)
+{
+	return proc_mkdir(path, fbxatm_proc_root);
+}
+
+void fbxatm_proc_misc_deregister(const char *path)
+{
+	remove_proc_entry(path, fbxatm_proc_root);
+}
+
+/*
+ * list of proc entries for fbxatm
+ */
+static struct fbxatm_proc_entry {
+	char *name;
+	const struct file_operations *proc_fops;
+	struct proc_dir_entry *dirent;
+
+} fbxatm_proc_entries[] = {
+	{
+		.name = "dev",
+		.proc_fops = &adev_seq_fops,
+	},
+	{
+		.name = "vcc",
+		.proc_fops = &vcc_seq_fops,
+	},
+};
+
+static void fbxatm_remove_proc(void)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(fbxatm_proc_entries); i++) {
+		struct fbxatm_proc_entry *e;
+
+		e = &fbxatm_proc_entries[i];
+
+		if (!e->dirent)
+			continue;
+		remove_proc_entry(e->name, fbxatm_proc_root);
+		e->dirent = NULL;
+	}
+
+	proc_net_remove(&init_net, "fbxatm");
+}
+
+int __init fbxatm_procfs_init(void)
+{
+	unsigned int i;
+	int ret;
+
+	fbxatm_proc_root = proc_net_mkdir(&init_net, "fbxatm",
+					  init_net.proc_net);
+	if (!fbxatm_proc_root) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(fbxatm_proc_entries); i++) {
+		struct proc_dir_entry *dirent;
+		struct fbxatm_proc_entry *e;
+
+		e = &fbxatm_proc_entries[i];
+
+		dirent = create_proc_entry(e->name, S_IRUGO, fbxatm_proc_root);
+		if (!dirent) {
+			ret = -ENOMEM;
+			goto err;
+		}
+		dirent->proc_fops = e->proc_fops;
+		e->dirent = dirent;
+	}
+
+	return 0;
+
+err:
+	if (fbxatm_proc_root)
+		fbxatm_remove_proc();
+	return ret;
+}
+
+void fbxatm_procfs_exit(void)
+{
+	fbxatm_remove_proc();
+}
diff -Nruw linux-2.6.39.4-fbx/net/fbxatm./fbxatm_remote.c linux-2.6.39.4-fbx/net/fbxatm/fbxatm_remote.c
--- linux-2.6.39.4-fbx/net/fbxatm./fbxatm_remote.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/net/fbxatm/fbxatm_remote.c	2011-06-20 17:00:14.296084288 +0200
@@ -0,0 +1,812 @@
+#include <linux/module.h>
+#include <linux/fbxatm.h>
+#include <linux/fbxatm_dev.h>
+#include <linux/fbxatm_remote.h>
+#include <asm/unaligned.h>
+
+#define PFX		"fbxatm_remote: "
+#define MAX_PORTS	64
+#define MAX_RETRANS	10
+#define RETRANS_TIMER	(HZ / 3)
+
+struct fbxatm_remote_ctx;
+
+struct fbxatm_remote_sock {
+	spinlock_t			lock;
+	struct fbxatm_remote_sockaddr	addr;
+
+	struct timer_list		retrans_timer;
+	unsigned int			retrans_count;
+
+	struct sk_buff			*pending;
+
+	/* 1 for output */
+	int				direction;
+
+	/* wait ack for output, send ack for input */
+	int				has_ack;
+
+	u8				seq;
+
+	struct fbxatm_remote_ctx	*ctx;
+	struct list_head		next;
+};
+
+struct fbxatm_remote_ctx {
+	spinlock_t			lock;
+	int				dead;
+
+	struct net_device		*netdev;
+	u8				remote_mac[ETH_ALEN];
+	u32				session_id;
+
+	struct fbxatm_remote_sock	*socks_per_lport[MAX_PORTS];
+	struct sk_buff			*pending_zero_ack;
+
+	void				(*timeout_cb)(void *priv);
+	void				*priv;
+
+	struct list_head		next;
+};
+
+static struct list_head ctx_list;
+static DEFINE_SPINLOCK(ctx_list_lock);
+static void (*unknown_cb)(struct net_device *,
+			  struct sk_buff *);
+
+unsigned int fbxatm_remote_headroom(struct fbxatm_remote_ctx *ctx)
+{
+	return sizeof (struct fbxatm_remote_hdr) +
+		ctx->netdev->hard_header_len + ctx->netdev->needed_headroom;
+}
+
+EXPORT_SYMBOL(fbxatm_remote_headroom);
+
+/*
+ * allocate skb with enough headroom for header
+ */
+struct sk_buff *fbxatm_remote_alloc_skb(struct fbxatm_remote_ctx *ctx,
+					unsigned int size)
+{
+	struct sk_buff *skb;
+	unsigned int hroom_size;
+
+	hroom_size = fbxatm_remote_headroom(ctx);
+	skb = dev_alloc_skb(hroom_size + size);
+	if (!skb)
+		return NULL;
+	skb_reserve(skb, hroom_size);
+	return skb;
+}
+
+EXPORT_SYMBOL(fbxatm_remote_alloc_skb);
+
+/*
+ * return sock addr
+ */
+void fbxatm_remote_sock_getaddr(struct fbxatm_remote_sock *sock,
+				struct fbxatm_remote_sockaddr *addr)
+{
+	memcpy(addr, &sock->addr, sizeof (*addr));
+}
+
+EXPORT_SYMBOL(fbxatm_remote_sock_getaddr);
+
+/*
+ * socket retrans timer callback
+ */
+static void sock_timer(unsigned long data)
+{
+	struct fbxatm_remote_sock *sock;
+	struct sk_buff *skb;
+
+	sock = (struct fbxatm_remote_sock *)data;
+
+	spin_lock_bh(&sock->ctx->lock);
+	spin_lock(&sock->lock);
+
+	if (!sock->addr.infinite_retry && sock->retrans_count >= MAX_RETRANS) {
+		printk(KERN_ERR PFX "retrans max reached\n");
+		sock->ctx->dead = 1;
+		dev_kfree_skb(sock->pending);
+		sock->pending = NULL;
+		if (sock->ctx->timeout_cb)
+			sock->ctx->timeout_cb(sock->ctx->priv);
+		spin_unlock(&sock->lock);
+		spin_unlock_bh(&sock->ctx->lock);
+		return;
+	}
+
+	sock->retrans_count++;
+	sock->retrans_timer.expires = jiffies + RETRANS_TIMER;
+
+	skb = skb_clone(sock->pending, GFP_ATOMIC);
+	if (skb)
+		dev_queue_xmit(skb);
+	add_timer(&sock->retrans_timer);
+
+	spin_unlock(&sock->lock);
+	spin_unlock_bh(&sock->ctx->lock);
+}
+
+/*
+ * append header for given socket
+ */
+static int append_tx_header(struct fbxatm_remote_sock *sock,
+			    struct sk_buff *skb)
+{
+	struct fbxatm_remote_hdr *hdr;
+	unsigned int needed;
+
+	needed = skb->dev->hard_header_len + skb->dev->needed_headroom +
+		sizeof (*hdr);
+
+	if (unlikely(skb_headroom(skb) < needed)) {
+		if (net_ratelimit())
+			printk(KERN_WARNING PFX "headroom too small %d < %d\n",
+			       skb_headroom(skb), needed);
+	}
+
+	if (skb_cow_head(skb, needed))
+		return 1;
+
+	hdr = (struct fbxatm_remote_hdr *)skb_push(skb, sizeof (*hdr));
+	skb_set_network_header(skb, 0);
+
+	put_unaligned(htonl(FBXATM_REMOTE_MAGIC), &hdr->magic);
+	if (sock->direction == 1) {
+		/* output */
+		hdr->flags = 0;
+	} else {
+		/* input */
+		hdr->flags = FBXATM_RFLAGS_ACK;
+	}
+	hdr->seq = sock->seq;
+	put_unaligned(htons(skb->len), &hdr->len);
+	put_unaligned(sock->addr.lport, &hdr->sport);
+	put_unaligned(sock->addr.dport, &hdr->dport);
+
+	put_unaligned(sock->addr.mtype, &hdr->mtype);
+	put_unaligned(sock->ctx->session_id, &hdr->session_id);
+
+	skb->protocol = htons(ETH_P_FBXATM_REMOTE);
+	if (dev_hard_header(skb, skb->dev, ETH_P_FBXATM_REMOTE,
+			    sock->ctx->remote_mac, NULL, skb->len) < 0)
+		return 1;
+
+	return 0;
+}
+
+/*
+ * purge socket send queue, advance next sequence
+ */
+void fbxatm_remote_sock_purge(struct fbxatm_remote_sock *sock)
+{
+	spin_lock_bh(&sock->lock);
+	if (sock->pending) {
+		del_timer_sync(&sock->retrans_timer);
+		dev_kfree_skb(sock->pending);
+		sock->pending = NULL;
+		sock->seq++;
+	}
+	spin_unlock_bh(&sock->lock);
+}
+
+EXPORT_SYMBOL(fbxatm_remote_sock_purge);
+
+/*
+ * check if tx is pending on socket
+ */
+int fbxatm_remote_sock_pending(struct fbxatm_remote_sock *sock)
+{
+	int ret;
+
+	spin_lock_bh(&sock->lock);
+	ret = sock->pending ? 1 : 0;
+	spin_unlock_bh(&sock->lock);
+	return ret;
+}
+
+EXPORT_SYMBOL(fbxatm_remote_sock_pending);
+
+/*
+ * send skb on socket
+ */
+int fbxatm_remote_sock_send(struct fbxatm_remote_sock *sock,
+			    struct sk_buff *skb)
+{
+	BUG_ON(sock->direction == 0);
+
+	spin_lock_bh(&sock->lock);
+	skb->dev = sock->ctx->netdev;
+
+	if (append_tx_header(sock, skb)) {
+		spin_unlock_bh(&sock->lock);
+		dev_kfree_skb(skb);
+		return 1;
+	}
+
+	if (unlikely(sock->ctx->dead)) {
+		spin_unlock_bh(&sock->lock);
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	/* start retrans timer if needed */
+	if (sock->has_ack) {
+		if (sock->pending) {
+			printk(KERN_ERR PFX "sock already has tx pending\n");
+			spin_unlock_bh(&sock->lock);
+			dev_kfree_skb(skb);
+			return 1;
+		}
+
+		sock->pending = skb_clone(skb, GFP_ATOMIC);
+		if (sock->pending) {
+			sock->retrans_count = 0;
+			sock->retrans_timer.expires = jiffies + RETRANS_TIMER;
+			add_timer(&sock->retrans_timer);
+		}
+	}
+
+	spin_unlock_bh(&sock->lock);
+	dev_queue_xmit(skb);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(fbxatm_remote_sock_send);
+
+/*
+ * send ack skb on socket
+ */
+int fbxatm_remote_sock_send_ack(struct fbxatm_remote_sock *sock,
+				struct sk_buff *skb)
+{
+	BUG_ON(sock->direction == 1);
+
+	spin_lock_bh(&sock->lock);
+
+	skb->dev = sock->ctx->netdev;
+
+	if (append_tx_header(sock, skb)) {
+		spin_unlock_bh(&sock->lock);
+		dev_kfree_skb(skb);
+		return 1;
+	}
+
+	if (unlikely(sock->ctx->dead)) {
+		spin_unlock_bh(&sock->lock);
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	skb->dev = sock->ctx->netdev;
+	sock->pending = skb_clone(skb, GFP_ATOMIC);
+	spin_unlock_bh(&sock->lock);
+	dev_queue_xmit(skb);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(fbxatm_remote_sock_send_ack);
+
+/*
+ * send raw ack
+ */
+int fbxatm_remote_sock_send_raw_ack(struct fbxatm_remote_ctx *ctx,
+				    struct net_device *dev,
+				    u8 *remote_mac,
+				    struct fbxatm_remote_hdr *hdr,
+				    struct sk_buff *ack)
+{
+	struct fbxatm_remote_hdr *ack_hdr;
+
+	if (skb_cow_head(ack, sizeof (*ack_hdr))) {
+		dev_kfree_skb(ack);
+		return 1;
+	}
+
+	ack_hdr = (struct fbxatm_remote_hdr *)skb_push(ack, sizeof (*hdr));
+	skb_set_network_header(ack, 0);
+
+	put_unaligned(htonl(FBXATM_REMOTE_MAGIC), &ack_hdr->magic);
+	ack_hdr->flags = FBXATM_RFLAGS_ACK;
+	ack_hdr->seq = hdr->seq;
+
+	put_unaligned(htons(ack->len), &ack_hdr->len);
+	put_unaligned(hdr->dport, &ack_hdr->sport);
+	put_unaligned(hdr->sport, &ack_hdr->dport);
+	put_unaligned(hdr->mtype, &ack_hdr->mtype);
+	put_unaligned(hdr->session_id, &ack_hdr->session_id);
+
+	ack->dev = dev;
+
+	if (dev_hard_header(ack, dev, ETH_P_FBXATM_REMOTE,
+			    remote_mac, NULL, ack->len) < 0) {
+		dev_kfree_skb(ack);
+		return 1;
+	}
+
+	if (hdr->dport == 0) {
+		kfree(ctx->pending_zero_ack);
+		ctx->pending_zero_ack = skb_clone(ack, GFP_ATOMIC);
+	}
+
+	if (dev_queue_xmit(ack))
+		return 1;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(fbxatm_remote_sock_send_raw_ack);
+
+/*
+ * handle input data on 'in' direction socket
+ */
+static void __in_sock_rcv(struct fbxatm_remote_sock *sock,
+			  struct sk_buff *skb,
+			  struct fbxatm_remote_hdr *hdr)
+{
+	struct sk_buff *ack;
+	int ret;
+
+	spin_lock(&sock->lock);
+
+	if (sock->has_ack) {
+		u8 expected_seq;
+
+		/* check for duplicate seq  */
+		if (hdr->seq == sock->seq) {
+
+			/* got last packet again, ack has been
+			 * lost, send it again if we have it */
+			if (sock->pending) {
+				ack = skb_clone(sock->pending, GFP_ATOMIC);
+				if (ack)
+					dev_queue_xmit(ack);
+			}
+
+			spin_unlock(&sock->lock);
+			dev_kfree_skb(skb);
+			return;
+		}
+
+		expected_seq = sock->seq + 1;
+		if (hdr->seq != expected_seq) {
+			/* lost sync */
+			spin_unlock(&sock->lock);
+			dev_kfree_skb(skb);
+			return;
+		}
+
+		/* about to accept new packet, free any pending ack */
+		dev_kfree_skb(sock->pending);
+		sock->pending = NULL;
+
+		sock->seq = hdr->seq;
+
+		/* set sock dport to last receive packet to send
+		 * correct ack */
+		sock->addr.dport = hdr->sport;
+	}
+
+	/* deliver packet to socket */
+	ret = sock->addr.deliver(sock->addr.priv, skb, &ack);
+
+	if (!sock->has_ack || !ret) {
+		/* don't send ack now */
+		spin_unlock(&sock->lock);
+		return;
+	}
+
+	if (!ack) {
+		/* generate empty ack */
+		ack = fbxatm_remote_alloc_skb(sock->ctx, 0);
+		if (!ack) {
+			spin_unlock(&sock->lock);
+			return;
+		}
+	}
+
+	ack->dev = sock->ctx->netdev;
+
+	if (append_tx_header(sock, ack)) {
+		spin_unlock(&sock->lock);
+		dev_kfree_skb(ack);
+		return;
+	}
+
+	sock->pending = ack;
+
+	/* send ack now */
+	ack = skb_clone(sock->pending, GFP_ATOMIC);
+	spin_unlock(&sock->lock);
+
+	if (ack)
+		dev_queue_xmit(ack);
+}
+
+/*
+ * handle data on 'out' direction socket
+ */
+static void __out_sock_rcv(struct fbxatm_remote_sock *sock,
+			   struct sk_buff *skb,
+			   struct fbxatm_remote_hdr *hdr)
+{
+	if (!sock->has_ack) {
+		dev_kfree_skb(skb);
+		printk(KERN_ERR PFX "ack for non ack sock\n");
+		return;
+	}
+
+	spin_lock(&sock->lock);
+
+	/* check if ack if for last sent seq */
+	if (hdr->seq != sock->seq) {
+		spin_unlock(&sock->lock);
+		dev_kfree_skb(skb);
+		return;
+	}
+
+	/* make sure we're expecting it */
+	if (!sock->pending) {
+		spin_unlock(&sock->lock);
+		dev_kfree_skb(skb);
+		return;
+	}
+
+	del_timer_sync(&sock->retrans_timer);
+	dev_kfree_skb(sock->pending);
+	sock->pending = NULL;
+	sock->seq++;
+
+	if (sock->addr.response)
+		sock->addr.response(sock->addr.priv, skb);
+	else
+		dev_kfree_skb(skb);
+
+	spin_unlock(&sock->lock);
+}
+
+/*
+ * fbxatm ethertype rx callback
+ */
+static int fbxatm_rcv(struct sk_buff *skb, struct net_device *dev,
+		      struct packet_type *pt, struct net_device *orig_dev)
+{
+	struct fbxatm_remote_hdr *hdr;
+	struct fbxatm_remote_ctx *ctx;
+	int found;
+	unsigned int len;
+	u16 port;
+
+	if (!netif_running(dev)) {
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	skb = skb_unshare(skb, GFP_ATOMIC);
+	if (!skb)
+		return 0;
+
+	/* decode fbxatm ethertype */
+	if (!pskb_may_pull(skb, sizeof (*hdr))) {
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	hdr = (struct fbxatm_remote_hdr *)skb_network_header(skb);
+	if (ntohl(hdr->magic) != FBXATM_REMOTE_MAGIC) {
+		if (net_ratelimit())
+			printk(KERN_ERR PFX "bad fbxatm remote magic: %08x\n",
+			       ntohl(hdr->magic));
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	/* check len */
+	len = ntohs(hdr->len);
+	if (skb->len < len) {
+		if (net_ratelimit())
+			printk(KERN_ERR PFX "short packet\n");
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	/* trim skb to correct size */
+	if (pskb_trim(skb, len)) {
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	port = ntohs(hdr->dport);
+	if (port >= MAX_PORTS) {
+		dev_kfree_skb(skb);
+		printk(KERN_ERR PFX "bad port %u\n", port);
+		return 0;
+	}
+
+	/* remove header */
+	skb_set_network_header(skb, 0);
+	__skb_pull(skb, sizeof (*hdr));
+	skb_set_transport_header(skb, 0);
+
+	/* find context by mac/session id */
+	found = 0;
+	spin_lock_bh(&ctx_list_lock);
+	list_for_each_entry(ctx, &ctx_list, next) {
+		struct ethhdr *eth;
+		struct fbxatm_remote_sock *sock;
+		int is_ack;
+
+		eth = eth_hdr(skb);
+		if (memcmp(eth->h_source, ctx->remote_mac, ETH_ALEN)) {
+			spin_unlock(&ctx->lock);
+			continue;
+		}
+
+		if (hdr->session_id != ctx->session_id)
+			continue;
+
+		spin_lock(&ctx->lock);
+
+		if (unlikely(ctx->dead)) {
+			spin_unlock(&ctx->lock);
+			continue;
+		}
+
+		/* found context, find socket by port */
+		found = 1;
+
+		/* special case for port 0, in case ack is lost */
+		if (port == 0 && ctx->pending_zero_ack) {
+			struct sk_buff *ack;
+			ack = skb_clone(ctx->pending_zero_ack, GFP_ATOMIC);
+			if (ack)
+				dev_queue_xmit(ack);
+			spin_unlock(&ctx->lock);
+			break;
+		}
+
+		sock = ctx->socks_per_lport[port];
+		if (!sock) {
+			printk(KERN_ERR PFX "context but no socket for "
+			       "port: %u\n", port);
+			spin_unlock(&ctx->lock);
+			break;
+		}
+
+		if (hdr->mtype != sock->addr.mtype) {
+			printk(KERN_ERR PFX "incorrect mtype for sock\n");
+			spin_unlock(&ctx->lock);
+			break;
+		}
+
+		/* check direction, we should only get ack for output
+		 * socket */
+		is_ack = (hdr->flags & FBXATM_RFLAGS_ACK) ? 1 : 0;
+		if (sock->direction ^ is_ack) {
+			printk(KERN_ERR PFX "incorrect ack value for sock\n");
+			spin_unlock(&ctx->lock);
+			break;
+		}
+
+		/* ok deliver */
+		if (sock->direction)
+			__out_sock_rcv(sock, skb, hdr);
+		else
+			__in_sock_rcv(sock, skb, hdr);
+
+		spin_unlock(&ctx->lock);
+		spin_unlock_bh(&ctx_list_lock);
+		return 0;
+	}
+
+	spin_unlock_bh(&ctx_list_lock);
+
+	if (!found && unknown_cb)
+		unknown_cb(dev, skb);
+	else
+		dev_kfree_skb(skb);
+
+	return 0;
+}
+
+void fbxatm_remote_set_unknown_cb(void (*cb)(struct net_device *,
+					     struct sk_buff *))
+{
+	unknown_cb = cb;
+}
+
+EXPORT_SYMBOL(fbxatm_remote_set_unknown_cb);
+
+/*
+ * allocate local port for socket
+ */
+static int __alloc_lport(struct fbxatm_remote_ctx *ctx,
+			 struct fbxatm_remote_sock *sock)
+{
+	int i;
+
+	for (i = 1; i < ARRAY_SIZE(ctx->socks_per_lport); i++) {
+		if (ctx->socks_per_lport[i])
+			continue;
+		sock->addr.lport = htons(i);
+		ctx->socks_per_lport[i] = sock;
+		return 0;
+	}
+	return -EADDRINUSE;
+}
+
+static struct fbxatm_remote_sock *sock_new(struct fbxatm_remote_sockaddr *addr)
+{
+	struct fbxatm_remote_sock *sock;
+
+	sock = kzalloc(sizeof (*sock), GFP_KERNEL);
+	if (!sock)
+		return NULL;
+	memcpy(&sock->addr, addr, sizeof (*addr));
+	init_timer(&sock->retrans_timer);
+	spin_lock_init(&sock->lock);
+	sock->retrans_timer.data = (unsigned long)sock;
+	sock->retrans_timer.function = sock_timer;
+	return sock;
+}
+
+struct fbxatm_remote_sock *
+fbxatm_remote_sock_connect(struct fbxatm_remote_ctx *ctx,
+			   struct fbxatm_remote_sockaddr *addr,
+			   int need_ack)
+{
+	struct fbxatm_remote_sock *sock;
+
+	sock = sock_new(addr);
+	if (!sock)
+		return NULL;
+
+	spin_lock_bh(&ctx->lock);
+	sock->ctx = ctx;
+	if (__alloc_lport(ctx, sock)) {
+		spin_unlock_bh(&ctx->lock);
+		kfree(sock);
+		return NULL;
+	}
+
+	sock->direction = 1;
+	sock->seq = 0;
+	sock->has_ack = need_ack;
+	spin_unlock_bh(&ctx->lock);
+
+	return sock;
+}
+
+EXPORT_SYMBOL(fbxatm_remote_sock_connect);
+
+struct fbxatm_remote_sock *
+fbxatm_remote_sock_bind(struct fbxatm_remote_ctx *ctx,
+			struct fbxatm_remote_sockaddr *addr,
+			int send_ack)
+{
+	struct fbxatm_remote_sock *sock;
+
+	sock = sock_new(addr);
+	if (!sock)
+		return NULL;
+
+	spin_lock_bh(&ctx->lock);
+	sock->ctx = ctx;
+	if (__alloc_lport(ctx, sock)) {
+		spin_unlock_bh(&ctx->lock);
+		kfree(sock);
+		return NULL;
+	}
+
+	sock->direction = 0;
+	sock->seq = ~0;
+	sock->has_ack = send_ack;
+	spin_unlock_bh(&ctx->lock);
+
+	return sock;
+}
+
+EXPORT_SYMBOL(fbxatm_remote_sock_bind);
+
+void fbxatm_remote_sock_close(struct fbxatm_remote_sock *sock)
+{
+	spin_lock_bh(&sock->ctx->lock);
+	if (sock->addr.lport)
+		sock->ctx->socks_per_lport[ntohs(sock->addr.lport)] = NULL;
+
+	spin_lock(&sock->lock);
+	del_timer_sync(&sock->retrans_timer);
+	dev_kfree_skb(sock->pending);
+	spin_unlock(&sock->lock);
+	spin_unlock_bh(&sock->ctx->lock);
+	kfree(sock);
+}
+
+EXPORT_SYMBOL(fbxatm_remote_sock_close);
+
+struct fbxatm_remote_ctx *fbxatm_remote_alloc_ctx(struct net_device *netdev,
+						  u8 *remote_mac,
+						  u32 session_id,
+						  void (*timeout)(void *priv),
+						  void *priv)
+{
+	struct fbxatm_remote_ctx *ctx;
+
+	ctx = kzalloc(sizeof (*ctx), GFP_KERNEL);
+	if (!ctx)
+		return NULL;
+	ctx->netdev = netdev;
+	spin_lock_init(&ctx->lock);
+	memcpy(ctx->remote_mac, remote_mac, ETH_ALEN);
+	ctx->session_id = session_id;
+	ctx->timeout_cb = timeout;
+	ctx->priv = priv;
+
+	spin_lock_bh(&ctx_list_lock);
+	list_add_tail(&ctx->next, &ctx_list);
+	spin_unlock_bh(&ctx_list_lock);
+
+	return ctx;
+}
+
+EXPORT_SYMBOL(fbxatm_remote_alloc_ctx);
+
+void fbxatm_remote_ctx_set_dead(struct fbxatm_remote_ctx *ctx)
+{
+	spin_lock_bh(&ctx->lock);
+	ctx->dead = 1;
+	spin_unlock_bh(&ctx->lock);
+}
+
+EXPORT_SYMBOL(fbxatm_remote_ctx_set_dead);
+
+void fbxatm_remote_free_ctx(struct fbxatm_remote_ctx *ctx)
+{
+	int i;
+
+	spin_lock_bh(&ctx_list_lock);
+	spin_lock(&ctx->lock);
+
+	for (i = 1; i < ARRAY_SIZE(ctx->socks_per_lport); i++) {
+		if (!ctx->socks_per_lport[i])
+			continue;
+		printk(KERN_ERR PFX "socket count is not 0\n");
+		spin_unlock(&ctx->lock);
+		spin_unlock_bh(&ctx_list_lock);
+		return;
+	}
+
+	kfree(ctx->pending_zero_ack);
+	list_del(&ctx->next);
+	spin_unlock(&ctx->lock);
+	spin_unlock_bh(&ctx_list_lock);
+	kfree(ctx);
+}
+
+EXPORT_SYMBOL(fbxatm_remote_free_ctx);
+
+static struct packet_type fbxatm_packet_type = {
+	.type	= __constant_htons(ETH_P_FBXATM_REMOTE),
+	.func	= fbxatm_rcv,
+};
+
+int fbxatm_remote_init(void)
+{
+	spin_lock_init(&ctx_list_lock);
+	INIT_LIST_HEAD(&ctx_list);
+	dev_add_pack(&fbxatm_packet_type);
+	return 0;
+}
+
+EXPORT_SYMBOL(fbxatm_remote_init);
+
+void fbxatm_remote_exit(void)
+{
+	dev_remove_pack(&fbxatm_packet_type);
+}
+
+EXPORT_SYMBOL(fbxatm_remote_exit);
diff -Nruw linux-2.6.39.4-fbx/net/fbxatm./fbxatm_remote_driver.c linux-2.6.39.4-fbx/net/fbxatm/fbxatm_remote_driver.c
--- linux-2.6.39.4-fbx/net/fbxatm./fbxatm_remote_driver.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/net/fbxatm/fbxatm_remote_driver.c	2011-06-15 18:56:45.975463255 +0200
@@ -0,0 +1,1123 @@
+/*
+ * "remote" driver for fbxatm, "connect" to a remote fbxatm stack in
+ * net stub mode and control its PHYs
+ *
+ * Copyright (C) 2009 Maxime Bizon <mbizon@freebox.fr>
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+
+#include "fbxatm_remote_driver.h"
+
+#define PFX	"fbxatm_remote_driver: "
+
+static struct list_head remote_dev_list;
+static DEFINE_SPINLOCK(remote_lock);
+
+/*
+ * request moving to dead state and schedule
+ */
+static void set_dying(struct driver_remote *priv)
+{
+	priv->want_die = 1;
+	schedule_delayed_work(&priv->fsm_work, 0);
+}
+
+/*
+ * socket deliver callback for vcc_rx socket
+ */
+static int vcc_rx_deliver(void *data, struct sk_buff *skb,
+			  struct sk_buff **ack)
+{
+	struct driver_remote_vcc *pvcc;
+
+	pvcc = (struct driver_remote_vcc *)data;
+	fbxatm_netifrx(pvcc->vcc, skb);
+	return 0;
+}
+
+/*
+ * socket deliver callback for vcc_qempty socket
+ */
+static int vcc_qempty_deliver(void *data, struct sk_buff *skb,
+			      struct sk_buff **ack)
+{
+	struct driver_remote_vcc *pvcc;
+	struct driver_remote *priv;
+
+	pvcc = (struct driver_remote_vcc *)data;
+	priv = pvcc->priv;
+
+	spin_lock(&priv->tx_lock);
+
+	if (pvcc->tx_pending) {
+		/* wait until we get tx ack */
+		pvcc->tx_got_qempty = 1;
+		goto send_ack;
+	}
+
+	/* report tx done event */
+	clear_bit(FBXATM_VCC_F_FULL, &pvcc->vcc->vcc_flags);
+	fbxatm_tx_done(pvcc->vcc);
+
+send_ack:
+	dev_kfree_skb(skb);
+	*ack = NULL;
+	spin_unlock(&priv->tx_lock);
+	/* send ack now */
+	return 1;
+}
+
+/*
+ * socket response callback for vcc_send socket, called with bh
+ * disabled
+ */
+static void vcc_send_response(void *data, struct sk_buff *skb)
+{
+	struct fbxatm_remote_vcc_send_ack *pkt_ack;
+	struct driver_remote_vcc *pvcc;
+	struct driver_remote *priv;
+
+	pvcc = (struct driver_remote_vcc *)data;
+	priv = pvcc->priv;
+
+	spin_lock(&priv->tx_lock);
+
+	if (unlikely(!pvcc->tx_pending)) {
+		printk(KERN_ERR PFX "send response while no tx pending\n");
+		goto out;
+	}
+
+	if (!pskb_may_pull(skb, sizeof (*pkt_ack))) {
+		printk(KERN_ERR PFX "bad vcc send ack\n");
+		goto out;
+	}
+
+	pvcc->tx_pending = 0;
+
+	pkt_ack = (struct fbxatm_remote_vcc_send_ack *)skb->data;
+	if (pkt_ack->full) {
+		/* qempty will wake us up later, but maybe we got it
+		 * already ? */
+		if (!pvcc->tx_got_qempty)
+			goto out;
+	}
+
+	/* wake up queue */
+	clear_bit(FBXATM_VCC_F_FULL, &pvcc->vcc->vcc_flags);
+	fbxatm_tx_done(pvcc->vcc);
+
+out:
+	spin_unlock(&priv->tx_lock);
+	dev_kfree_skb(skb);
+}
+
+/*
+ * fbxatm request to send aal5 on given vcc, called with bh disabled
+ */
+static int remote_send(struct fbxatm_vcc *vcc, struct sk_buff *skb)
+{
+	struct driver_remote_vcc *pvcc;
+	struct driver_remote *priv;
+
+	pvcc = vcc->dev_priv;
+	priv = pvcc->priv;
+
+	spin_lock(&priv->tx_lock);
+	if (priv->state != RSTATE_S_ACTIVE)
+		goto drop;
+
+	if (test_bit(FBXATM_VCC_F_FULL, &vcc->vcc_flags)) {
+		spin_unlock(&priv->tx_lock);
+		/* return queue full */
+		return 1;
+	}
+
+	if (fbxatm_remote_sock_send(pvcc->vcc_send_sock, skb)) {
+		/* packet has been dropped */
+		spin_unlock(&priv->tx_lock);
+		return 0;
+	}
+
+	set_bit(FBXATM_VCC_F_FULL, &vcc->vcc_flags);
+	pvcc->tx_pending = 1;
+	pvcc->tx_got_qempty = 0;
+
+	spin_unlock(&priv->tx_lock);
+	return 0;
+
+drop:
+	spin_unlock(&priv->tx_lock);
+	dev_kfree_skb(skb);
+	return 0;
+}
+
+/*
+ * sleep until we get an ack for sockets using wq
+ */
+static int __wait_ack(struct driver_remote *priv)
+{
+	wait_event(priv->wq, priv->wq_res != 0 ||
+		   priv->state != RSTATE_S_ACTIVE);
+
+	if (priv->wq_res == 2 || priv->state != RSTATE_S_ACTIVE) {
+		/* timeout or device will die soon */
+		return -EIO;
+	}
+
+	return 0;
+}
+
+/*
+ * fbxatm callback to send oam cell
+ */
+static int remote_send_oam(struct fbxatm_dev *adev,
+			   struct fbxatm_oam_cell *cell)
+{
+	struct driver_remote *priv;
+	struct sk_buff *skb;
+	int ret;
+
+	priv = fbxatm_dev_priv(adev);
+	mutex_lock(&priv->mutex);
+
+	if (priv->state != RSTATE_S_ACTIVE) {
+		mutex_unlock(&priv->mutex);
+		return -ENODEV;
+	}
+
+	/* prepare outgoing packet */
+	skb = fbxatm_remote_alloc_skb(priv->remote_ctx,
+				      sizeof (cell->payload));
+	if (!skb) {
+		mutex_unlock(&priv->mutex);
+		kfree(cell);
+		return -ENOMEM;
+	}
+
+	memcpy(skb_put(skb, sizeof (cell->payload)), &cell->payload,
+	       sizeof (cell->payload));
+	kfree(cell);
+
+	/* send & wait for ack */
+	skb_queue_purge(&priv->wq_acks);
+	priv->wq_res = 0;
+
+	if (fbxatm_remote_sock_send(priv->dev_send_oam_sock, skb))
+		return -ENOMEM;
+
+	ret = __wait_ack(priv);
+	mutex_unlock(&priv->mutex);
+
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+/*
+ * fbxatm callback to open given vcc
+ */
+static int remote_vcc_open(struct fbxatm_vcc *vcc)
+{
+	struct fbxatm_remote_vcc_action *pkt;
+	struct fbxatm_remote_vcc_action_ack *pkt_ack;
+	struct sk_buff *skb, *ack;
+	struct fbxatm_remote_sockaddr addr;
+	struct driver_remote_vcc *pvcc;
+	struct driver_remote *priv;
+	int ret;
+
+	priv = fbxatm_dev_priv(vcc->adev);
+	mutex_lock(&priv->mutex);
+
+	if (priv->state != RSTATE_S_ACTIVE) {
+		mutex_unlock(&priv->mutex);
+		return -EIO;
+	}
+
+	/* allocate private vcc context */
+	pvcc = kzalloc(sizeof (*pvcc), GFP_KERNEL);
+	if (!pvcc) {
+		mutex_unlock(&priv->mutex);
+		return -ENOMEM;
+	}
+
+	pvcc->priv = priv;
+	pvcc->vcc = vcc;
+	vcc->dev_priv = pvcc;
+
+	/* open input sockets */
+	memset(&addr, 0, sizeof (addr));
+	addr.mtype = htonl(FBXATM_RMT_VCC_RX);
+	addr.priv = pvcc;
+	addr.deliver = vcc_rx_deliver;
+	pvcc->vcc_rx_sock = fbxatm_remote_sock_bind(priv->remote_ctx,
+						    &addr, 0);
+	if (!pvcc->vcc_rx_sock) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	memset(&addr, 0, sizeof (addr));
+	addr.mtype = htonl(FBXATM_RMT_VCC_QEMPTY);
+	addr.priv = pvcc;
+	addr.deliver = vcc_qempty_deliver;
+	pvcc->vcc_qempty_sock = fbxatm_remote_sock_bind(priv->remote_ctx,
+							&addr, 1);
+	if (!pvcc->vcc_qempty_sock) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	/* prepare outgoing packet */
+	skb = fbxatm_remote_alloc_skb(priv->remote_ctx,
+				      sizeof (*pkt));
+	if (!skb) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+	pkt = (struct fbxatm_remote_vcc_action *)skb_put(skb, sizeof (*pkt));
+	pkt->action = htonl(1);
+
+	fbxatm_remote_sock_getaddr(pvcc->vcc_rx_sock, &addr);
+	pkt->vcc_rx_port = addr.lport;
+
+	fbxatm_remote_sock_getaddr(pvcc->vcc_qempty_sock, &addr);
+	pkt->vcc_qempty_port = addr.lport;
+
+	pkt->vpi = htonl(vcc->vpi);
+	pkt->vci = htonl(vcc->vci);
+	pkt->traffic_class = htonl(vcc->qos.traffic_class);
+	pkt->max_sdu = htonl(vcc->qos.max_sdu);
+	pkt->max_buffered_pkt = htonl(vcc->qos.max_buffered_pkt);
+	pkt->priority = htonl(vcc->qos.priority);
+	pkt->rx_priority = htonl(vcc->qos.rx_priority);
+
+	/* send & wait for ack */
+	skb_queue_purge(&priv->wq_acks);
+	priv->wq_res = 0;
+
+	if (fbxatm_remote_sock_send(priv->vcc_action_sock, skb)) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	ret = __wait_ack(priv);
+
+	if (ret) {
+		/* timeout, device will die soon */
+		goto fail;
+	}
+
+	/* check ack */
+	ack = skb_dequeue(&priv->wq_acks);
+	if (!pskb_may_pull(ack, sizeof (*pkt_ack))) {
+		printk(KERN_ERR PFX "bad vcc action ack\n");
+		dev_kfree_skb(ack);
+		set_dying(priv);
+		ret = -EIO;
+		goto fail;
+	}
+
+	pkt_ack = (struct fbxatm_remote_vcc_action_ack *)ack->data;
+	if (pkt_ack->ret) {
+		printk(KERN_ERR PFX "remote vcc open failed\n");
+		dev_kfree_skb(ack);
+		set_dying(priv);
+		ret = -EIO;
+		goto fail;
+	}
+
+	pvcc->remote_id = pkt_ack->vcc_remote_id;
+
+	memset(&addr, 0, sizeof (addr));
+	addr.mtype = htonl(FBXATM_RMT_VCC_SEND);
+	addr.priv = pvcc;
+	addr.dport = pkt_ack->vcc_send_port;
+	addr.response = vcc_send_response;
+	pvcc->vcc_send_sock = fbxatm_remote_sock_connect(priv->remote_ctx,
+							 &addr, 1);
+	if (!pvcc->vcc_send_sock) {
+		dev_kfree_skb(ack);
+		set_dying(priv);
+		ret = -EIO;
+		goto fail;
+	}
+
+	dev_kfree_skb(ack);
+	list_add(&pvcc->next, &priv->pvcc_list);
+	mutex_unlock(&priv->mutex);
+	return 0;
+
+fail:
+	if (pvcc->vcc_qempty_sock)
+		fbxatm_remote_sock_close(pvcc->vcc_qempty_sock);
+	if (pvcc->vcc_rx_sock)
+		fbxatm_remote_sock_close(pvcc->vcc_rx_sock);
+	kfree(pvcc);
+	mutex_unlock(&priv->mutex);
+	return ret;
+}
+
+/*
+ * fbxatm callback to close & flush given vcc
+ */
+static void remote_vcc_close(struct fbxatm_vcc *vcc)
+{
+	struct driver_remote *priv;
+	struct driver_remote_vcc *pvcc;
+	struct sk_buff *skb, *ack;
+	struct fbxatm_remote_vcc_action *pkt;
+	struct fbxatm_remote_vcc_action_ack *pkt_ack;
+	int ret;
+
+	priv = fbxatm_dev_priv(vcc->adev);
+	mutex_lock(&priv->mutex);
+
+	pvcc = vcc->dev_priv;
+
+	if (priv->state != RSTATE_S_ACTIVE) {
+		/* just close vcc, don't tell remote */
+		list_del(&pvcc->next);
+		kfree(pvcc);
+
+		/* warn fsm so it can restart */
+		schedule_delayed_work(&priv->fsm_work, 0);
+		goto out_unlock;
+	}
+
+	/* prepare outgoing packet */
+	skb = fbxatm_remote_alloc_skb(priv->remote_ctx,
+				      sizeof (*pkt));
+	if (!skb) {
+		set_dying(priv);
+		goto out_unlock;
+	}
+
+	pkt = (struct fbxatm_remote_vcc_action *)skb_put(skb, sizeof (*pkt));
+	pkt->action = htonl(0);
+	pkt->vcc_remote_id = pvcc->remote_id;
+
+	/* free vcc now, failure will trigger dead state */
+	fbxatm_remote_sock_close(pvcc->vcc_send_sock);
+	fbxatm_remote_sock_close(pvcc->vcc_rx_sock);
+	fbxatm_remote_sock_close(pvcc->vcc_qempty_sock);
+	list_del(&pvcc->next);
+	kfree(pvcc);
+
+	/* send & wait for ack */
+	skb_queue_purge(&priv->wq_acks);
+	priv->wq_res = 0;
+
+	if (fbxatm_remote_sock_send(priv->vcc_action_sock, skb)) {
+		set_dying(priv);
+		goto out_unlock;
+	}
+
+	ret = __wait_ack(priv);
+
+	if (ret) {
+		/* timeout, device will die soon */
+		mutex_unlock(&priv->mutex);
+		return;
+	}
+
+	/* check ack */
+	ack = skb_dequeue(&priv->wq_acks);
+	if (!pskb_may_pull(ack, sizeof (*pkt_ack))) {
+		printk(KERN_ERR PFX "bad vcc action close ack\n");
+		dev_kfree_skb(ack);
+		set_dying(priv);
+		goto out_unlock;
+	}
+
+	pkt_ack = (struct fbxatm_remote_vcc_action_ack *)ack->data;
+	if (pkt_ack->ret) {
+		printk(KERN_ERR PFX "remote vcc close failed\n");
+		dev_kfree_skb(ack);
+		set_dying(priv);
+		goto out_unlock;
+	}
+
+out_unlock:
+	mutex_unlock(&priv->mutex);
+}
+
+/*
+ * common response for vcc action & send oam socket
+ */
+static void common_response(void *data, struct sk_buff *skb)
+{
+	struct driver_remote *priv;
+
+	priv = (struct driver_remote *)data;
+	skb_queue_tail(&priv->wq_acks, skb);
+	priv->wq_res = 1;
+	wake_up(&priv->wq);
+}
+
+/*
+ * create device procfs entries
+ */
+static int remote_init_procfs(struct fbxatm_dev *adev)
+{
+	return 0;
+}
+
+/*
+ * release device procfs entries
+ */
+static void remote_release_procfs(struct fbxatm_dev *adev)
+{
+}
+
+/*
+ * local fake fbxatm device callbacks
+ */
+static const struct fbxatm_dev_ops remote_fbxatm_ops = {
+	.open		= remote_vcc_open,
+	.close		= remote_vcc_close,
+	.send		= remote_send,
+	.send_oam	= remote_send_oam,
+	.init_procfs	= remote_init_procfs,
+	.release_procfs	= remote_release_procfs,
+	.owner		= THIS_MODULE,
+};
+
+/*
+ * dev_rx_oam socket rx callback
+ */
+static int dev_rx_oam_deliver(void *data, struct sk_buff *skb,
+			      struct sk_buff **ack)
+{
+	struct driver_remote *priv;
+
+	priv = (struct driver_remote *)data;
+	skb_queue_tail(&priv->dev_oam_reqs, skb);
+	schedule_delayed_work(&priv->fsm_work, 0);
+
+	return 0;
+}
+
+/*
+ * dev_link socket rx callback
+ */
+static int dev_link_deliver(void *data, struct sk_buff *skb,
+			    struct sk_buff **ack)
+{
+	struct driver_remote *priv;
+
+	priv = (struct driver_remote *)data;
+	skb_queue_tail(&priv->dev_link_reqs, skb);
+	schedule_delayed_work(&priv->fsm_work, 0);
+
+	/* send ack later */
+	return 0;
+}
+
+/*
+ * dev_connect socket tx ack callback
+ */
+static void dev_connect_response(void *data, struct sk_buff *skb)
+{
+	struct driver_remote *priv;
+
+	priv = (struct driver_remote *)data;
+	skb_queue_tail(&priv->connect_acks, skb);
+	schedule_delayed_work(&priv->fsm_work, 0);
+}
+
+/*
+ * handle link change queue
+ */
+static void handle_dev_link_queue(struct driver_remote *priv)
+{
+	struct sk_buff *skb;
+
+	do {
+		struct fbxatm_remote_dev_link *pkt;
+		struct fbxatm_dev *adev;
+		struct sk_buff *ack;
+
+		skb = skb_dequeue(&priv->dev_link_reqs);
+		if (!skb)
+			break;
+
+		if (!pskb_may_pull(skb, sizeof (*pkt))) {
+			printk(KERN_ERR PFX "bad rx dev link\n");
+			dev_kfree_skb(skb);
+			continue;
+		}
+
+		pkt = (struct fbxatm_remote_dev_link *)skb->data;
+
+		adev = priv->fbxatm_dev;
+		adev->link_rate_ds = ntohl(pkt->link_rate_ds);
+		adev->link_rate_us = ntohl(pkt->link_rate_us);
+		adev->link_cell_rate_ds = ntohl(pkt->link_cell_rate_ds);
+		adev->link_cell_rate_us = ntohl(pkt->link_cell_rate_us);
+
+		if (pkt->link)
+			fbxatm_dev_set_link_up(adev);
+		else
+			fbxatm_dev_set_link_down(adev);
+
+		/* send ack */
+		ack = fbxatm_remote_alloc_skb(priv->remote_ctx, 0);
+		if (!ack)
+			continue;
+		fbxatm_remote_sock_send_ack(priv->dev_link_sock, ack);
+
+	} while (1);
+}
+
+/*
+ * handle oam rx queue
+ */
+static void handle_oam_rx_queue(struct driver_remote *priv)
+{
+	struct fbxatm_oam_cell *cell;
+	struct sk_buff *skb;
+
+	do {
+		skb = skb_dequeue(&priv->dev_oam_reqs);
+		if (!skb)
+			break;
+
+		cell = kmalloc(sizeof (*cell), GFP_KERNEL);
+		if (!cell) {
+			dev_kfree_skb(skb);
+			continue;
+		}
+
+		if (!pskb_may_pull(skb, sizeof (cell->payload))) {
+			printk(KERN_ERR PFX "bad rx oam\n");
+			kfree(cell);
+			dev_kfree_skb(skb);
+			continue;
+		}
+
+		memcpy(&cell->payload, skb->data, sizeof (cell->payload));
+		dev_kfree_skb(skb);
+		fbxatm_netifrx_oam(priv->fbxatm_dev, cell);
+
+	} while (1);
+}
+
+/*
+ * free all and set to dead state
+ */
+static void remote_free(struct driver_remote *priv)
+{
+	struct driver_remote_vcc *pvcc;
+
+	if (priv->state == RSTATE_S_DEAD)
+		return;
+
+	priv->want_die = 0;
+
+	/* make sure remote_send device operation doesn't use sockets
+	 * any more */
+	spin_lock_bh(&priv->tx_lock);
+	priv->state = RSTATE_S_DEAD;
+	spin_unlock_bh(&priv->tx_lock);
+
+	/* same goes for open_vcc, close_vcc and send_oam ops,
+	 * RSTATE_S_DEAD will prevent function from being entered, and
+	 * any sleeper will be woken up */
+	wake_up(&priv->wq);
+
+	mutex_lock(&priv->mutex);
+
+	/* no vcc can be created, close all vcc sockets */
+	list_for_each_entry(pvcc, &priv->pvcc_list, next) {
+
+		if (pvcc->vcc_send_sock) {
+			fbxatm_remote_sock_close(pvcc->vcc_send_sock);
+			pvcc->vcc_send_sock = NULL;
+		}
+
+		if (pvcc->vcc_rx_sock) {
+			fbxatm_remote_sock_close(pvcc->vcc_rx_sock);
+			pvcc->vcc_rx_sock = NULL;
+		}
+
+		if (pvcc->vcc_qempty_sock) {
+			fbxatm_remote_sock_close(pvcc->vcc_qempty_sock);
+			pvcc->vcc_qempty_sock = NULL;
+		}
+	}
+	mutex_unlock(&priv->mutex);
+
+	/* no external callback from fbxatm can use sockets now */
+
+	/* close all sockets */
+	if (priv->dev_connect_sock) {
+		fbxatm_remote_sock_close(priv->dev_connect_sock);
+		priv->dev_connect_sock = NULL;
+	}
+
+	if (priv->keepalive_sock) {
+		fbxatm_remote_sock_close(priv->keepalive_sock);
+		priv->keepalive_sock = NULL;
+	}
+
+	if (priv->dev_link_sock) {
+		fbxatm_remote_sock_close(priv->dev_link_sock);
+		priv->keepalive_sock = NULL;
+	}
+
+	if (priv->dev_rx_oam_sock) {
+		fbxatm_remote_sock_close(priv->dev_rx_oam_sock);
+		priv->dev_rx_oam_sock = NULL;
+	}
+
+	if (priv->vcc_action_sock) {
+		fbxatm_remote_sock_close(priv->vcc_action_sock);
+		priv->vcc_action_sock = NULL;
+	}
+
+	if (priv->dev_send_oam_sock) {
+		fbxatm_remote_sock_close(priv->dev_send_oam_sock);
+		priv->dev_send_oam_sock = NULL;
+	}
+
+	if (priv->netdev) {
+		dev_put(priv->netdev);
+		priv->netdev = NULL;
+	}
+
+	if (priv->remote_ctx) {
+		fbxatm_remote_free_ctx(priv->remote_ctx);
+		priv->remote_ctx = NULL;
+	}
+
+	skb_queue_purge(&priv->connect_acks);
+	skb_queue_purge(&priv->dev_link_reqs);
+	skb_queue_purge(&priv->dev_oam_reqs);
+	skb_queue_purge(&priv->wq_acks);
+
+	if (priv->fbxatm_dev_registered) {
+		fbxatm_dev_set_link_down(priv->fbxatm_dev);
+		printk(KERN_WARNING "%s: marking dead\n",
+		       priv->fbxatm_dev->name);
+	}
+}
+
+/*
+ * remote context timeout on any socket
+ */
+static void remote_sock_timeout(void *data)
+{
+	set_dying((struct driver_remote *)data);
+}
+
+/*
+ * main workqueue to handle device fsm
+ */
+static void remote_fsm(struct work_struct *t)
+{
+	struct delayed_work *dwork;
+	struct driver_remote *priv;
+	struct net_device *netdev;
+	struct fbxatm_remote_sockaddr addr;
+
+	dwork = container_of(t, struct delayed_work, work);
+	priv = container_of(dwork, struct driver_remote, fsm_work);
+
+	if (priv->want_die) {
+		remote_free(priv);
+		/* let FSM restart if needed */
+	}
+
+	switch (priv->state) {
+	case RSTATE_S_WAIT_NETDEV:
+	{
+		struct fbxatm_remote_connect *pkt;
+		struct fbxatm_remote_ctx *ctx;
+		struct sk_buff *skb;
+		u32 session_id;
+
+		netdev = dev_get_by_name(&init_net, priv->pd->netdev_name);
+		if (!netdev) {
+			/* netdev notifier will reschedule */
+			return;
+		}
+		priv->netdev = netdev;
+
+		/* got netdev, open remote context */
+		get_random_bytes(&session_id, sizeof (session_id));
+		ctx = fbxatm_remote_alloc_ctx(netdev, priv->pd->remote_mac,
+					      session_id,
+					      remote_sock_timeout,
+					      priv);
+		if (!ctx) {
+			printk(KERN_ERR PFX "unable to allocate remote ctx\n");
+			remote_free(priv);
+			return;
+		}
+		priv->remote_ctx = ctx;
+
+		/* open rx sockets */
+		memset(&addr, 0, sizeof (addr));
+		addr.mtype = htonl(FBXATM_RMT_DEV_LINK);
+		addr.deliver = dev_link_deliver;
+		addr.priv = priv;
+		priv->dev_link_sock = fbxatm_remote_sock_bind(ctx, &addr, 1);
+		if (!priv->dev_link_sock) {
+			remote_free(priv);
+			return;
+		}
+
+		memset(&addr, 0, sizeof (addr));
+		addr.mtype = htonl(FBXATM_RMT_DEV_RX_OAM);
+		addr.deliver = dev_rx_oam_deliver;
+		addr.priv = priv;
+		priv->dev_rx_oam_sock = fbxatm_remote_sock_bind(ctx, &addr, 0);
+		if (!priv->dev_rx_oam_sock) {
+			remote_free(priv);
+			return;
+		}
+
+		/* create socket for initial connexion */
+		memset(&addr, 0, sizeof (addr));
+		addr.mtype = htonl(FBXATM_RMT_CONNECT);
+		addr.response = dev_connect_response;
+		addr.priv = priv;
+		addr.infinite_retry = 1;
+		priv->dev_connect_sock = fbxatm_remote_sock_connect(ctx,
+								    &addr, 1);
+		if (!priv->dev_connect_sock) {
+			remote_free(priv);
+			return;
+		}
+
+		/* send the connect packet */
+		skb = fbxatm_remote_alloc_skb(priv->remote_ctx,
+					      sizeof (*pkt));
+		if (!skb) {
+			remote_free(priv);
+			return;
+		}
+
+		pkt = (struct fbxatm_remote_connect *)
+			skb_put(skb, sizeof (*pkt));
+
+		memcpy(pkt->name, priv->pd->remote_name, sizeof (pkt->name));
+
+		fbxatm_remote_sock_getaddr(priv->dev_link_sock, &addr);
+		pkt->dev_link_port = addr.lport;
+
+		fbxatm_remote_sock_getaddr(priv->dev_rx_oam_sock, &addr);
+		pkt->dev_rx_oam_port = addr.lport;
+
+		if (fbxatm_remote_sock_send(priv->dev_connect_sock, skb)) {
+			dev_kfree_skb(skb);
+			remote_free(priv);
+			return;
+		}
+
+		/* wait for connect ack... */
+		priv->state = RSTATE_S_WAIT_REMOTE;
+		break;
+	}
+
+	case RSTATE_S_WAIT_REMOTE:
+	{
+		struct fbxatm_remote_connect_ack *pkt_ack;
+		struct fbxatm_remote_ctx *ctx;
+		struct fbxatm_dev *adev;
+		struct sk_buff *skb;
+		int ret;
+
+		skb = skb_dequeue(&priv->connect_acks);
+		if (!skb)
+			return;
+
+		if (!pskb_may_pull(skb, sizeof (*pkt_ack))) {
+			printk(KERN_ERR PFX "bad connect ack\n");
+			dev_kfree_skb(skb);
+			return;
+		}
+
+		pkt_ack = (struct fbxatm_remote_connect_ack *)skb->data;
+		ctx = priv->remote_ctx;
+
+		/* open sockets */
+		memset(&addr, 0, sizeof (addr));
+		addr.mtype = htonl(FBXATM_RMT_VCC_ACTION);
+		addr.response = common_response;
+		addr.dport = pkt_ack->vcc_action_port;
+		addr.priv = priv;
+		priv->vcc_action_sock = fbxatm_remote_sock_connect(ctx,
+								   &addr, 1);
+		if (!priv->vcc_action_sock) {
+			remote_free(priv);
+			return;
+		}
+
+		memset(&addr, 0, sizeof (addr));
+		addr.mtype = htonl(FBXATM_RMT_DEV_SEND_OAM);
+		addr.response = common_response;
+		addr.dport = pkt_ack->dev_send_oam_port;
+		addr.priv = priv;
+		priv->dev_send_oam_sock = fbxatm_remote_sock_connect(ctx,
+								     &addr, 1);
+		if (!priv->dev_send_oam_sock) {
+			remote_free(priv);
+			return;
+		}
+
+		memset(&addr, 0, sizeof (addr));
+		addr.mtype = htonl(FBXATM_RMT_KEEPALIVE);
+		addr.priv = priv;
+		addr.dport = pkt_ack->keepalive_port;
+		priv->keepalive_sock = fbxatm_remote_sock_connect(ctx,
+								  &addr, 1);
+		if (!priv->keepalive_sock) {
+			remote_free(priv);
+			return;
+		}
+
+		/* all set, register fbxatm device */
+		adev = priv->fbxatm_dev;
+		adev->max_vcc = ntohl(pkt_ack->max_vcc);
+		adev->vci_mask = ntohl(pkt_ack->vci_mask);
+		adev->vpi_mask = ntohl(pkt_ack->vpi_mask);
+		adev->max_priority = ntohl(pkt_ack->max_priority);
+		adev->max_rx_priority = ntohl(pkt_ack->max_rx_priority);
+		adev->link_rate_ds = ntohl(pkt_ack->link_rate_ds);
+		adev->link_rate_us = ntohl(pkt_ack->link_rate_us);
+		adev->link_cell_rate_ds = ntohl(pkt_ack->link_cell_rate_ds);
+		adev->link_cell_rate_us = ntohl(pkt_ack->link_cell_rate_us);
+		adev->tx_headroom = fbxatm_remote_headroom(ctx);
+
+		/* register atm device */
+		priv->state = RSTATE_S_ACTIVE;
+
+		if (!priv->fbxatm_dev_registered) {
+			ret = fbxatm_register_device(adev, "remote_fbxatm",
+						     &remote_fbxatm_ops);
+			if (ret) {
+				remote_free(priv);
+				return;
+			}
+		}
+
+		priv->fbxatm_dev_registered = 1;
+		printk(KERN_INFO "%s: connected to %s - %pM6/%s\n",
+		       adev->name, priv->pd->remote_name,
+		       priv->pd->remote_mac, priv->netdev->name);
+
+		if (pkt_ack->link)
+			fbxatm_dev_set_link_up(adev);
+		else
+			fbxatm_dev_set_link_down(adev);
+
+		schedule_delayed_work(&priv->fsm_work, HZ);
+		break;
+	}
+
+	case RSTATE_S_ACTIVE:
+	{
+		/* process link change event if any */
+		handle_dev_link_queue(priv);
+
+		/* process rx oam if any */
+		handle_oam_rx_queue(priv);
+
+		/* send keepalive */
+		if (!fbxatm_remote_sock_pending(priv->keepalive_sock)) {
+			struct sk_buff *skb;
+
+			skb = fbxatm_remote_alloc_skb(priv->remote_ctx, 0);
+			if (skb)
+				fbxatm_remote_sock_send(priv->keepalive_sock,
+							skb);
+		}
+
+		schedule_delayed_work(&priv->fsm_work, HZ);
+		break;
+	}
+
+	case RSTATE_S_DEAD:
+		/* wait until open vcc list is empty */
+		if (!list_empty(&priv->pvcc_list))
+			break;
+
+		priv->state = RSTATE_S_WAIT_NETDEV;
+		if (priv->fbxatm_dev_registered)
+			printk(KERN_INFO "%s: reconnecting\n",
+			       priv->fbxatm_dev->name);
+		schedule_delayed_work(&priv->fsm_work, HZ);
+		break;
+	}
+}
+
+/*
+ * netdevice notifier callback
+ */
+static int remote_device_event(struct notifier_block *this,
+			       unsigned long event, void *ptr)
+{
+	struct net_device *dev = (struct net_device *)ptr;
+	struct driver_remote *priv;
+
+	spin_lock_bh(&remote_lock);
+
+	/* go through remote list to check if device matches one */
+	list_for_each_entry(priv, &remote_dev_list, next) {
+
+		switch (event) {
+		case NETDEV_REGISTER:
+			if (strcmp(dev->name, priv->pd->netdev_name))
+				continue;
+			break;
+
+		case NETDEV_UNREGISTER:
+			if (dev != priv->netdev)
+				continue;
+			priv->want_die = 1;
+			break;
+
+		default:
+			continue;
+		}
+		schedule_delayed_work(&priv->fsm_work, 0);
+	}
+
+	spin_unlock_bh(&remote_lock);
+
+	return 0;
+}
+
+static struct notifier_block remote_notifier = {
+	.notifier_call = remote_device_event,
+};
+
+/*
+ * platform data probe callback
+ */
+static int __devinit remote_probe(struct platform_device *pdev)
+{
+	struct fbxatm_remote_pdata *pd;
+	struct driver_remote *priv;
+	struct fbxatm_dev *adev;
+
+	pd = pdev->dev.platform_data;
+	if (!pd || !pd->netdev_name[0])
+		return -EINVAL;
+
+	/* allocate fbxatm device */
+	adev = fbxatm_alloc_device(sizeof (*priv));
+	if (!adev)
+		return -ENOMEM;
+
+	priv = fbxatm_dev_priv(adev);
+
+	priv->fbxatm_dev = adev;
+	INIT_LIST_HEAD(&priv->pvcc_list);
+	spin_lock_init(&priv->tx_lock);
+	mutex_init(&priv->mutex);
+
+	priv->state = RSTATE_S_WAIT_NETDEV;
+	INIT_DELAYED_WORK(&priv->fsm_work, remote_fsm);
+
+	skb_queue_head_init(&priv->connect_acks);
+	skb_queue_head_init(&priv->dev_link_reqs);
+	skb_queue_head_init(&priv->dev_oam_reqs);
+	init_waitqueue_head(&priv->wq);
+	skb_queue_head_init(&priv->wq_acks);
+	priv->pd = pd;
+
+	spin_lock_bh(&remote_lock);
+	list_add_tail(&priv->next, &remote_dev_list);
+	spin_unlock_bh(&remote_lock);
+
+	platform_set_drvdata(pdev, priv);
+
+	printk(KERN_INFO PFX "connecting to %s - %pM6/%s\n",
+	       priv->pd->remote_name,
+	       priv->pd->remote_mac,
+	       priv->pd->netdev_name);
+
+	/* kick fsm  */
+	schedule_delayed_work(&priv->fsm_work, 0);
+	return 0;
+}
+
+static int __devexit remote_remove(struct platform_device *pdev)
+{
+	struct driver_remote *priv;
+	struct fbxatm_dev *adev;
+
+	priv = platform_get_drvdata(pdev);
+	adev = priv->fbxatm_dev;
+
+	/* remove from global list so network notifier can't find us */
+	spin_lock_bh(&remote_lock);
+	list_del(&priv->next);
+	spin_unlock_bh(&remote_lock);
+
+	/* cancel any pending fsm */
+	cancel_delayed_work_sync(&priv->fsm_work);
+
+	/* force dead state */
+	remote_free(priv);
+
+	if (priv->fbxatm_dev_registered)
+		fbxatm_unregister_device(adev);
+	fbxatm_free_device(adev);
+	return 0;
+}
+
+struct platform_driver fbxatm_remote_driver = {
+	.probe	= remote_probe,
+	.remove	= __devexit_p(remote_remove),
+	.driver	= {
+		.name	= "fbxatm_remote",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static int __init fbxatm_remote_driver_init(void)
+{
+	int ret;
+
+	INIT_LIST_HEAD(&remote_dev_list);
+	ret = fbxatm_remote_init();
+	if (ret)
+		goto fail;
+	ret = register_netdevice_notifier(&remote_notifier);
+	if (ret)
+		goto fail_remote;
+	ret = platform_driver_register(&fbxatm_remote_driver);
+	if (ret)
+		goto fail_notifier;
+	return 0;
+
+fail_notifier:
+	unregister_netdevice_notifier(&remote_notifier);
+fail_remote:
+	fbxatm_remote_exit();
+fail:
+	return ret;
+}
+
+static void __exit fbxatm_remote_driver_exit(void)
+{
+	fbxatm_remote_exit();
+	unregister_netdevice_notifier(&remote_notifier);
+	platform_driver_unregister(&fbxatm_remote_driver);
+}
+
+module_init(fbxatm_remote_driver_init);
+module_exit(fbxatm_remote_driver_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+MODULE_AUTHOR("Maxime Bizon <mbizon@freebox.fr>");
diff -Nruw linux-2.6.39.4-fbx/net/fbxatm./fbxatm_remote_driver.h linux-2.6.39.4-fbx/net/fbxatm/fbxatm_remote_driver.h
--- linux-2.6.39.4-fbx/net/fbxatm./fbxatm_remote_driver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/net/fbxatm/fbxatm_remote_driver.h	2011-05-24 18:15:37.875793706 +0200
@@ -0,0 +1,79 @@
+#ifndef FBXATM_REMOTE_DRIVER_H_
+#define FBXATM_REMOTE_DRIVER_H_
+
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/fbxatm.h>
+#include <linux/fbxatm_dev.h>
+#include <linux/fbxatm_remote.h>
+
+enum remote_state {
+	RSTATE_S_WAIT_NETDEV = 0,
+	RSTATE_S_WAIT_REMOTE,
+	RSTATE_S_ACTIVE,
+	RSTATE_S_DEAD,
+};
+
+struct driver_remote;
+
+struct driver_remote_vcc {
+
+	struct fbxatm_vcc		*vcc;
+	struct driver_remote		*priv;
+
+	unsigned int			remote_id;
+
+	int				tx_pending;
+	int				tx_got_qempty;
+
+	/* output */
+	struct fbxatm_remote_sock	*vcc_send_sock;
+
+	/* input */
+	struct fbxatm_remote_sock	*vcc_rx_sock;
+	struct fbxatm_remote_sock	*vcc_qempty_sock;
+
+	struct list_head		next;
+};
+
+struct driver_remote {
+	struct fbxatm_dev		*fbxatm_dev;
+	int				fbxatm_dev_registered;
+
+	struct list_head		pvcc_list;
+
+	spinlock_t			tx_lock;
+	struct mutex			mutex;
+
+	struct fbxatm_remote_ctx	*remote_ctx;
+	struct net_device		*netdev;
+
+	enum remote_state		state;
+	struct delayed_work		fsm_work;
+	int				want_die;
+
+	/* output */
+	struct fbxatm_remote_sock	*dev_connect_sock;
+	struct sk_buff_head		connect_acks;
+
+	struct fbxatm_remote_sock	*keepalive_sock;
+
+	/* input */
+	struct fbxatm_remote_sock	*dev_link_sock;
+	struct sk_buff_head		dev_link_reqs;
+
+	struct fbxatm_remote_sock	*dev_rx_oam_sock;
+	struct sk_buff_head		dev_oam_reqs;
+
+	/* used to wait for send_oam & vcc_action */
+	struct fbxatm_remote_sock	*vcc_action_sock;
+	struct fbxatm_remote_sock	*dev_send_oam_sock;
+	wait_queue_head_t		wq;
+	int				wq_res;
+	struct sk_buff_head		wq_acks;
+
+	struct fbxatm_remote_pdata	*pd;
+	struct list_head		next;
+};
+
+#endif /* ! FBXATM_REMOTE_DRIVER_H_ */
diff -Nruw linux-2.6.39.4-fbx/net/fbxatm./fbxatm_sysfs.c linux-2.6.39.4-fbx/net/fbxatm/fbxatm_sysfs.c
--- linux-2.6.39.4-fbx/net/fbxatm./fbxatm_sysfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/net/fbxatm/fbxatm_sysfs.c	2011-05-24 18:15:37.885793664 +0200
@@ -0,0 +1,153 @@
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/kobject.h>
+#include <linux/fbxatm_dev.h>
+#include "fbxatm_priv.h"
+
+#define to_fbxatm_dev(cldev) container_of(cldev, struct fbxatm_dev, dev)
+
+static ssize_t show_ifindex(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct fbxatm_dev *adev = to_fbxatm_dev(dev);
+	return sprintf(buf, "%d\n", adev->ifindex);
+}
+
+static ssize_t show_link_state(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct fbxatm_dev *adev = to_fbxatm_dev(dev);
+	return sprintf(buf, "%d\n",
+		       test_bit(FBXATM_DEV_F_LINK_UP, &adev->dev_flags) ?
+		       1 : 0);
+}
+
+static ssize_t show_link_rate_us(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct fbxatm_dev *adev = to_fbxatm_dev(dev);
+	return sprintf(buf, "%d\n", adev->link_rate_us);
+}
+
+static ssize_t show_link_rate_ds(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct fbxatm_dev *adev = to_fbxatm_dev(dev);
+	return sprintf(buf, "%d\n", adev->link_rate_ds);
+}
+
+static ssize_t show_max_priority(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct fbxatm_dev *adev = to_fbxatm_dev(dev);
+	return sprintf(buf, "%d\n", adev->max_priority);
+}
+
+static ssize_t show_max_rx_priority(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct fbxatm_dev *adev = to_fbxatm_dev(dev);
+	return sprintf(buf, "%d\n", adev->max_rx_priority);
+}
+
+static DEVICE_ATTR(ifindex, S_IRUGO, show_ifindex, NULL);
+static DEVICE_ATTR(link_state, S_IRUGO, show_link_state, NULL);
+static DEVICE_ATTR(link_rate_us, S_IRUGO, show_link_rate_us, NULL);
+static DEVICE_ATTR(link_rate_ds, S_IRUGO, show_link_rate_ds, NULL);
+static DEVICE_ATTR(max_priority, S_IRUGO, show_max_priority, NULL);
+static DEVICE_ATTR(max_rx_priority, S_IRUGO, show_max_rx_priority, NULL);
+
+static struct device_attribute *fbxatm_attrs[] = {
+	&dev_attr_ifindex,
+	&dev_attr_link_state,
+	&dev_attr_link_rate_us,
+	&dev_attr_link_rate_ds,
+	&dev_attr_max_priority,
+	&dev_attr_max_rx_priority,
+};
+
+static int fbxatm_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct fbxatm_dev *adev;
+
+	if (!dev)
+		return -ENODEV;
+
+	adev = to_fbxatm_dev(dev);
+	if (!adev)
+		return -ENODEV;
+
+	if (add_uevent_var(env, "NAME=%s", adev->name))
+		return -ENOMEM;
+
+	if (add_uevent_var(env, "IFINDEX=%u", adev->ifindex))
+		return -ENOMEM;
+
+	if (add_uevent_var(env, "LINK=%u",
+			   test_bit(FBXATM_DEV_F_LINK_UP, &adev->dev_flags) ?
+			   1 : 0))
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void fbxatm_release(struct device *dev)
+{
+	struct fbxatm_dev *adev = to_fbxatm_dev(dev);
+	__fbxatm_free_device(adev);
+}
+
+static struct class fbxatm_class = {
+	.name		= "fbxatm",
+	.dev_release	= fbxatm_release,
+	.dev_uevent	= fbxatm_uevent,
+};
+
+void fbxatm_dev_change_sysfs(struct fbxatm_dev *adev)
+{
+	struct device *dev = &adev->dev;
+
+	kobject_uevent_env(&dev->kobj, KOBJ_CHANGE, NULL);
+}
+
+int fbxatm_register_dev_sysfs(struct fbxatm_dev *adev)
+{
+	struct device *dev = &adev->dev;
+	int i, j, ret;
+
+	dev->class = &fbxatm_class;
+	dev_set_name(dev, "%s", adev->name);
+	ret = device_register(dev);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < ARRAY_SIZE(fbxatm_attrs); i++) {
+		ret = device_create_file(dev, fbxatm_attrs[i]);
+		if (ret)
+			goto err;
+	}
+	return 0;
+
+err:
+	for (j = 0; j < i; j++)
+		device_remove_file(dev, fbxatm_attrs[j]);
+	device_del(dev);
+	return ret;
+}
+
+void fbxatm_unregister_dev_sysfs(struct fbxatm_dev *adev)
+{
+	struct device *dev = &adev->dev;
+	device_del(dev);
+}
+
+int __init fbxatm_sysfs_init(void)
+{
+	return class_register(&fbxatm_class);
+}
+
+void fbxatm_sysfs_exit(void)
+{
+	class_unregister(&fbxatm_class);
+}
diff -Nruw linux-2.6.39.4-fbx/net/fbxatm./Kconfig linux-2.6.39.4-fbx/net/fbxatm/Kconfig
--- linux-2.6.39.4-fbx/net/fbxatm./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/net/fbxatm/Kconfig	2011-05-24 18:15:37.865793748 +0200
@@ -0,0 +1,28 @@
+menuconfig FBXATM
+	tristate "Freebox Asynchronous Transfer Mode (ATM)"
+
+if FBXATM
+
+config FBXATM_REMOTE
+	bool
+
+choice
+	prompt "mode"
+	default FBXATM_STACK
+
+config FBXATM_STACK
+	bool "standard"
+
+config FBXATM_REMOTE_STUB
+	bool "remote stub"
+	select FBXATM_REMOTE
+
+endchoice
+
+config FBXATM_REMOTE_DRIVER
+	tristate "remote fbxatm driver"
+	depends on FBXATM_STACK
+	select FBXATM_REMOTE
+	default n
+
+endif
diff -Nruw linux-2.6.39.4-fbx/net/fbxatm./Makefile linux-2.6.39.4-fbx/net/fbxatm/Makefile
--- linux-2.6.39.4-fbx/net/fbxatm./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.39.4-fbx/net/fbxatm/Makefile	2011-05-24 18:15:37.865793748 +0200
@@ -0,0 +1,18 @@
+obj-$(CONFIG_FBXATM) += fbxatm.o
+obj-$(CONFIG_FBXATM_REMOTE) += fbxatm_remote.o
+
+fbxatm-y := fbxatm_procfs.o fbxatm_sysfs.o
+
+ifeq ($(CONFIG_FBXATM_STACK),y)
+fbxatm-y += 	fbxatm_core.o	\
+		fbxatm_2684.o	\
+		fbxatm_dev.o	\
+		crc10.o
+fbxatm-$(CONFIG_PPP) += fbxatm_pppoa.o
+endif
+
+ifeq ($(CONFIG_FBXATM_REMOTE_STUB),y)
+fbxatm-y += fbxatm_remote_stub.o
+endif
+
+obj-$(CONFIG_FBXATM_REMOTE_DRIVER) += fbxatm_remote_driver.o
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.39.4-fbx/net/ipv4/ip_ffn.c	2011-05-24 18:15:57.315713237 +0200
@@ -0,0 +1,447 @@
+/*
+ * IP fast forwarding and NAT
+ *
+ * Very restrictive code, that only cope non fragmented UDP and TCP
+ * packets, that are routed and NATed with no other modification.
+ *
+ * Provide a fast path for established conntrack entries so that
+ * packets go out ASAP.
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/jhash.h>
+#include <net/ip.h>
+#include <net/route.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_helper.h>
+
+#define FFN_CACHE_SIZE		128
+#define MAX_FFN_ENTRY		512
+
+struct ffn_data {
+	u8 new_tos;
+	u32 new_sip;
+	u32 new_dip;
+	u16 new_sport;
+	u16 new_dport;
+	int force_skb_prio;
+	unsigned int new_skb_prio;
+	struct dst_entry *dst;
+	struct nf_conn *ct;
+	enum ip_conntrack_info ctinfo;
+};
+
+struct ffn_lookup_entry {
+	u32 sip;
+	u32 dip;
+	u16 sport;
+	u16 dport;
+	u8 protocol;
+	struct list_head next;
+	struct ffn_data manip;
+	struct list_head all_next;
+};
+
+static DEFINE_SPINLOCK(ffn_lock);
+static struct list_head ffn_cache[FFN_CACHE_SIZE];
+static struct list_head ffn_all;
+static unsigned int ffn_entry_count;
+
+/*
+ * hash on five parameter
+ */
+static inline unsigned int ffn_hash(u32 sip, u32 dip, u16 sport, u16 dport,
+				    int is_tcp)
+{
+	return jhash_3words(sip, is_tcp ? dip : ~dip, sport | dport << 16, 0);
+}
+
+/*
+ * attempt to find entry with given value in cache
+ */
+static struct ffn_lookup_entry *__ffn_find(u32 sip, u32 dip,
+					   u16 sport, u16 dport,
+					   u8 protocol,
+					   unsigned int hash)
+{
+	struct ffn_lookup_entry *tmp;
+
+	list_for_each_entry(tmp, &ffn_cache[hash % FFN_CACHE_SIZE], next) {
+
+		/* compare entry */
+		if (tmp->sip == sip && tmp->dip == dip &&
+		    tmp->sport == sport && tmp->dport == dport &&
+		    tmp->protocol == protocol)
+			return tmp;
+	}
+	return NULL;
+}
+
+static struct ffn_lookup_entry *__ffn_get(u32 sip, u32 dip,
+					  u16 sport, u16 dport,
+					  int is_tcp)
+{
+	unsigned int hash;
+	u8 protocol;
+
+	/* lookup entry in cache */
+	protocol = (is_tcp) ? IPPROTO_TCP : IPPROTO_UDP;
+	hash = ffn_hash(sip, dip, sport, dport, is_tcp);
+	return __ffn_find(sip, dip, sport, dport, protocol, hash);
+}
+
+static void __ffn_remove_entry(struct ffn_lookup_entry *e)
+{
+	list_del(&e->next);
+	list_del(&e->all_next);
+	ffn_entry_count--;
+	dst_release(e->manip.dst);
+	kfree(e);
+}
+
+static int __ffn_add_entry(struct ffn_lookup_entry *e,
+			   u8 proto, unsigned int hash)
+{
+	/* make sure it's not present */
+	if (__ffn_find(e->sip, e->dip, e->sport, e->dport, proto, hash))
+		return 1;
+
+	if (ffn_entry_count >= MAX_FFN_ENTRY)
+		return 1;
+
+	/* add new entry */
+	list_add_tail(&e->next, &ffn_cache[hash % FFN_CACHE_SIZE]);
+	list_add_tail(&e->all_next, &ffn_all);
+	ffn_entry_count++;
+	return 0;
+}
+
+/*
+ * helper to recompute checksum
+ */
+static inline u16 recheck4(u32 oldvalinv, u32 newval,
+			   u32 oldvalinv2, u32 newval2,
+			   u32 oldvalinv3, u32 newval3,
+			   u32 oldvalinv4, u32 newval4,
+			   u16 oldcheck)
+{
+	u32 diffs[] = { oldvalinv, newval, oldvalinv2, newval2,
+			oldvalinv3, newval3,
+			oldvalinv4, newval4 };
+
+	return csum_fold(csum_partial((char *)diffs, sizeof (diffs),
+				      oldcheck ^ 0xFFFF));
+}
+
+/*
+ * two hooks into netfilter code
+ */
+extern int external_tcpv4_packet(struct nf_conn *ct,
+				 const struct sk_buff *skb,
+				 unsigned int dataoff,
+				 enum ip_conntrack_info ctinfo);
+
+extern int external_udpv4_packet(struct nf_conn *ct,
+				 const struct sk_buff *skb,
+				 unsigned int dataoff,
+				 enum ip_conntrack_info ctinfo);
+
+/*
+ * check if packet is in ffn cache, or mark it if it can be added
+ * later
+ */
+int ip_ffn_process(struct sk_buff *skb)
+{
+	struct ffn_lookup_entry *e;
+	struct nf_conntrack *nfct;
+	struct iphdr *iph;
+	struct tcphdr *tcph = NULL;
+	struct udphdr *udph = NULL;
+	u16 tcheck;
+	u8 proto;
+	int res;
+
+	iph = ip_hdr(skb);
+
+	/* refuse fragmented IP packet, or packets with IP options */
+	if (iph->ihl > 5 || (iph->frag_off & htons(IP_MF | IP_OFFSET)))
+		goto not_ffnable;
+
+	/* refuse fragmented IP packet */
+	if (iph->frag_off & htons(IP_MF | IP_OFFSET))
+		goto not_ffnable;
+
+	/* check encapsulated protocol is udp or tcp */
+	if (iph->protocol != IPPROTO_TCP && iph->protocol != IPPROTO_UDP)
+		goto not_ffnable;
+
+	if (iph->ttl <= 1)
+		goto not_ffnable;
+
+	proto = iph->protocol;
+	if (proto == IPPROTO_TCP) {
+
+		if (skb_headlen(skb) < (iph->ihl * 4) + sizeof (struct tcphdr))
+			goto not_ffnable;
+		tcph = (struct tcphdr *)((unsigned char *)iph +
+					 (iph->ihl * 4));
+
+		if (tcph->doff * 4 < sizeof (struct tcphdr) ||
+		    skb_headlen(skb) < iph->ihl * 4 + tcph->doff * 4)
+			goto not_ffnable;
+
+		spin_lock_bh(&ffn_lock);
+		e = __ffn_get(iph->saddr, iph->daddr, tcph->source,
+			      tcph->dest, 1);
+	} else {
+
+		if (skb_headlen(skb) < (iph->ihl * 4) + sizeof (struct udphdr))
+			goto not_ffnable;
+		udph = (struct udphdr *)((unsigned char *)iph +
+					 (iph->ihl * 4));
+		spin_lock_bh(&ffn_lock);
+		e = __ffn_get(iph->saddr, iph->daddr, udph->source,
+			      udph->dest, 0);
+	}
+
+	if (!e) {
+		spin_unlock_bh(&ffn_lock);
+		goto ffnable;
+	}
+
+	if (e->manip.dst->obsolete > 0) {
+		__ffn_remove_entry(e);
+		spin_unlock_bh(&ffn_lock);
+		goto ffnable;
+	}
+
+	nfct = &e->manip.ct->ct_general;
+	nf_conntrack_get(nfct);
+
+	if (proto == IPPROTO_TCP) {
+		/* do sequence number checking and update
+		 * conntrack info */
+		res = external_tcpv4_packet(e->manip.ct, skb, iph->ihl * 4,
+					    e->manip.ctinfo);
+		tcheck = tcph->check;
+	} else {
+		res = external_udpv4_packet(e->manip.ct, skb, iph->ihl * 4,
+					    e->manip.ctinfo);
+		tcheck = udph->check;
+	}
+
+	if (unlikely(res != NF_ACCEPT)) {
+		/* packet rejected by conntrack, unless asked to drop,
+		 * send it back into kernel */
+		spin_unlock_bh(&ffn_lock);
+		nf_conntrack_put(nfct);
+
+		if (res == NF_DROP) {
+			dev_kfree_skb(skb);
+			return 0;
+		}
+
+		goto ffnable;
+	}
+
+	/* fix ports & transport protocol checksum */
+	if (proto == IPPROTO_TCP) {
+		tcheck = recheck4(~iph->saddr, e->manip.new_sip,
+				  ~iph->daddr, e->manip.new_dip,
+				  tcph->source ^ 0xFFFF,
+				  e->manip.new_sport,
+				  tcph->dest ^ 0xFFFF,
+				  e->manip.new_dport,
+				  tcheck);
+		tcph->source = e->manip.new_sport;
+		tcph->dest = e->manip.new_dport;
+		tcph->check = tcheck;
+	} else {
+		tcheck = recheck4(~iph->saddr, e->manip.new_sip,
+				  ~iph->daddr, e->manip.new_dip,
+				  udph->source ^ 0xFFFF,
+				  e->manip.new_sport,
+				  udph->dest ^ 0xFFFF,
+				  e->manip.new_dport,
+				  tcheck);
+		udph->source = e->manip.new_sport;
+		udph->dest = e->manip.new_dport;
+		if (udph->check)
+			udph->check = tcheck ? tcheck : 0xffff;
+	}
+
+	/* update IP header field */
+	iph->ttl--;
+	iph->tos = e->manip.new_tos;
+	iph->saddr = e->manip.new_sip;
+	iph->daddr = e->manip.new_dip;
+	iph->check = 0;
+	iph->check = ip_fast_csum((u8 *)iph, 5);
+
+	/* forward skb */
+	if (e->manip.force_skb_prio)
+		skb->priority = e->manip.new_skb_prio;
+	else
+		skb->priority = rt_tos2priority(iph->tos);
+	skb_dst_set(skb, dst_clone(e->manip.dst));
+	spin_unlock_bh(&ffn_lock);
+	nf_conntrack_put(nfct);
+
+	skb->ffn_state = FFN_STATE_FAST_FORWARDED;
+	dst_output(skb);
+	return 0;
+
+ffnable:
+	skb->ffn_state = FFN_STATE_FORWARDABLE;
+	return 1;
+
+not_ffnable:
+	skb->ffn_state = FFN_STATE_INCOMPATIBLE;
+	return 1;
+}
+
+/*
+ * check if skb is candidate for ffn, and if so add it to ffn cache
+ *
+ * called after post routing
+ */
+void ip_ffn_add(struct sk_buff *skb)
+{
+	struct nf_conn *ct;
+	struct nf_conntrack_tuple *tuple, *rtuple;
+	enum ip_conntrack_info ctinfo;
+	struct ffn_lookup_entry *e;
+	struct iphdr *iph;
+	unsigned int hash;
+	int dir;
+	u8 proto;
+
+	if (ffn_entry_count >= MAX_FFN_ENTRY)
+		return;
+
+	iph = ip_hdr(skb);
+
+	if (!skb->nfct || skb_dst(skb)->output != ip_output)
+		return;
+
+	ct = nf_ct_get(skb, &ctinfo);
+	if ((ctinfo != IP_CT_ESTABLISHED) &&
+	    (ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY))
+		return;
+
+	if (nfct_help(ct))
+		return;
+
+	dir = (ctinfo == IP_CT_ESTABLISHED) ?
+		IP_CT_DIR_ORIGINAL : IP_CT_DIR_REPLY;
+	tuple = &ct->tuplehash[dir].tuple;
+
+	if (tuple->dst.protonum != IPPROTO_TCP &&
+	    tuple->dst.protonum != IPPROTO_UDP)
+		return;
+
+	rtuple = &ct->tuplehash[1 - dir].tuple;
+
+	e = kmalloc(sizeof (*e), GFP_ATOMIC);
+	if (!e)
+		return;
+	e->sip = tuple->src.u3.ip;
+	e->dip = tuple->dst.u3.ip;
+	e->sport = tuple->src.u.all;
+	e->dport = tuple->dst.u.all;
+	e->protocol = tuple->dst.protonum;
+
+	e->manip.new_tos = iph->tos;
+	e->manip.new_sip = rtuple->dst.u3.ip;
+	e->manip.new_dip = rtuple->src.u3.ip;
+	e->manip.new_sport = rtuple->dst.u.all;
+	e->manip.new_dport = rtuple->src.u.all;
+	if (skb->priority != rt_tos2priority(iph->tos)) {
+		e->manip.force_skb_prio = 1;
+		e->manip.new_skb_prio = skb->priority;
+	}
+	e->manip.dst = skb_dst(skb);
+	dst_hold(e->manip.dst);
+	e->manip.ct = ct;
+	e->manip.ctinfo = ctinfo;
+
+	hash = ffn_hash(e->sip, e->dip, e->sport, e->dport,
+			e->protocol == IPPROTO_TCP);
+	proto = (e->protocol == IPPROTO_TCP) ? IPPROTO_TCP : IPPROTO_UDP;
+
+	spin_lock_bh(&ffn_lock);
+	if (__ffn_add_entry(e, proto, hash)) {
+		spin_unlock_bh(&ffn_lock);
+		dst_release(e->manip.dst);
+		kfree(e);
+		return;
+	}
+	spin_unlock_bh(&ffn_lock);
+}
+
+/*
+ * netfilter callback when conntrack is about to be destroyed
+ */
+void ip_ffn_ct_destroy(struct nf_conn *ct)
+{
+	struct nf_conntrack_tuple *tuple;
+	struct ffn_lookup_entry *e;
+	int dir;
+
+	/* locate all entry that use this conntrack */
+	for (dir = 0; dir < 2; dir++) {
+		tuple = &ct->tuplehash[dir].tuple;
+
+		if (tuple->dst.protonum != IPPROTO_TCP &&
+		    tuple->dst.protonum != IPPROTO_UDP)
+			return;
+
+		spin_lock_bh(&ffn_lock);
+		e = __ffn_get(tuple->src.u3.ip, tuple->dst.u3.ip,
+			      tuple->src.u.all, tuple->dst.u.all,
+			      tuple->dst.protonum == IPPROTO_TCP);
+		if (e)
+			__ffn_remove_entry(e);
+		spin_unlock_bh(&ffn_lock);
+	}
+}
+
+/*
+ * initialize ffn cache data
+ */
+static void __ip_ffn_init_cache(void)
+{
+	int i;
+
+	for (i = 0; i < FFN_CACHE_SIZE; i++)
+		INIT_LIST_HEAD(&ffn_cache[i]);
+	INIT_LIST_HEAD(&ffn_all);
+	ffn_entry_count = 0;
+}
+
+/*
+ * flush all ffn cache
+ */
+void ip_ffn_flush_all(void)
+{
+	struct ffn_lookup_entry *e, *tmp;
+
+	spin_lock_bh(&ffn_lock);
+	list_for_each_entry_safe(e, tmp, &ffn_all, all_next)
+		__ffn_remove_entry(e);
+	__ip_ffn_init_cache();
+	spin_unlock_bh(&ffn_lock);
+}
+
+/*
+ * initialize ffn
+ */
+void __init ip_ffn_init(void)
+{
+	printk("IP Fast Forward and NAT enabled\n");
+	__ip_ffn_init_cache();
+}
